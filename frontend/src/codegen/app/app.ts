/**
 * Generated by orval 🍺
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  FavoriteApp,
  GetAppstreamAppstreamAppIdGetParams,
  GetEolMessageAppidEolMessageAppIdGet200,
  GetEolMessageAppidEolMessageAppIdGetParams,
  GetEolMessageEolMessageGet200,
  GetEolRebaseAppidEolRebaseAppIdGet200,
  GetEolRebaseAppidEolRebaseAppIdGetParams,
  GetEolRebaseEolRebaseGet200,
  GetPlatformsPlatformsGet200,
  GetRuntimeListRuntimesGet200,
  GetSummarySummaryAppIdGetParams,
  HTTPValidationError,
  ListAppstreamAppstreamGetParams,
  MeilisearchResponseAppsIndex,
  PostSearchSearchPostParams,
  SearchQuery,
} from ".././model"

/**
 * @summary Get Eol Rebase
 */
export type getEolRebaseEolRebaseGetResponse200 = {
  data: GetEolRebaseEolRebaseGet200
  status: 200
}

export type getEolRebaseEolRebaseGetResponseComposite =
  getEolRebaseEolRebaseGetResponse200

export type getEolRebaseEolRebaseGetResponse =
  getEolRebaseEolRebaseGetResponseComposite & {
    headers: Headers
  }

export const getGetEolRebaseEolRebaseGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/rebase`
}

export const getEolRebaseEolRebaseGet = async (
  options?: RequestInit,
): Promise<getEolRebaseEolRebaseGetResponse> => {
  const res = await fetch(getGetEolRebaseEolRebaseGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getEolRebaseEolRebaseGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getEolRebaseEolRebaseGetResponse
}

export const getGetEolRebaseEolRebaseGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/rebase`] as const
}

export const getGetEolRebaseEolRebaseGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetEolRebaseEolRebaseGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>
  > = ({ signal }) => getEolRebaseEolRebaseGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEolRebaseEolRebaseGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>
>
export type GetEolRebaseEolRebaseGetQueryError = unknown

export function useGetEolRebaseEolRebaseGet<
  TData = Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
          TError,
          Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolRebaseEolRebaseGet<
  TData = Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
          TError,
          Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolRebaseEolRebaseGet<
  TData = Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Eol Rebase
 */

export function useGetEolRebaseEolRebaseGet<
  TData = Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseEolRebaseGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEolRebaseEolRebaseGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Eol Rebase Appid
 */
export type getEolRebaseAppidEolRebaseAppIdGetResponse200 = {
  data: GetEolRebaseAppidEolRebaseAppIdGet200
  status: 200
}

export type getEolRebaseAppidEolRebaseAppIdGetResponse404 = {
  data: null
  status: 404
}

export type getEolRebaseAppidEolRebaseAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getEolRebaseAppidEolRebaseAppIdGetResponseComposite =
  | getEolRebaseAppidEolRebaseAppIdGetResponse200
  | getEolRebaseAppidEolRebaseAppIdGetResponse404
  | getEolRebaseAppidEolRebaseAppIdGetResponse422

export type getEolRebaseAppidEolRebaseAppIdGetResponse =
  getEolRebaseAppidEolRebaseAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetEolRebaseAppidEolRebaseAppIdGetUrl = (
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/rebase/${appId}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/rebase/${appId}`
}

export const getEolRebaseAppidEolRebaseAppIdGet = async (
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
  options?: RequestInit,
): Promise<getEolRebaseAppidEolRebaseAppIdGetResponse> => {
  const res = await fetch(
    getGetEolRebaseAppidEolRebaseAppIdGetUrl(appId, params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getEolRebaseAppidEolRebaseAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getEolRebaseAppidEolRebaseAppIdGetResponse
}

export const getGetEolRebaseAppidEolRebaseAppIdGetQueryKey = (
  appId?: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/rebase/${appId}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetEolRebaseAppidEolRebaseAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetEolRebaseAppidEolRebaseAppIdGetQueryKey(appId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>
  > = ({ signal }) =>
    getEolRebaseAppidEolRebaseAppIdGet(appId, params, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEolRebaseAppidEolRebaseAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>
>
export type GetEolRebaseAppidEolRebaseAppIdGetQueryError =
  null | HTTPValidationError

export function useGetEolRebaseAppidEolRebaseAppIdGet<
  TData = Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params: undefined | GetEolRebaseAppidEolRebaseAppIdGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolRebaseAppidEolRebaseAppIdGet<
  TData = Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolRebaseAppidEolRebaseAppIdGet<
  TData = Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Eol Rebase Appid
 */

export function useGetEolRebaseAppidEolRebaseAppIdGet<
  TData = Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolRebaseAppidEolRebaseAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolRebaseAppidEolRebaseAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEolRebaseAppidEolRebaseAppIdGetQueryOptions(
    appId,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Eol Message
 */
export type getEolMessageEolMessageGetResponse200 = {
  data: GetEolMessageEolMessageGet200
  status: 200
}

export type getEolMessageEolMessageGetResponseComposite =
  getEolMessageEolMessageGetResponse200

export type getEolMessageEolMessageGetResponse =
  getEolMessageEolMessageGetResponseComposite & {
    headers: Headers
  }

export const getGetEolMessageEolMessageGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/message`
}

export const getEolMessageEolMessageGet = async (
  options?: RequestInit,
): Promise<getEolMessageEolMessageGetResponse> => {
  const res = await fetch(getGetEolMessageEolMessageGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getEolMessageEolMessageGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getEolMessageEolMessageGetResponse
}

export const getGetEolMessageEolMessageGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/message`] as const
}

export const getGetEolMessageEolMessageGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetEolMessageEolMessageGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEolMessageEolMessageGet>>
  > = ({ signal }) => getEolMessageEolMessageGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEolMessageEolMessageGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEolMessageEolMessageGet>>
>
export type GetEolMessageEolMessageGetQueryError = unknown

export function useGetEolMessageEolMessageGet<
  TData = Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
          TError,
          Awaited<ReturnType<typeof getEolMessageEolMessageGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolMessageEolMessageGet<
  TData = Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
          TError,
          Awaited<ReturnType<typeof getEolMessageEolMessageGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolMessageEolMessageGet<
  TData = Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Eol Message
 */

export function useGetEolMessageEolMessageGet<
  TData = Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageEolMessageGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEolMessageEolMessageGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Eol Message Appid
 */
export type getEolMessageAppidEolMessageAppIdGetResponse200 = {
  data: GetEolMessageAppidEolMessageAppIdGet200
  status: 200
}

export type getEolMessageAppidEolMessageAppIdGetResponse404 = {
  data: null
  status: 404
}

export type getEolMessageAppidEolMessageAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getEolMessageAppidEolMessageAppIdGetResponseComposite =
  | getEolMessageAppidEolMessageAppIdGetResponse200
  | getEolMessageAppidEolMessageAppIdGetResponse404
  | getEolMessageAppidEolMessageAppIdGetResponse422

export type getEolMessageAppidEolMessageAppIdGetResponse =
  getEolMessageAppidEolMessageAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetEolMessageAppidEolMessageAppIdGetUrl = (
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/message/${appId}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/message/${appId}`
}

export const getEolMessageAppidEolMessageAppIdGet = async (
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
  options?: RequestInit,
): Promise<getEolMessageAppidEolMessageAppIdGetResponse> => {
  const res = await fetch(
    getGetEolMessageAppidEolMessageAppIdGetUrl(appId, params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getEolMessageAppidEolMessageAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getEolMessageAppidEolMessageAppIdGetResponse
}

export const getGetEolMessageAppidEolMessageAppIdGetQueryKey = (
  appId?: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/eol/message/${appId}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetEolMessageAppidEolMessageAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetEolMessageAppidEolMessageAppIdGetQueryKey(appId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>
  > = ({ signal }) =>
    getEolMessageAppidEolMessageAppIdGet(appId, params, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEolMessageAppidEolMessageAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>
>
export type GetEolMessageAppidEolMessageAppIdGetQueryError =
  null | HTTPValidationError

export function useGetEolMessageAppidEolMessageAppIdGet<
  TData = Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params: undefined | GetEolMessageAppidEolMessageAppIdGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolMessageAppidEolMessageAppIdGet<
  TData = Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEolMessageAppidEolMessageAppIdGet<
  TData = Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Eol Message Appid
 */

export function useGetEolMessageAppidEolMessageAppIdGet<
  TData = Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetEolMessageAppidEolMessageAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEolMessageAppidEolMessageAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEolMessageAppidEolMessageAppIdGetQueryOptions(
    appId,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary List Appstream
 */
export type listAppstreamAppstreamGetResponse200 = {
  data: string[]
  status: 200
}

export type listAppstreamAppstreamGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAppstreamAppstreamGetResponseComposite =
  | listAppstreamAppstreamGetResponse200
  | listAppstreamAppstreamGetResponse422

export type listAppstreamAppstreamGetResponse =
  listAppstreamAppstreamGetResponseComposite & {
    headers: Headers
  }

export const getListAppstreamAppstreamGetUrl = (
  params?: ListAppstreamAppstreamGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream`
}

export const listAppstreamAppstreamGet = async (
  params?: ListAppstreamAppstreamGetParams,
  options?: RequestInit,
): Promise<listAppstreamAppstreamGetResponse> => {
  const res = await fetch(getListAppstreamAppstreamGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: listAppstreamAppstreamGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listAppstreamAppstreamGetResponse
}

export const getListAppstreamAppstreamGetQueryKey = (
  params?: ListAppstreamAppstreamGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream`,
    ...(params ? [params] : []),
  ] as const
}

export const getListAppstreamAppstreamGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAppstreamAppstreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getListAppstreamAppstreamGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listAppstreamAppstreamGet>>
  > = ({ signal }) =>
    listAppstreamAppstreamGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAppstreamAppstreamGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAppstreamAppstreamGet>>
>
export type ListAppstreamAppstreamGetQueryError = HTTPValidationError

export function useListAppstreamAppstreamGet<
  TData = Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListAppstreamAppstreamGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
          TError,
          Awaited<ReturnType<typeof listAppstreamAppstreamGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAppstreamAppstreamGet<
  TData = Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAppstreamAppstreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
          TError,
          Awaited<ReturnType<typeof listAppstreamAppstreamGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAppstreamAppstreamGet<
  TData = Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAppstreamAppstreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List Appstream
 */

export function useListAppstreamAppstreamGet<
  TData = Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAppstreamAppstreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAppstreamAppstreamGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAppstreamAppstreamGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Appstream
 */
export type getAppstreamAppstreamAppIdGetResponse200 = {
  data: unknown
  status: 200
}

export type getAppstreamAppstreamAppIdGetResponse404 = {
  data: null
  status: 404
}

export type getAppstreamAppstreamAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAppstreamAppstreamAppIdGetResponseComposite =
  | getAppstreamAppstreamAppIdGetResponse200
  | getAppstreamAppstreamAppIdGetResponse404
  | getAppstreamAppstreamAppIdGetResponse422

export type getAppstreamAppstreamAppIdGetResponse =
  getAppstreamAppstreamAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetAppstreamAppstreamAppIdGetUrl = (
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream/${appId}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream/${appId}`
}

export const getAppstreamAppstreamAppIdGet = async (
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
  options?: RequestInit,
): Promise<getAppstreamAppstreamAppIdGetResponse> => {
  const res = await fetch(getGetAppstreamAppstreamAppIdGetUrl(appId, params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAppstreamAppstreamAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getAppstreamAppstreamAppIdGetResponse
}

export const getGetAppstreamAppstreamAppIdGetQueryKey = (
  appId?: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/appstream/${appId}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetAppstreamAppstreamAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAppstreamAppstreamAppIdGetQueryKey(appId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>
  > = ({ signal }) =>
    getAppstreamAppstreamAppIdGet(appId, params, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppstreamAppstreamAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>
>
export type GetAppstreamAppstreamAppIdGetQueryError = null | HTTPValidationError

export function useGetAppstreamAppstreamAppIdGet<
  TData = Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params: undefined | GetAppstreamAppstreamAppIdGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppstreamAppstreamAppIdGet<
  TData = Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppstreamAppstreamAppIdGet<
  TData = Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Appstream
 */

export function useGetAppstreamAppstreamAppIdGet<
  TData = Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetAppstreamAppstreamAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppstreamAppstreamAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAppstreamAppstreamAppIdGetQueryOptions(
    appId,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Isfullscreenapp
 */
export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse200 = {
  data: boolean
  status: 200
}

export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getIsFullscreenAppIsFullscreenAppAppIdGetResponseComposite =
  | getIsFullscreenAppIsFullscreenAppAppIdGetResponse200
  | getIsFullscreenAppIsFullscreenAppAppIdGetResponse422

export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse =
  getIsFullscreenAppIsFullscreenAppAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetIsFullscreenAppIsFullscreenAppAppIdGetUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/is-fullscreen-app/${appId}`
}

export const getIsFullscreenAppIsFullscreenAppAppIdGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getIsFullscreenAppIsFullscreenAppAppIdGetResponse> => {
  const res = await fetch(
    getGetIsFullscreenAppIsFullscreenAppAppIdGetUrl(appId),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getIsFullscreenAppIsFullscreenAppAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getIsFullscreenAppIsFullscreenAppAppIdGetResponse
}

export const getGetIsFullscreenAppIsFullscreenAppAppIdGetQueryKey = (
  appId?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/is-fullscreen-app/${appId}`,
  ] as const
}

export const getGetIsFullscreenAppIsFullscreenAppAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetIsFullscreenAppIsFullscreenAppAppIdGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>
  > = ({ signal }) =>
    getIsFullscreenAppIsFullscreenAppAppIdGet(appId, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIsFullscreenAppIsFullscreenAppAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>
>
export type GetIsFullscreenAppIsFullscreenAppAppIdGetQueryError =
  HTTPValidationError

export function useGetIsFullscreenAppIsFullscreenAppAppIdGet<
  TData = Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetIsFullscreenAppIsFullscreenAppAppIdGet<
  TData = Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetIsFullscreenAppIsFullscreenAppAppIdGet<
  TData = Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Isfullscreenapp
 */

export function useGetIsFullscreenAppIsFullscreenAppAppIdGet<
  TData = Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIsFullscreenAppIsFullscreenAppAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetIsFullscreenAppIsFullscreenAppAppIdGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Post Search
 */
export type postSearchSearchPostResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type postSearchSearchPostResponse400 = {
  data: null
  status: 400
}

export type postSearchSearchPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type postSearchSearchPostResponseComposite =
  | postSearchSearchPostResponse200
  | postSearchSearchPostResponse400
  | postSearchSearchPostResponse422

export type postSearchSearchPostResponse =
  postSearchSearchPostResponseComposite & {
    headers: Headers
  }

export const getPostSearchSearchPostUrl = (
  params?: PostSearchSearchPostParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/search?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/search`
}

export const postSearchSearchPost = async (
  searchQuery: SearchQuery,
  params?: PostSearchSearchPostParams,
  options?: RequestInit,
): Promise<postSearchSearchPostResponse> => {
  const res = await fetch(getPostSearchSearchPostUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(searchQuery),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postSearchSearchPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postSearchSearchPostResponse
}

export const getPostSearchSearchPostMutationOptions = <
  TError = null | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postSearchSearchPost>>,
    TError,
    { data: SearchQuery; params?: PostSearchSearchPostParams },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof postSearchSearchPost>>,
  TError,
  { data: SearchQuery; params?: PostSearchSearchPostParams },
  TContext
> => {
  const mutationKey = ["postSearchSearchPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postSearchSearchPost>>,
    { data: SearchQuery; params?: PostSearchSearchPostParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return postSearchSearchPost(data, params, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostSearchSearchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof postSearchSearchPost>>
>
export type PostSearchSearchPostMutationBody = SearchQuery
export type PostSearchSearchPostMutationError = null | HTTPValidationError

/**
 * @summary Post Search
 */
export const usePostSearchSearchPost = <
  TError = null | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postSearchSearchPost>>,
      TError,
      { data: SearchQuery; params?: PostSearchSearchPostParams },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postSearchSearchPost>>,
  TError,
  { data: SearchQuery; params?: PostSearchSearchPostParams },
  TContext
> => {
  const mutationOptions = getPostSearchSearchPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get Runtime List
 */
export type getRuntimeListRuntimesGetResponse200 = {
  data: GetRuntimeListRuntimesGet200
  status: 200
}

export type getRuntimeListRuntimesGetResponseComposite =
  getRuntimeListRuntimesGetResponse200

export type getRuntimeListRuntimesGetResponse =
  getRuntimeListRuntimesGetResponseComposite & {
    headers: Headers
  }

export const getGetRuntimeListRuntimesGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/runtimes`
}

export const getRuntimeListRuntimesGet = async (
  options?: RequestInit,
): Promise<getRuntimeListRuntimesGetResponse> => {
  const res = await fetch(getGetRuntimeListRuntimesGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getRuntimeListRuntimesGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getRuntimeListRuntimesGetResponse
}

export const getGetRuntimeListRuntimesGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/runtimes`] as const
}

export const getGetRuntimeListRuntimesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetRuntimeListRuntimesGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>
  > = ({ signal }) => getRuntimeListRuntimesGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRuntimeListRuntimesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>
>
export type GetRuntimeListRuntimesGetQueryError = unknown

export function useGetRuntimeListRuntimesGet<
  TData = Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
          TError,
          Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRuntimeListRuntimesGet<
  TData = Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
          TError,
          Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRuntimeListRuntimesGet<
  TData = Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Runtime List
 */

export function useGetRuntimeListRuntimesGet<
  TData = Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRuntimeListRuntimesGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetRuntimeListRuntimesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Summary
 */
export type getSummarySummaryAppIdGetResponse200 = {
  data: unknown
  status: 200
}

export type getSummarySummaryAppIdGetResponse404 = {
  data: null
  status: 404
}

export type getSummarySummaryAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSummarySummaryAppIdGetResponseComposite =
  | getSummarySummaryAppIdGetResponse200
  | getSummarySummaryAppIdGetResponse404
  | getSummarySummaryAppIdGetResponse422

export type getSummarySummaryAppIdGetResponse =
  getSummarySummaryAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetSummarySummaryAppIdGetUrl = (
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/summary/${appId}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/summary/${appId}`
}

export const getSummarySummaryAppIdGet = async (
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
  options?: RequestInit,
): Promise<getSummarySummaryAppIdGetResponse> => {
  const res = await fetch(getGetSummarySummaryAppIdGetUrl(appId, params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSummarySummaryAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getSummarySummaryAppIdGetResponse
}

export const getGetSummarySummaryAppIdGetQueryKey = (
  appId?: string,
  params?: GetSummarySummaryAppIdGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/summary/${appId}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetSummarySummaryAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetSummarySummaryAppIdGetQueryKey(appId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>
  > = ({ signal }) =>
    getSummarySummaryAppIdGet(appId, params, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSummarySummaryAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>
>
export type GetSummarySummaryAppIdGetQueryError = null | HTTPValidationError

export function useGetSummarySummaryAppIdGet<
  TData = Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params: undefined | GetSummarySummaryAppIdGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSummarySummaryAppIdGet<
  TData = Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSummarySummaryAppIdGet<
  TData = Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Summary
 */

export function useGetSummarySummaryAppIdGet<
  TData = Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
  TError = null | HTTPValidationError,
>(
  appId: string,
  params?: GetSummarySummaryAppIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSummarySummaryAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSummarySummaryAppIdGetQueryOptions(
    appId,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Return a mapping from org-name to platform aliases and dependencies which are
recognised by the backend.  These are used by things such as the transactions
and donations APIs to address amounts to the platforms.
 * @summary Get Platforms
 */
export type getPlatformsPlatformsGetResponse200 = {
  data: GetPlatformsPlatformsGet200
  status: 200
}

export type getPlatformsPlatformsGetResponseComposite =
  getPlatformsPlatformsGetResponse200

export type getPlatformsPlatformsGetResponse =
  getPlatformsPlatformsGetResponseComposite & {
    headers: Headers
  }

export const getGetPlatformsPlatformsGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/platforms`
}

export const getPlatformsPlatformsGet = async (
  options?: RequestInit,
): Promise<getPlatformsPlatformsGetResponse> => {
  const res = await fetch(getGetPlatformsPlatformsGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPlatformsPlatformsGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getPlatformsPlatformsGetResponse
}

export const getGetPlatformsPlatformsGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/platforms`] as const
}

export const getGetPlatformsPlatformsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetPlatformsPlatformsGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPlatformsPlatformsGet>>
  > = ({ signal }) => getPlatformsPlatformsGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPlatformsPlatformsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlatformsPlatformsGet>>
>
export type GetPlatformsPlatformsGetQueryError = unknown

export function useGetPlatformsPlatformsGet<
  TData = Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlatformsPlatformsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlatformsPlatformsGet<
  TData = Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlatformsPlatformsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPlatformsPlatformsGet<
  TData = Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Platforms
 */

export function useGetPlatformsPlatformsGet<
  TData = Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlatformsPlatformsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetPlatformsPlatformsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Addons
 */
export type getAddonsAddonAppIdGetResponse200 = {
  data: string[]
  status: 200
}

export type getAddonsAddonAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAddonsAddonAppIdGetResponseComposite =
  | getAddonsAddonAppIdGetResponse200
  | getAddonsAddonAppIdGetResponse422

export type getAddonsAddonAppIdGetResponse =
  getAddonsAddonAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetAddonsAddonAppIdGetUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/addon/${appId}`
}

export const getAddonsAddonAppIdGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getAddonsAddonAppIdGetResponse> => {
  const res = await fetch(getGetAddonsAddonAppIdGetUrl(appId), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAddonsAddonAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getAddonsAddonAppIdGetResponse
}

export const getGetAddonsAddonAppIdGetQueryKey = (appId?: string) => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/addon/${appId}`] as const
}

export const getGetAddonsAddonAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAddonsAddonAppIdGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>
  > = ({ signal }) => getAddonsAddonAppIdGet(appId, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAddonsAddonAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>
>
export type GetAddonsAddonAppIdGetQueryError = HTTPValidationError

export function useGetAddonsAddonAppIdGet<
  TData = Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAddonsAddonAppIdGet<
  TData = Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAddonsAddonAppIdGet<
  TData = Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Addons
 */

export function useGetAddonsAddonAppIdGet<
  TData = Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAddonsAddonAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAddonsAddonAppIdGetQueryOptions(appId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Exceptions
 */
export type getExceptionsExceptionsGetResponse200 = {
  data: unknown
  status: 200
}

export type getExceptionsExceptionsGetResponse500 = {
  data: null
  status: 500
}

export type getExceptionsExceptionsGetResponseComposite =
  | getExceptionsExceptionsGetResponse200
  | getExceptionsExceptionsGetResponse500

export type getExceptionsExceptionsGetResponse =
  getExceptionsExceptionsGetResponseComposite & {
    headers: Headers
  }

export const getGetExceptionsExceptionsGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/exceptions/`
}

export const getExceptionsExceptionsGet = async (
  options?: RequestInit,
): Promise<getExceptionsExceptionsGetResponse> => {
  const res = await fetch(getGetExceptionsExceptionsGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getExceptionsExceptionsGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getExceptionsExceptionsGetResponse
}

export const getGetExceptionsExceptionsGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/exceptions/`] as const
}

export const getGetExceptionsExceptionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetExceptionsExceptionsGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExceptionsExceptionsGet>>
  > = ({ signal }) => getExceptionsExceptionsGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExceptionsExceptionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExceptionsExceptionsGet>>
>
export type GetExceptionsExceptionsGetQueryError = null

export function useGetExceptionsExceptionsGet<
  TData = Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
          TError,
          Awaited<ReturnType<typeof getExceptionsExceptionsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetExceptionsExceptionsGet<
  TData = Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
          TError,
          Awaited<ReturnType<typeof getExceptionsExceptionsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetExceptionsExceptionsGet<
  TData = Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Exceptions
 */

export function useGetExceptionsExceptionsGet<
  TData = Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsExceptionsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetExceptionsExceptionsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Exceptions For App
 */
export type getExceptionsForAppExceptionsAppIdGetResponse200 = {
  data: unknown
  status: 200
}

export type getExceptionsForAppExceptionsAppIdGetResponse404 = {
  data: null
  status: 404
}

export type getExceptionsForAppExceptionsAppIdGetResponse422 = {
  data: null
  status: 422
}

export type getExceptionsForAppExceptionsAppIdGetResponse500 = {
  data: null
  status: 500
}

export type getExceptionsForAppExceptionsAppIdGetResponseComposite =
  | getExceptionsForAppExceptionsAppIdGetResponse200
  | getExceptionsForAppExceptionsAppIdGetResponse404
  | getExceptionsForAppExceptionsAppIdGetResponse422
  | getExceptionsForAppExceptionsAppIdGetResponse500

export type getExceptionsForAppExceptionsAppIdGetResponse =
  getExceptionsForAppExceptionsAppIdGetResponseComposite & {
    headers: Headers
  }

export const getGetExceptionsForAppExceptionsAppIdGetUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/exceptions/${appId}`
}

export const getExceptionsForAppExceptionsAppIdGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getExceptionsForAppExceptionsAppIdGetResponse> => {
  const res = await fetch(getGetExceptionsForAppExceptionsAppIdGetUrl(appId), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getExceptionsForAppExceptionsAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getExceptionsForAppExceptionsAppIdGetResponse
}

export const getGetExceptionsForAppExceptionsAppIdGetQueryKey = (
  appId?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/exceptions/${appId}`,
  ] as const
}

export const getGetExceptionsForAppExceptionsAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
  TError = null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetExceptionsForAppExceptionsAppIdGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>
  > = ({ signal }) =>
    getExceptionsForAppExceptionsAppIdGet(appId, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExceptionsForAppExceptionsAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>
>
export type GetExceptionsForAppExceptionsAppIdGetQueryError = null | null | null

export function useGetExceptionsForAppExceptionsAppIdGet<
  TData = Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
  TError = null | null | null,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetExceptionsForAppExceptionsAppIdGet<
  TData = Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
  TError = null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetExceptionsForAppExceptionsAppIdGet<
  TData = Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
  TError = null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Exceptions For App
 */

export function useGetExceptionsForAppExceptionsAppIdGet<
  TData = Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
  TError = null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExceptionsForAppExceptionsAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetExceptionsForAppExceptionsAppIdGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Add an app to a users favorites. The appid is the ID of the app to add.
 * @summary Add To Favorites
 */
export type addToFavoritesFavoritesAppIdAddPostResponse200 = {
  data: unknown
  status: 200
}

export type addToFavoritesFavoritesAppIdAddPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type addToFavoritesFavoritesAppIdAddPostResponse500 = {
  data: null
  status: 500
}

export type addToFavoritesFavoritesAppIdAddPostResponseComposite =
  | addToFavoritesFavoritesAppIdAddPostResponse200
  | addToFavoritesFavoritesAppIdAddPostResponse422
  | addToFavoritesFavoritesAppIdAddPostResponse500

export type addToFavoritesFavoritesAppIdAddPostResponse =
  addToFavoritesFavoritesAppIdAddPostResponseComposite & {
    headers: Headers
  }

export const getAddToFavoritesFavoritesAppIdAddPostUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites/${appId}/add`
}

export const addToFavoritesFavoritesAppIdAddPost = async (
  appId: string,
  options?: RequestInit,
): Promise<addToFavoritesFavoritesAppIdAddPostResponse> => {
  const res = await fetch(getAddToFavoritesFavoritesAppIdAddPostUrl(appId), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: addToFavoritesFavoritesAppIdAddPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as addToFavoritesFavoritesAppIdAddPostResponse
}

export const getAddToFavoritesFavoritesAppIdAddPostMutationOptions = <
  TError = HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>,
    TError,
    { appId: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationKey = ["addToFavoritesFavoritesAppIdAddPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>,
    { appId: string }
  > = (props) => {
    const { appId } = props ?? {}

    return addToFavoritesFavoritesAppIdAddPost(appId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddToFavoritesFavoritesAppIdAddPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>
>

export type AddToFavoritesFavoritesAppIdAddPostMutationError =
  HTTPValidationError | null

/**
 * @summary Add To Favorites
 */
export const useAddToFavoritesFavoritesAppIdAddPost = <
  TError = HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>,
      TError,
      { appId: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addToFavoritesFavoritesAppIdAddPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationOptions =
    getAddToFavoritesFavoritesAppIdAddPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Remove an app from a users favorites. The appid is the ID of the app to remove.
 * @summary Remove From Favorites
 */
export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse200 = {
  data: unknown
  status: 200
}

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse500 = {
  data: null
  status: 500
}

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponseComposite =
  | removeFromFavoritesFavoritesAppIdRemoveDeleteResponse200
  | removeFromFavoritesFavoritesAppIdRemoveDeleteResponse422
  | removeFromFavoritesFavoritesAppIdRemoveDeleteResponse500

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse =
  removeFromFavoritesFavoritesAppIdRemoveDeleteResponseComposite & {
    headers: Headers
  }

export const getRemoveFromFavoritesFavoritesAppIdRemoveDeleteUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites/${appId}/remove`
}

export const removeFromFavoritesFavoritesAppIdRemoveDelete = async (
  appId: string,
  options?: RequestInit,
): Promise<removeFromFavoritesFavoritesAppIdRemoveDeleteResponse> => {
  const res = await fetch(
    getRemoveFromFavoritesFavoritesAppIdRemoveDeleteUrl(appId),
    {
      ...options,
      method: "DELETE",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: removeFromFavoritesFavoritesAppIdRemoveDeleteResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as removeFromFavoritesFavoritesAppIdRemoveDeleteResponse
}

export const getRemoveFromFavoritesFavoritesAppIdRemoveDeleteMutationOptions = <
  TError = HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>,
    TError,
    { appId: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationKey = ["removeFromFavoritesFavoritesAppIdRemoveDelete"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>,
    { appId: string }
  > = (props) => {
    const { appId } = props ?? {}

    return removeFromFavoritesFavoritesAppIdRemoveDelete(appId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RemoveFromFavoritesFavoritesAppIdRemoveDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>
  >

export type RemoveFromFavoritesFavoritesAppIdRemoveDeleteMutationError =
  HTTPValidationError | null

/**
 * @summary Remove From Favorites
 */
export const useRemoveFromFavoritesFavoritesAppIdRemoveDelete = <
  TError = HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>,
      TError,
      { appId: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeFromFavoritesFavoritesAppIdRemoveDelete>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationOptions =
    getRemoveFromFavoritesFavoritesAppIdRemoveDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get a list of the users favorite apps.
 * @summary Get Favorites
 */
export type getFavoritesFavoritesGetResponse200 = {
  data: FavoriteApp[]
  status: 200
}

export type getFavoritesFavoritesGetResponseComposite =
  getFavoritesFavoritesGetResponse200

export type getFavoritesFavoritesGetResponse =
  getFavoritesFavoritesGetResponseComposite & {
    headers: Headers
  }

export const getGetFavoritesFavoritesGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites`
}

export const getFavoritesFavoritesGet = async (
  options?: RequestInit,
): Promise<getFavoritesFavoritesGetResponse> => {
  const res = await fetch(getGetFavoritesFavoritesGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getFavoritesFavoritesGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getFavoritesFavoritesGetResponse
}

export const getGetFavoritesFavoritesGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites`] as const
}

export const getGetFavoritesFavoritesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetFavoritesFavoritesGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFavoritesFavoritesGet>>
  > = ({ signal }) => getFavoritesFavoritesGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFavoritesFavoritesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFavoritesFavoritesGet>>
>
export type GetFavoritesFavoritesGetQueryError = unknown

export function useGetFavoritesFavoritesGet<
  TData = Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesFavoritesGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFavoritesFavoritesGet<
  TData = Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesFavoritesGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetFavoritesFavoritesGet<
  TData = Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Favorites
 */

export function useGetFavoritesFavoritesGet<
  TData = Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFavoritesFavoritesGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetFavoritesFavoritesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Is Favorited
 */
export type isFavoritedFavoritesAppIdGetResponse200 = {
  data: boolean
  status: 200
}

export type isFavoritedFavoritesAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type isFavoritedFavoritesAppIdGetResponseComposite =
  | isFavoritedFavoritesAppIdGetResponse200
  | isFavoritedFavoritesAppIdGetResponse422

export type isFavoritedFavoritesAppIdGetResponse =
  isFavoritedFavoritesAppIdGetResponseComposite & {
    headers: Headers
  }

export const getIsFavoritedFavoritesAppIdGetUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites/${appId}`
}

export const isFavoritedFavoritesAppIdGet = async (
  appId: string,
  options?: RequestInit,
): Promise<isFavoritedFavoritesAppIdGetResponse> => {
  const res = await fetch(getIsFavoritedFavoritesAppIdGetUrl(appId), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: isFavoritedFavoritesAppIdGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as isFavoritedFavoritesAppIdGetResponse
}

export const getIsFavoritedFavoritesAppIdGetQueryKey = (appId?: string) => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/favorites/${appId}`] as const
}

export const getIsFavoritedFavoritesAppIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getIsFavoritedFavoritesAppIdGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>
  > = ({ signal }) =>
    isFavoritedFavoritesAppIdGet(appId, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsFavoritedFavoritesAppIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>
>
export type IsFavoritedFavoritesAppIdGetQueryError = HTTPValidationError

export function useIsFavoritedFavoritesAppIdGet<
  TData = Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useIsFavoritedFavoritesAppIdGet<
  TData = Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
          TError,
          Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useIsFavoritedFavoritesAppIdGet<
  TData = Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Is Favorited
 */

export function useIsFavoritedFavoritesAppIdGet<
  TData = Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
  TError = HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isFavoritedFavoritesAppIdGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getIsFavoritedFavoritesAppIdGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
