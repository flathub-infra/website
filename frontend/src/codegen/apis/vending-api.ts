/* tslint:disable */
/* eslint-disable */
/**
 * Flathub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base"
// @ts-ignore
import { HTTPValidationError } from "../model"
// @ts-ignore
import { ProposedPayment } from "../model"
// @ts-ignore
import { RedemptionResult } from "../model"
// @ts-ignore
import { TokenCancellation } from "../model"
// @ts-ignore
import { TokenList } from "../model"
// @ts-ignore
import { TokenModel } from "../model"
// @ts-ignore
import { VendingApplicationInformation } from "../model"
// @ts-ignore
import { VendingConfig } from "../model"
// @ts-ignore
import { VendingOnboardingRequest } from "../model"
// @ts-ignore
import { VendingOutput } from "../model"
// @ts-ignore
import { VendingRedirect } from "../model"
// @ts-ignore
import { VendingSetup } from "../model"
// @ts-ignore
import { VendingStatus } from "../model"
/**
 * VendingApi - axios parameter creator
 * @export
 */
export const VendingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This determines the vending info for the app and returns it
     * @summary App Info
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appInfoVendingappAppIdInfoGet: async (
      appId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("appInfoVendingappAppIdInfoGet", "appId", appId)
      const localVarPath = `/vendingapp/{app_id}/info`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Cancel a set of tokens
     * @summary Cancel Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTokensVendingappAppIdTokensCancelPost: async (
      appId: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "cancelTokensVendingappAppIdTokensCancelPost",
        "appId",
        appId,
      )
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "cancelTokensVendingappAppIdTokensCancelPost",
        "requestBody",
        requestBody,
      )
      const localVarPath = `/vendingapp/{app_id}/tokens/cancel`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create some tokens for the given appid.  The calling user must own the vending config for this application
     * @summary Create Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokensVendingappAppIdTokensPost: async (
      appId: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("createTokensVendingappAppIdTokensPost", "appId", appId)
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "createTokensVendingappAppIdTokensPost",
        "requestBody",
        requestBody,
      )
      const localVarPath = `/vendingapp/{app_id}/tokens`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the vending status for a given application.  Returns a no content response if the appid has no vending setup.
     * @summary Get App Vending Setup
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppVendingSetupVendingappAppIdSetupGet: async (
      appId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "getAppVendingSetupVendingappAppIdSetupGet",
        "appId",
        appId,
      )
      const localVarPath = `/vendingapp/{app_id}/setup`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a link to the logged in user\'s Stripe express dashboard.  The user must be logged in and must have onboarded.
     * @summary Get Dashboard Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDashboardLinkVendingStatusDashboardlinkGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vending/status/dashboardlink`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the configuration values needed to calculate application vending splits client-side.  Configuration includes: - Fee values - Platform values
     * @summary Get Global Vending Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGlobalVendingConfigVendingConfigGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vending/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the redeemable tokens for the given application.  The caller must have control of the app at some level  For now, there is no pagination or filtering, all tokens will be returned
     * @summary Get Redeemable Tokens
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRedeemableTokensVendingappAppIdTokensGet: async (
      appId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "getRedeemableTokensVendingappAppIdTokensGet",
        "appId",
        appId,
      )
      const localVarPath = `/vendingapp/{app_id}/tokens`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create/update the vending status for a given application.  Returns an error if the appid is not known, or if it\'s already set up for vending with a user other than the one calling this API.  If you do not have the right to set the vending status for this application then you will also be refused.  In addition, if any of the currency or amount values constraints are violated then you will get an error
     * @summary Post App Vending Setup
     * @param {string} appId
     * @param {VendingSetup} vendingSetup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppVendingSetupVendingappAppIdSetupPost: async (
      appId: string,
      vendingSetup: VendingSetup,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "postAppVendingSetupVendingappAppIdSetupPost",
        "appId",
        appId,
      )
      // verify required parameter 'vendingSetup' is not null or undefined
      assertParamExists(
        "postAppVendingSetupVendingappAppIdSetupPost",
        "vendingSetup",
        vendingSetup,
      )
      const localVarPath = `/vendingapp/{app_id}/setup`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vendingSetup,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Construct a transaction for the given application with the proposed payment. If the proposed payment is unacceptable then an error will be returned. If the user is not logged in, then an error will be returned.  Otherwise a transaction will be created and the information about it will be returned in the output of the call.
     * @summary Post App Vending Status
     * @param {string} appId
     * @param {ProposedPayment} proposedPayment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppVendingStatusVendingappAppIdPost: async (
      appId: string,
      proposedPayment: ProposedPayment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "postAppVendingStatusVendingappAppIdPost",
        "appId",
        appId,
      )
      // verify required parameter 'proposedPayment' is not null or undefined
      assertParamExists(
        "postAppVendingStatusVendingappAppIdPost",
        "proposedPayment",
        proposedPayment,
      )
      const localVarPath = `/vendingapp/{app_id}`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        proposedPayment,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This redeems the given token for the logged in user.  If the logged in user already owns the app then the token will not be redeemed
     * @summary Redeem Token
     * @param {string} appId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemTokenVendingappAppIdTokensRedeemTokenPost: async (
      appId: string,
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "redeemTokenVendingappAppIdTokensRedeemTokenPost",
        "appId",
        appId,
      )
      // verify required parameter 'token' is not null or undefined
      assertParamExists(
        "redeemTokenVendingappAppIdTokensRedeemTokenPost",
        "token",
        token,
      )
      const localVarPath = `/vendingapp/{app_id}/tokens/redeem/{token}`
        .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
        .replace(`{${"token"}}`, encodeURIComponent(String(token)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start or continue the onboarding process.
     * @summary Start Onboarding
     * @param {VendingOnboardingRequest} vendingOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startOnboardingVendingStatusOnboardingPost: async (
      vendingOnboardingRequest: VendingOnboardingRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'vendingOnboardingRequest' is not null or undefined
      assertParamExists(
        "startOnboardingVendingStatusOnboardingPost",
        "vendingOnboardingRequest",
        vendingOnboardingRequest,
      )
      const localVarPath = `/vending/status/onboarding`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vendingOnboardingRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the vending status of the logged in user.  This will return `201` if the logged in user has never begun the onboarding flow to be a vendor on Flathub.
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusVendingStatusGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vending/status`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VendingApi - functional programming interface
 * @export
 */
export const VendingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VendingApiAxiosParamCreator(configuration)
  return {
    /**
     * This determines the vending info for the app and returns it
     * @summary App Info
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appInfoVendingappAppIdInfoGet(
      appId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VendingApplicationInformation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.appInfoVendingappAppIdInfoGet(
          appId,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Cancel a set of tokens
     * @summary Cancel Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTokensVendingappAppIdTokensCancelPost(
      appId: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenCancellation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cancelTokensVendingappAppIdTokensCancelPost(
          appId,
          requestBody,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Create some tokens for the given appid.  The calling user must own the vending config for this application
     * @summary Create Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTokensVendingappAppIdTokensPost(
      appId: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenModel>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createTokensVendingappAppIdTokensPost(
          appId,
          requestBody,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the vending status for a given application.  Returns a no content response if the appid has no vending setup.
     * @summary Get App Vending Setup
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppVendingSetupVendingappAppIdSetupGet(
      appId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendingSetup>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppVendingSetupVendingappAppIdSetupGet(
          appId,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve a link to the logged in user\'s Stripe express dashboard.  The user must be logged in and must have onboarded.
     * @summary Get Dashboard Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDashboardLinkVendingStatusDashboardlinkGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VendingRedirect>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDashboardLinkVendingStatusDashboardlinkGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the configuration values needed to calculate application vending splits client-side.  Configuration includes: - Fee values - Platform values
     * @summary Get Global Vending Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGlobalVendingConfigVendingConfigGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendingConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGlobalVendingConfigVendingConfigGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the redeemable tokens for the given application.  The caller must have control of the app at some level  For now, there is no pagination or filtering, all tokens will be returned
     * @summary Get Redeemable Tokens
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRedeemableTokensVendingappAppIdTokensGet(
      appId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRedeemableTokensVendingappAppIdTokensGet(
          appId,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Create/update the vending status for a given application.  Returns an error if the appid is not known, or if it\'s already set up for vending with a user other than the one calling this API.  If you do not have the right to set the vending status for this application then you will also be refused.  In addition, if any of the currency or amount values constraints are violated then you will get an error
     * @summary Post App Vending Setup
     * @param {string} appId
     * @param {VendingSetup} vendingSetup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAppVendingSetupVendingappAppIdSetupPost(
      appId: string,
      vendingSetup: VendingSetup,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendingSetup>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postAppVendingSetupVendingappAppIdSetupPost(
          appId,
          vendingSetup,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Construct a transaction for the given application with the proposed payment. If the proposed payment is unacceptable then an error will be returned. If the user is not logged in, then an error will be returned.  Otherwise a transaction will be created and the information about it will be returned in the output of the call.
     * @summary Post App Vending Status
     * @param {string} appId
     * @param {ProposedPayment} proposedPayment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAppVendingStatusVendingappAppIdPost(
      appId: string,
      proposedPayment: ProposedPayment,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendingOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postAppVendingStatusVendingappAppIdPost(
          appId,
          proposedPayment,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * This redeems the given token for the logged in user.  If the logged in user already owns the app then the token will not be redeemed
     * @summary Redeem Token
     * @param {string} appId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async redeemTokenVendingappAppIdTokensRedeemTokenPost(
      appId: string,
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RedemptionResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.redeemTokenVendingappAppIdTokensRedeemTokenPost(
          appId,
          token,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Start or continue the onboarding process.
     * @summary Start Onboarding
     * @param {VendingOnboardingRequest} vendingOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startOnboardingVendingStatusOnboardingPost(
      vendingOnboardingRequest: VendingOnboardingRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VendingRedirect>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.startOnboardingVendingStatusOnboardingPost(
          vendingOnboardingRequest,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the vending status of the logged in user.  This will return `201` if the logged in user has never begun the onboarding flow to be a vendor on Flathub.
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusVendingStatusGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendingStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusVendingStatusGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * VendingApi - factory interface
 * @export
 */
export const VendingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VendingApiFp(configuration)
  return {
    /**
     * This determines the vending info for the app and returns it
     * @summary App Info
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appInfoVendingappAppIdInfoGet(
      appId: string,
      options?: any,
    ): AxiosPromise<VendingApplicationInformation> {
      return localVarFp
        .appInfoVendingappAppIdInfoGet(appId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Cancel a set of tokens
     * @summary Cancel Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTokensVendingappAppIdTokensCancelPost(
      appId: string,
      requestBody: Array<string>,
      options?: any,
    ): AxiosPromise<Array<TokenCancellation>> {
      return localVarFp
        .cancelTokensVendingappAppIdTokensCancelPost(
          appId,
          requestBody,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create some tokens for the given appid.  The calling user must own the vending config for this application
     * @summary Create Tokens
     * @param {string} appId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokensVendingappAppIdTokensPost(
      appId: string,
      requestBody: Array<string>,
      options?: any,
    ): AxiosPromise<Array<TokenModel>> {
      return localVarFp
        .createTokensVendingappAppIdTokensPost(appId, requestBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the vending status for a given application.  Returns a no content response if the appid has no vending setup.
     * @summary Get App Vending Setup
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppVendingSetupVendingappAppIdSetupGet(
      appId: string,
      options?: any,
    ): AxiosPromise<VendingSetup> {
      return localVarFp
        .getAppVendingSetupVendingappAppIdSetupGet(appId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a link to the logged in user\'s Stripe express dashboard.  The user must be logged in and must have onboarded.
     * @summary Get Dashboard Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDashboardLinkVendingStatusDashboardlinkGet(
      options?: any,
    ): AxiosPromise<VendingRedirect> {
      return localVarFp
        .getDashboardLinkVendingStatusDashboardlinkGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the configuration values needed to calculate application vending splits client-side.  Configuration includes: - Fee values - Platform values
     * @summary Get Global Vending Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGlobalVendingConfigVendingConfigGet(
      options?: any,
    ): AxiosPromise<VendingConfig> {
      return localVarFp
        .getGlobalVendingConfigVendingConfigGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the redeemable tokens for the given application.  The caller must have control of the app at some level  For now, there is no pagination or filtering, all tokens will be returned
     * @summary Get Redeemable Tokens
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRedeemableTokensVendingappAppIdTokensGet(
      appId: string,
      options?: any,
    ): AxiosPromise<TokenList> {
      return localVarFp
        .getRedeemableTokensVendingappAppIdTokensGet(appId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create/update the vending status for a given application.  Returns an error if the appid is not known, or if it\'s already set up for vending with a user other than the one calling this API.  If you do not have the right to set the vending status for this application then you will also be refused.  In addition, if any of the currency or amount values constraints are violated then you will get an error
     * @summary Post App Vending Setup
     * @param {string} appId
     * @param {VendingSetup} vendingSetup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppVendingSetupVendingappAppIdSetupPost(
      appId: string,
      vendingSetup: VendingSetup,
      options?: any,
    ): AxiosPromise<VendingSetup> {
      return localVarFp
        .postAppVendingSetupVendingappAppIdSetupPost(
          appId,
          vendingSetup,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Construct a transaction for the given application with the proposed payment. If the proposed payment is unacceptable then an error will be returned. If the user is not logged in, then an error will be returned.  Otherwise a transaction will be created and the information about it will be returned in the output of the call.
     * @summary Post App Vending Status
     * @param {string} appId
     * @param {ProposedPayment} proposedPayment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppVendingStatusVendingappAppIdPost(
      appId: string,
      proposedPayment: ProposedPayment,
      options?: any,
    ): AxiosPromise<VendingOutput> {
      return localVarFp
        .postAppVendingStatusVendingappAppIdPost(
          appId,
          proposedPayment,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This redeems the given token for the logged in user.  If the logged in user already owns the app then the token will not be redeemed
     * @summary Redeem Token
     * @param {string} appId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemTokenVendingappAppIdTokensRedeemTokenPost(
      appId: string,
      token: string,
      options?: any,
    ): AxiosPromise<RedemptionResult> {
      return localVarFp
        .redeemTokenVendingappAppIdTokensRedeemTokenPost(appId, token, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start or continue the onboarding process.
     * @summary Start Onboarding
     * @param {VendingOnboardingRequest} vendingOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startOnboardingVendingStatusOnboardingPost(
      vendingOnboardingRequest: VendingOnboardingRequest,
      options?: any,
    ): AxiosPromise<VendingRedirect> {
      return localVarFp
        .startOnboardingVendingStatusOnboardingPost(
          vendingOnboardingRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the vending status of the logged in user.  This will return `201` if the logged in user has never begun the onboarding flow to be a vendor on Flathub.
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusVendingStatusGet(options?: any): AxiosPromise<VendingStatus> {
      return localVarFp
        .statusVendingStatusGet(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VendingApi - object-oriented interface
 * @export
 * @class VendingApi
 * @extends {BaseAPI}
 */
export class VendingApi extends BaseAPI {
  /**
   * This determines the vending info for the app and returns it
   * @summary App Info
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public appInfoVendingappAppIdInfoGet(
    appId: string,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .appInfoVendingappAppIdInfoGet(appId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Cancel a set of tokens
   * @summary Cancel Tokens
   * @param {string} appId
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public cancelTokensVendingappAppIdTokensCancelPost(
    appId: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .cancelTokensVendingappAppIdTokensCancelPost(appId, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create some tokens for the given appid.  The calling user must own the vending config for this application
   * @summary Create Tokens
   * @param {string} appId
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public createTokensVendingappAppIdTokensPost(
    appId: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .createTokensVendingappAppIdTokensPost(appId, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the vending status for a given application.  Returns a no content response if the appid has no vending setup.
   * @summary Get App Vending Setup
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public getAppVendingSetupVendingappAppIdSetupGet(
    appId: string,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .getAppVendingSetupVendingappAppIdSetupGet(appId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a link to the logged in user\'s Stripe express dashboard.  The user must be logged in and must have onboarded.
   * @summary Get Dashboard Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public getDashboardLinkVendingStatusDashboardlinkGet(
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .getDashboardLinkVendingStatusDashboardlinkGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the configuration values needed to calculate application vending splits client-side.  Configuration includes: - Fee values - Platform values
   * @summary Get Global Vending Config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public getGlobalVendingConfigVendingConfigGet(options?: AxiosRequestConfig) {
    return VendingApiFp(this.configuration)
      .getGlobalVendingConfigVendingConfigGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the redeemable tokens for the given application.  The caller must have control of the app at some level  For now, there is no pagination or filtering, all tokens will be returned
   * @summary Get Redeemable Tokens
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public getRedeemableTokensVendingappAppIdTokensGet(
    appId: string,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .getRedeemableTokensVendingappAppIdTokensGet(appId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create/update the vending status for a given application.  Returns an error if the appid is not known, or if it\'s already set up for vending with a user other than the one calling this API.  If you do not have the right to set the vending status for this application then you will also be refused.  In addition, if any of the currency or amount values constraints are violated then you will get an error
   * @summary Post App Vending Setup
   * @param {string} appId
   * @param {VendingSetup} vendingSetup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public postAppVendingSetupVendingappAppIdSetupPost(
    appId: string,
    vendingSetup: VendingSetup,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .postAppVendingSetupVendingappAppIdSetupPost(appId, vendingSetup, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Construct a transaction for the given application with the proposed payment. If the proposed payment is unacceptable then an error will be returned. If the user is not logged in, then an error will be returned.  Otherwise a transaction will be created and the information about it will be returned in the output of the call.
   * @summary Post App Vending Status
   * @param {string} appId
   * @param {ProposedPayment} proposedPayment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public postAppVendingStatusVendingappAppIdPost(
    appId: string,
    proposedPayment: ProposedPayment,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .postAppVendingStatusVendingappAppIdPost(appId, proposedPayment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This redeems the given token for the logged in user.  If the logged in user already owns the app then the token will not be redeemed
   * @summary Redeem Token
   * @param {string} appId
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public redeemTokenVendingappAppIdTokensRedeemTokenPost(
    appId: string,
    token: string,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .redeemTokenVendingappAppIdTokensRedeemTokenPost(appId, token, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start or continue the onboarding process.
   * @summary Start Onboarding
   * @param {VendingOnboardingRequest} vendingOnboardingRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public startOnboardingVendingStatusOnboardingPost(
    vendingOnboardingRequest: VendingOnboardingRequest,
    options?: AxiosRequestConfig,
  ) {
    return VendingApiFp(this.configuration)
      .startOnboardingVendingStatusOnboardingPost(
        vendingOnboardingRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the vending status of the logged in user.  This will return `201` if the logged in user has never begun the onboarding flow to be a vendor on Flathub.
   * @summary Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendingApi
   */
  public statusVendingStatusGet(options?: AxiosRequestConfig) {
    return VendingApiFp(this.configuration)
      .statusVendingStatusGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
