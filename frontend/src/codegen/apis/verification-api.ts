/* tslint:disable */
/* eslint-disable */
/**
 * Flathub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration"
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "../base"
// @ts-ignore
import { ArchiveRequest } from "../model"
// @ts-ignore
import { AvailableMethods } from "../model"
// @ts-ignore
import { HTTPValidationError } from "../model"
// @ts-ignore
import { LinkResponse } from "../model"
// @ts-ignore
import { ResponseVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost } from "../model"
// @ts-ignore
import { VerificationStatus } from "../model"
// @ts-ignore
import { WebsiteVerificationResult } from "../model"
// @ts-ignore
import { WebsiteVerificationToken } from "../model"
/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Archive
     * @param {string} appId
     * @param {ArchiveRequest} archiveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveVerificationAppIdArchivePost: async (
      appId: string,
      archiveRequest: ArchiveRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("archiveVerificationAppIdArchivePost", "appId", appId)
      // verify required parameter 'archiveRequest' is not null or undefined
      assertParamExists(
        "archiveVerificationAppIdArchivePost",
        "archiveRequest",
        archiveRequest,
      )
      const localVarPath = `/verification/{app_id}/archive`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        archiveRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Checks website verification, and if it succeeds, marks the app as verified for the current account.
     * @summary Confirm Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost:
      async (
        appId: string,
        newApp?: boolean,
        options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
        // verify required parameter 'appId' is not null or undefined
        assertParamExists(
          "confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost",
          "appId",
          appId,
        )
        const localVarPath =
          `/verification/{app_id}/confirm-website-verification`.replace(
            `{${"app_id"}}`,
            encodeURIComponent(String(appId)),
          )
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
        let baseOptions
        if (configuration) {
          baseOptions = configuration.baseOptions
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        }
        const localVarHeaderParameter = {} as any
        const localVarQueryParameter = {} as any

        if (newApp !== undefined) {
          localVarQueryParameter["new_app"] = newApp
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter)
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {}
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        }

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        }
      },
    /**
     * Gets the ways an app may be verified.
     * @summary Get Available Methods
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableMethodsVerificationAppIdAvailableMethodsGet: async (
      appId: string,
      newApp?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "getAvailableMethodsVerificationAppIdAvailableMethodsGet",
        "appId",
        appId,
      )
      const localVarPath = `/verification/{app_id}/available-methods`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (newApp !== undefined) {
        localVarQueryParameter["new_app"] = newApp
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Gets the verification status of the given app.
     * @summary Get Verification Status
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVerificationStatusVerificationAppIdStatusGet: async (
      appId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "getVerificationStatusVerificationAppIdStatusGet",
        "appId",
        appId,
      )
      const localVarPath = `/verification/{app_id}/status`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the URL to request access to the organization so we can verify the user\'s membership.
     * @summary Request Organization Access Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet:
      async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
        const localVarPath = `/verification/request-organization-access/github`
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
        let baseOptions
        if (configuration) {
          baseOptions = configuration.baseOptions
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        }
        const localVarHeaderParameter = {} as any
        const localVarQueryParameter = {} as any

        setSearchParams(localVarUrlObj, localVarQueryParameter)
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {}
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        }

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        }
      },
    /**
     * Creates a token for the user to verify the app via website.
     * @summary Setup Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost:
      async (
        appId: string,
        newApp?: boolean,
        options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
        // verify required parameter 'appId' is not null or undefined
        assertParamExists(
          "setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost",
          "appId",
          appId,
        )
        const localVarPath =
          `/verification/{app_id}/setup-website-verification`.replace(
            `{${"app_id"}}`,
            encodeURIComponent(String(appId)),
          )
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
        let baseOptions
        if (configuration) {
          baseOptions = configuration.baseOptions
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        }
        const localVarHeaderParameter = {} as any
        const localVarQueryParameter = {} as any

        if (newApp !== undefined) {
          localVarQueryParameter["new_app"] = newApp
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter)
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {}
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        }

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        }
      },
    /**
     *
     * @summary Switch To Direct Upload
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost: async (
      appId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost",
        "appId",
        appId,
      )
      const localVarPath =
        `/verification/{app_id}/switch_to_direct_upload`.replace(
          `{${"app_id"}}`,
          encodeURIComponent(String(appId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If the current account has verified the given app, mark it as no longer verified.
     * @summary Unverify
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unverifyVerificationAppIdUnverifyPost: async (
      appId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("unverifyVerificationAppIdUnverifyPost", "appId", appId)
      const localVarPath = `/verification/{app_id}/unverify`.replace(
        `{${"app_id"}}`,
        encodeURIComponent(String(appId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
     * @summary Verify By Login Provider
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost: async (
      appId: string,
      newApp?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists(
        "verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost",
        "appId",
        appId,
      )
      const localVarPath =
        `/verification/{app_id}/verify-by-login-provider`.replace(
          `{${"app_id"}}`,
          encodeURIComponent(String(appId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (newApp !== undefined) {
        localVarQueryParameter["new_app"] = newApp
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    VerificationApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Archive
     * @param {string} appId
     * @param {ArchiveRequest} archiveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archiveVerificationAppIdArchivePost(
      appId: string,
      archiveRequest: ArchiveRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.archiveVerificationAppIdArchivePost(
          appId,
          archiveRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.archiveVerificationAppIdArchivePost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Checks website verification, and if it succeeds, marks the app as verified for the current account.
     * @summary Confirm Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
      appId: string,
      newApp?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<WebsiteVerificationResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
          appId,
          newApp,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Gets the ways an app may be verified.
     * @summary Get Available Methods
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAvailableMethodsVerificationAppIdAvailableMethodsGet(
      appId: string,
      newApp?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AvailableMethods>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAvailableMethodsVerificationAppIdAvailableMethodsGet(
          appId,
          newApp,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.getAvailableMethodsVerificationAppIdAvailableMethodsGet"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Gets the verification status of the given app.
     * @summary Get Verification Status
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVerificationStatusVerificationAppIdStatusGet(
      appId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VerificationStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getVerificationStatusVerificationAppIdStatusGet(
          appId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.getVerificationStatusVerificationAppIdStatusGet"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns the URL to request access to the organization so we can verify the user\'s membership.
     * @summary Request Organization Access Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a token for the user to verify the app via website.
     * @summary Setup Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
      appId: string,
      newApp?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<WebsiteVerificationToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
          appId,
          newApp,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Switch To Direct Upload
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
      appId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
          appId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * If the current account has verified the given app, mark it as no longer verified.
     * @summary Unverify
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unverifyVerificationAppIdUnverifyPost(
      appId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.unverifyVerificationAppIdUnverifyPost(
          appId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.unverifyVerificationAppIdUnverifyPost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
     * @summary Verify By Login Provider
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
      appId: string,
      newApp?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
          appId,
          newApp,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "VerificationApi.verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VerificationApiFp(configuration)
  return {
    /**
     *
     * @summary Archive
     * @param {string} appId
     * @param {ArchiveRequest} archiveRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveVerificationAppIdArchivePost(
      appId: string,
      archiveRequest: ArchiveRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .archiveVerificationAppIdArchivePost(appId, archiveRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Checks website verification, and if it succeeds, marks the app as verified for the current account.
     * @summary Confirm Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
      appId: string,
      newApp?: boolean,
      options?: any,
    ): AxiosPromise<WebsiteVerificationResult> {
      return localVarFp
        .confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
          appId,
          newApp,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Gets the ways an app may be verified.
     * @summary Get Available Methods
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableMethodsVerificationAppIdAvailableMethodsGet(
      appId: string,
      newApp?: boolean,
      options?: any,
    ): AxiosPromise<AvailableMethods> {
      return localVarFp
        .getAvailableMethodsVerificationAppIdAvailableMethodsGet(
          appId,
          newApp,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Gets the verification status of the given app.
     * @summary Get Verification Status
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVerificationStatusVerificationAppIdStatusGet(
      appId: string,
      options?: any,
    ): AxiosPromise<VerificationStatus> {
      return localVarFp
        .getVerificationStatusVerificationAppIdStatusGet(appId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns the URL to request access to the organization so we can verify the user\'s membership.
     * @summary Request Organization Access Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
      options?: any,
    ): AxiosPromise<LinkResponse> {
      return localVarFp
        .requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates a token for the user to verify the app via website.
     * @summary Setup Website Verification
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
      appId: string,
      newApp?: boolean,
      options?: any,
    ): AxiosPromise<WebsiteVerificationToken> {
      return localVarFp
        .setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
          appId,
          newApp,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Switch To Direct Upload
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
      appId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
          appId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * If the current account has verified the given app, mark it as no longer verified.
     * @summary Unverify
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unverifyVerificationAppIdUnverifyPost(
      appId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .unverifyVerificationAppIdUnverifyPost(appId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
     * @summary Verify By Login Provider
     * @param {string} appId
     * @param {boolean} [newApp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
      appId: string,
      newApp?: boolean,
      options?: any,
    ): AxiosPromise<ResponseVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost> {
      return localVarFp
        .verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
          appId,
          newApp,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
  /**
   *
   * @summary Archive
   * @param {string} appId
   * @param {ArchiveRequest} archiveRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public archiveVerificationAppIdArchivePost(
    appId: string,
    archiveRequest: ArchiveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .archiveVerificationAppIdArchivePost(appId, archiveRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Checks website verification, and if it succeeds, marks the app as verified for the current account.
   * @summary Confirm Website Verification
   * @param {string} appId
   * @param {boolean} [newApp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
    appId: string,
    newApp?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
        appId,
        newApp,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Gets the ways an app may be verified.
   * @summary Get Available Methods
   * @param {string} appId
   * @param {boolean} [newApp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public getAvailableMethodsVerificationAppIdAvailableMethodsGet(
    appId: string,
    newApp?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .getAvailableMethodsVerificationAppIdAvailableMethodsGet(
        appId,
        newApp,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Gets the verification status of the given app.
   * @summary Get Verification Status
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public getVerificationStatusVerificationAppIdStatusGet(
    appId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .getVerificationStatusVerificationAppIdStatusGet(appId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns the URL to request access to the organization so we can verify the user\'s membership.
   * @summary Request Organization Access Github
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a token for the user to verify the app via website.
   * @summary Setup Website Verification
   * @param {string} appId
   * @param {boolean} [newApp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
    appId: string,
    newApp?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
        appId,
        newApp,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Switch To Direct Upload
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
    appId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
        appId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If the current account has verified the given app, mark it as no longer verified.
   * @summary Unverify
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public unverifyVerificationAppIdUnverifyPost(
    appId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .unverifyVerificationAppIdUnverifyPost(appId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
   * @summary Verify By Login Provider
   * @param {string} appId
   * @param {boolean} [newApp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerificationApi
   */
  public verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
    appId: string,
    newApp?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return VerificationApiFp(this.configuration)
      .verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
        appId,
        newApp,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
