/* tslint:disable */
/* eslint-disable */
/**
 * Flathub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base"
// @ts-ignore
import { ConnectedAccountProvider } from "../model"
// @ts-ignore
import { Data } from "../model"
// @ts-ignore
import { DeleteUserResult } from "../model"
// @ts-ignore
import { GetDeleteUserResult } from "../model"
// @ts-ignore
import { HTTPValidationError } from "../model"
// @ts-ignore
import { LoginMethod } from "../model"
// @ts-ignore
import { UserDeleteRequest } from "../model"
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Github Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGithubFlowAuthLoginGithubPost: async (
      data: Data,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'data' is not null or undefined
      assertParamExists("continueGithubFlowAuthLoginGithubPost", "data", data)
      const localVarPath = `/auth/login/github`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        data,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gitlab Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGitlabFlowAuthLoginGitlabPost: async (
      data: Data,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'data' is not null or undefined
      assertParamExists("continueGitlabFlowAuthLoginGitlabPost", "data", data)
      const localVarPath = `/auth/login/gitlab`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        data,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gnome Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGnomeFlowAuthLoginGnomePost: async (
      data: Data,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'data' is not null or undefined
      assertParamExists("continueGnomeFlowAuthLoginGnomePost", "data", data)
      const localVarPath = `/auth/login/gnome`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        data,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Google Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGoogleFlowAuthLoginGooglePost: async (
      data: Data,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'data' is not null or undefined
      assertParamExists("continueGoogleFlowAuthLoginGooglePost", "data", data)
      const localVarPath = `/auth/login/google`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        data,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Continue Kde Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueKdeFlowAuthLoginKdePost: async (
      data: Data,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'data' is not null or undefined
      assertParamExists("continueKdeFlowAuthLoginKdePost", "data", data)
      const localVarPath = `/auth/login/kde`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        data,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Do Agree To Publisher Agreement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/accept-publisher-agreement`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Changes the user\'s default account, which determines which display name and email we use.
     * @summary Do Change Default Account
     * @param {ConnectedAccountProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doChangeDefaultAccountAuthChangeDefaultAccountPost: async (
      provider: ConnectedAccountProvider,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists(
        "doChangeDefaultAccountAuthChangeDefaultAccountPost",
        "provider",
        provider,
      )
      const localVarPath = `/auth/change-default-account`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (provider !== undefined) {
        localVarQueryParameter["provider"] = provider
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
     * @summary Do Deleteuser
     * @param {UserDeleteRequest} userDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doDeleteuserAuthDeleteuserPost: async (
      userDeleteRequest: UserDeleteRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userDeleteRequest' is not null or undefined
      assertParamExists(
        "doDeleteuserAuthDeleteuserPost",
        "userDeleteRequest",
        userDeleteRequest,
      )
      const localVarPath = `/auth/deleteuser`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
     * @summary Do Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doLogoutAuthLogoutPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Do Refresh Dev Flatpaks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh-dev-flatpaks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
     * @summary Get Deleteuser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeleteuserAuthDeleteuserGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/deleteuser`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
     * @summary Get Login Methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginMethodsAuthLoginGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
     * @summary Get Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserinfoAuthUserinfoGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/userinfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
     * @summary Start Github Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGithubFlowAuthLoginGithubGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login/github`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
     * @summary Start Gitlab Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGitlabFlowAuthLoginGitlabGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login/gitlab`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
     * @summary Start Gnome Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGnomeFlowAuthLoginGnomeGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login/gnome`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Start Kde Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startKdeFlowAuthLoginKdeGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login/kde`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Github Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async continueGithubFlowAuthLoginGithubPost(
      data: Data,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.continueGithubFlowAuthLoginGithubPost(
          data,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gitlab Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async continueGitlabFlowAuthLoginGitlabPost(
      data: Data,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.continueGitlabFlowAuthLoginGitlabPost(
          data,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gnome Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async continueGnomeFlowAuthLoginGnomePost(
      data: Data,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.continueGnomeFlowAuthLoginGnomePost(
          data,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Google Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async continueGoogleFlowAuthLoginGooglePost(
      data: Data,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.continueGoogleFlowAuthLoginGooglePost(
          data,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     *
     * @summary Continue Kde Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async continueKdeFlowAuthLoginKdePost(
      data: Data,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.continueKdeFlowAuthLoginKdePost(
          data,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     *
     * @summary Do Agree To Publisher Agreement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Changes the user\'s default account, which determines which display name and email we use.
     * @summary Do Change Default Account
     * @param {ConnectedAccountProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doChangeDefaultAccountAuthChangeDefaultAccountPost(
      provider: ConnectedAccountProvider,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doChangeDefaultAccountAuthChangeDefaultAccountPost(
          provider,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
     * @summary Do Deleteuser
     * @param {UserDeleteRequest} userDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doDeleteuserAuthDeleteuserPost(
      userDeleteRequest: UserDeleteRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DeleteUserResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doDeleteuserAuthDeleteuserPost(
          userDeleteRequest,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
     * @summary Do Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doLogoutAuthLogoutPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doLogoutAuthLogoutPost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     *
     * @summary Do Refresh Dev Flatpaks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
     * @summary Get Deleteuser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDeleteuserAuthDeleteuserGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetDeleteUserResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDeleteuserAuthDeleteuserGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
     * @summary Get Login Methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginMethodsAuthLoginGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LoginMethod>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLoginMethodsAuthLoginGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
     * @summary Get Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserinfoAuthUserinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserinfoAuthUserinfoGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
     * @summary Start Github Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startGithubFlowAuthLoginGithubGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.startGithubFlowAuthLoginGithubGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
     * @summary Start Gitlab Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startGitlabFlowAuthLoginGitlabGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.startGitlabFlowAuthLoginGitlabGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
     * @summary Start Gnome Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startGnomeFlowAuthLoginGnomeGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.startGnomeFlowAuthLoginGnomeGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     *
     * @summary Start Kde Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startKdeFlowAuthLoginKdeGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.startKdeFlowAuthLoginKdeGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Github Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGithubFlowAuthLoginGithubPost(
      data: Data,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .continueGithubFlowAuthLoginGithubPost(data, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gitlab Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGitlabFlowAuthLoginGitlabPost(
      data: Data,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .continueGitlabFlowAuthLoginGitlabPost(data, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gnome Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGnomeFlowAuthLoginGnomePost(
      data: Data,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .continueGnomeFlowAuthLoginGnomePost(data, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Google Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueGoogleFlowAuthLoginGooglePost(
      data: Data,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .continueGoogleFlowAuthLoginGooglePost(data, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Continue Kde Flow
     * @param {Data} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    continueKdeFlowAuthLoginKdePost(
      data: Data,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .continueKdeFlowAuthLoginKdePost(data, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Do Agree To Publisher Agreement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Changes the user\'s default account, which determines which display name and email we use.
     * @summary Do Change Default Account
     * @param {ConnectedAccountProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doChangeDefaultAccountAuthChangeDefaultAccountPost(
      provider: ConnectedAccountProvider,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .doChangeDefaultAccountAuthChangeDefaultAccountPost(provider, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
     * @summary Do Deleteuser
     * @param {UserDeleteRequest} userDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doDeleteuserAuthDeleteuserPost(
      userDeleteRequest: UserDeleteRequest,
      options?: any,
    ): AxiosPromise<DeleteUserResult> {
      return localVarFp
        .doDeleteuserAuthDeleteuserPost(userDeleteRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
     * @summary Do Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doLogoutAuthLogoutPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .doLogoutAuthLogoutPost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Do Refresh Dev Flatpaks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
     * @summary Get Deleteuser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeleteuserAuthDeleteuserGet(
      options?: any,
    ): AxiosPromise<GetDeleteUserResult> {
      return localVarFp
        .getDeleteuserAuthDeleteuserGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
     * @summary Get Login Methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginMethodsAuthLoginGet(
      options?: any,
    ): AxiosPromise<Array<LoginMethod>> {
      return localVarFp
        .getLoginMethodsAuthLoginGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
     * @summary Get Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserinfoAuthUserinfoGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .getUserinfoAuthUserinfoGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
     * @summary Start Github Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGithubFlowAuthLoginGithubGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .startGithubFlowAuthLoginGithubGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
     * @summary Start Gitlab Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGitlabFlowAuthLoginGitlabGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .startGitlabFlowAuthLoginGitlabGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
     * @summary Start Gnome Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startGnomeFlowAuthLoginGnomeGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .startGnomeFlowAuthLoginGnomeGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Start Kde Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startKdeFlowAuthLoginKdeGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .startKdeFlowAuthLoginKdeGet(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
   * @summary Continue Github Flow
   * @param {Data} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public continueGithubFlowAuthLoginGithubPost(
    data: Data,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .continueGithubFlowAuthLoginGithubPost(data, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
   * @summary Continue Gitlab Flow
   * @param {Data} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public continueGitlabFlowAuthLoginGitlabPost(
    data: Data,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .continueGitlabFlowAuthLoginGitlabPost(data, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
   * @summary Continue Gnome Flow
   * @param {Data} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public continueGnomeFlowAuthLoginGnomePost(
    data: Data,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .continueGnomeFlowAuthLoginGnomePost(data, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
   * @summary Continue Google Flow
   * @param {Data} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public continueGoogleFlowAuthLoginGooglePost(
    data: Data,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .continueGoogleFlowAuthLoginGooglePost(data, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Continue Kde Flow
   * @param {Data} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public continueKdeFlowAuthLoginKdePost(
    data: Data,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .continueKdeFlowAuthLoginKdePost(data, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Do Agree To Publisher Agreement
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Changes the user\'s default account, which determines which display name and email we use.
   * @summary Do Change Default Account
   * @param {ConnectedAccountProvider} provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public doChangeDefaultAccountAuthChangeDefaultAccountPost(
    provider: ConnectedAccountProvider,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .doChangeDefaultAccountAuthChangeDefaultAccountPost(provider, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
   * @summary Do Deleteuser
   * @param {UserDeleteRequest} userDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public doDeleteuserAuthDeleteuserPost(
    userDeleteRequest: UserDeleteRequest,
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .doDeleteuserAuthDeleteuserPost(userDeleteRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
   * @summary Do Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public doLogoutAuthLogoutPost(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .doLogoutAuthLogoutPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Do Refresh Dev Flatpaks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(
    options?: AxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
   * @summary Get Deleteuser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public getDeleteuserAuthDeleteuserGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .getDeleteuserAuthDeleteuserGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
   * @summary Get Login Methods
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public getLoginMethodsAuthLoginGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .getLoginMethodsAuthLoginGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
   * @summary Get Userinfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public getUserinfoAuthUserinfoGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .getUserinfoAuthUserinfoGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
   * @summary Start Github Flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public startGithubFlowAuthLoginGithubGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .startGithubFlowAuthLoginGithubGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
   * @summary Start Gitlab Flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public startGitlabFlowAuthLoginGitlabGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .startGitlabFlowAuthLoginGitlabGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
   * @summary Start Gnome Flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public startGnomeFlowAuthLoginGnomeGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .startGnomeFlowAuthLoginGnomeGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Start Kde Flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public startKdeFlowAuthLoginKdeGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .startKdeFlowAuthLoginKdeGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
