/* tslint:disable */
/* eslint-disable */
/**
 * Flathub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base"
// @ts-ignore
import { HTTPValidationError } from "../model"
// @ts-ignore
import { NascentTransaction } from "../model"
// @ts-ignore
import { PaymentCardInfo } from "../model"
// @ts-ignore
import { Transaction } from "../model"
// @ts-ignore
import { TransactionSaveCard } from "../model"
// @ts-ignore
import { TransactionSortOrder } from "../model"
// @ts-ignore
import { WalletInfo } from "../model"
/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
     * @summary Cancel Transaction
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransactionWalletTransactionsTxnCancelPost: async (
      txn: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "cancelTransactionWalletTransactionsTxnCancelPost",
        "txn",
        txn,
      )
      const localVarPath = `/wallet/transactions/{txn}/cancel`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
     * @summary Create Transaction
     * @param {NascentTransaction} nascentTransaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactionWalletTransactionsPost: async (
      nascentTransaction: NascentTransaction,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nascentTransaction' is not null or undefined
      assertParamExists(
        "createTransactionWalletTransactionsPost",
        "nascentTransaction",
        nascentTransaction,
      )
      const localVarPath = `/wallet/transactions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        nascentTransaction,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
     * @summary Get Stripedata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripedataWalletStripedataGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/wallet/stripedata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
     * @summary Get Transaction By Id
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionByIdWalletTransactionsTxnGet: async (
      txn: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "getTransactionByIdWalletTransactionsTxnGet",
        "txn",
        txn,
      )
      const localVarPath = `/wallet/transactions/{txn}`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
     * @summary Get Transactions
     * @param {TransactionSortOrder} [sort]
     * @param {string | null} [since]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsWalletTransactionsGet: async (
      sort?: TransactionSortOrder,
      since?: string | null,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/wallet/transactions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (since !== undefined) {
        localVarQueryParameter["since"] = since
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
     * @summary Get Txn Stripedata
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTxnStripedataWalletTransactionsTxnStripeGet: async (
      txn: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "getTxnStripedataWalletTransactionsTxnStripeGet",
        "txn",
        txn,
      )
      const localVarPath = `/wallet/transactions/{txn}/stripe`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
     * @summary Get Walletinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletinfoWalletWalletinfoGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/wallet/walletinfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
     * @summary Post Removecard
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRemovecardWalletRemovecardPost: async (
      paymentCardInfo: PaymentCardInfo,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentCardInfo' is not null or undefined
      assertParamExists(
        "postRemovecardWalletRemovecardPost",
        "paymentCardInfo",
        paymentCardInfo,
      )
      const localVarPath = `/wallet/removecard`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentCardInfo,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
     * @summary Set Pending
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPendingWalletTransactionsTxnSetpendingPost: async (
      txn: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "setPendingWalletTransactionsTxnSetpendingPost",
        "txn",
        txn,
      )
      const localVarPath = `/wallet/transactions/{txn}/setpending`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
     * @summary Set Savecard
     * @param {string} txn
     * @param {TransactionSaveCard} transactionSaveCard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSavecardWalletTransactionsTxnSavecardPost: async (
      txn: string,
      transactionSaveCard: TransactionSaveCard,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "setSavecardWalletTransactionsTxnSavecardPost",
        "txn",
        txn,
      )
      // verify required parameter 'transactionSaveCard' is not null or undefined
      assertParamExists(
        "setSavecardWalletTransactionsTxnSavecardPost",
        "transactionSaveCard",
        transactionSaveCard,
      )
      const localVarPath = `/wallet/transactions/{txn}/savecard`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        transactionSaveCard,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
     * @summary Set Transaction Card
     * @param {string} txn
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTransactionCardWalletTransactionsTxnSetcardPost: async (
      txn: string,
      paymentCardInfo: PaymentCardInfo,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txn' is not null or undefined
      assertParamExists(
        "setTransactionCardWalletTransactionsTxnSetcardPost",
        "txn",
        txn,
      )
      // verify required parameter 'paymentCardInfo' is not null or undefined
      assertParamExists(
        "setTransactionCardWalletTransactionsTxnSetcardPost",
        "paymentCardInfo",
        paymentCardInfo,
      )
      const localVarPath = `/wallet/transactions/{txn}/setcard`.replace(
        `{${"txn"}}`,
        encodeURIComponent(String(txn)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentCardInfo,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
     * @summary Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhookWalletWebhookStripePost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/wallet/webhook/stripe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
  return {
    /**
     * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
     * @summary Cancel Transaction
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTransactionWalletTransactionsTxnCancelPost(
      txn: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cancelTransactionWalletTransactionsTxnCancelPost(
          txn,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
     * @summary Create Transaction
     * @param {NascentTransaction} nascentTransaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTransactionWalletTransactionsPost(
      nascentTransaction: NascentTransaction,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createTransactionWalletTransactionsPost(
          nascentTransaction,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
     * @summary Get Stripedata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStripedataWalletStripedataGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStripedataWalletStripedataGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
     * @summary Get Transaction By Id
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionByIdWalletTransactionsTxnGet(
      txn: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionByIdWalletTransactionsTxnGet(
          txn,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
     * @summary Get Transactions
     * @param {TransactionSortOrder} [sort]
     * @param {string | null} [since]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionsWalletTransactionsGet(
      sort?: TransactionSortOrder,
      since?: string | null,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionsWalletTransactionsGet(
          sort,
          since,
          limit,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
     * @summary Get Txn Stripedata
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTxnStripedataWalletTransactionsTxnStripeGet(
      txn: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTxnStripedataWalletTransactionsTxnStripeGet(
          txn,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
     * @summary Get Walletinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWalletinfoWalletWalletinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWalletinfoWalletWalletinfoGet(
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
     * @summary Post Removecard
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRemovecardWalletRemovecardPost(
      paymentCardInfo: PaymentCardInfo,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postRemovecardWalletRemovecardPost(
          paymentCardInfo,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
     * @summary Set Pending
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPendingWalletTransactionsTxnSetpendingPost(
      txn: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPendingWalletTransactionsTxnSetpendingPost(
          txn,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
     * @summary Set Savecard
     * @param {string} txn
     * @param {TransactionSaveCard} transactionSaveCard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setSavecardWalletTransactionsTxnSavecardPost(
      txn: string,
      transactionSaveCard: TransactionSaveCard,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setSavecardWalletTransactionsTxnSavecardPost(
          txn,
          transactionSaveCard,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
     * @summary Set Transaction Card
     * @param {string} txn
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTransactionCardWalletTransactionsTxnSetcardPost(
      txn: string,
      paymentCardInfo: PaymentCardInfo,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setTransactionCardWalletTransactionsTxnSetcardPost(
          txn,
          paymentCardInfo,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
     * @summary Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhookWalletWebhookStripePost(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhookWalletWebhookStripePost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletApiFp(configuration)
  return {
    /**
     * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
     * @summary Cancel Transaction
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransactionWalletTransactionsTxnCancelPost(
      txn: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .cancelTransactionWalletTransactionsTxnCancelPost(txn, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
     * @summary Create Transaction
     * @param {NascentTransaction} nascentTransaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactionWalletTransactionsPost(
      nascentTransaction: NascentTransaction,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createTransactionWalletTransactionsPost(nascentTransaction, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
     * @summary Get Stripedata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripedataWalletStripedataGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .getStripedataWalletStripedataGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
     * @summary Get Transaction By Id
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionByIdWalletTransactionsTxnGet(
      txn: string,
      options?: any,
    ): AxiosPromise<Transaction> {
      return localVarFp
        .getTransactionByIdWalletTransactionsTxnGet(txn, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
     * @summary Get Transactions
     * @param {TransactionSortOrder} [sort]
     * @param {string | null} [since]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsWalletTransactionsGet(
      sort?: TransactionSortOrder,
      since?: string | null,
      limit?: number,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .getTransactionsWalletTransactionsGet(sort, since, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
     * @summary Get Txn Stripedata
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTxnStripedataWalletTransactionsTxnStripeGet(
      txn: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .getTxnStripedataWalletTransactionsTxnStripeGet(txn, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
     * @summary Get Walletinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletinfoWalletWalletinfoGet(options?: any): AxiosPromise<WalletInfo> {
      return localVarFp
        .getWalletinfoWalletWalletinfoGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
     * @summary Post Removecard
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRemovecardWalletRemovecardPost(
      paymentCardInfo: PaymentCardInfo,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .postRemovecardWalletRemovecardPost(paymentCardInfo, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
     * @summary Set Pending
     * @param {string} txn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPendingWalletTransactionsTxnSetpendingPost(
      txn: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .setPendingWalletTransactionsTxnSetpendingPost(txn, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
     * @summary Set Savecard
     * @param {string} txn
     * @param {TransactionSaveCard} transactionSaveCard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSavecardWalletTransactionsTxnSavecardPost(
      txn: string,
      transactionSaveCard: TransactionSaveCard,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .setSavecardWalletTransactionsTxnSavecardPost(
          txn,
          transactionSaveCard,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
     * @summary Set Transaction Card
     * @param {string} txn
     * @param {PaymentCardInfo} paymentCardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTransactionCardWalletTransactionsTxnSetcardPost(
      txn: string,
      paymentCardInfo: PaymentCardInfo,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .setTransactionCardWalletTransactionsTxnSetcardPost(
          txn,
          paymentCardInfo,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
     * @summary Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhookWalletWebhookStripePost(options?: any): AxiosPromise<void> {
      return localVarFp
        .webhookWalletWebhookStripePost(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
   * @summary Cancel Transaction
   * @param {string} txn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public cancelTransactionWalletTransactionsTxnCancelPost(
    txn: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .cancelTransactionWalletTransactionsTxnCancelPost(txn, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
   * @summary Create Transaction
   * @param {NascentTransaction} nascentTransaction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public createTransactionWalletTransactionsPost(
    nascentTransaction: NascentTransaction,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .createTransactionWalletTransactionsPost(nascentTransaction, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
   * @summary Get Stripedata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getStripedataWalletStripedataGet(options?: AxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .getStripedataWalletStripedataGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
   * @summary Get Transaction By Id
   * @param {string} txn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getTransactionByIdWalletTransactionsTxnGet(
    txn: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .getTransactionByIdWalletTransactionsTxnGet(txn, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
   * @summary Get Transactions
   * @param {TransactionSortOrder} [sort]
   * @param {string | null} [since]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getTransactionsWalletTransactionsGet(
    sort?: TransactionSortOrder,
    since?: string | null,
    limit?: number,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .getTransactionsWalletTransactionsGet(sort, since, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
   * @summary Get Txn Stripedata
   * @param {string} txn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getTxnStripedataWalletTransactionsTxnStripeGet(
    txn: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .getTxnStripedataWalletTransactionsTxnStripeGet(txn, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
   * @summary Get Walletinfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getWalletinfoWalletWalletinfoGet(options?: AxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .getWalletinfoWalletWalletinfoGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
   * @summary Post Removecard
   * @param {PaymentCardInfo} paymentCardInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public postRemovecardWalletRemovecardPost(
    paymentCardInfo: PaymentCardInfo,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .postRemovecardWalletRemovecardPost(paymentCardInfo, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
   * @summary Set Pending
   * @param {string} txn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public setPendingWalletTransactionsTxnSetpendingPost(
    txn: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .setPendingWalletTransactionsTxnSetpendingPost(txn, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
   * @summary Set Savecard
   * @param {string} txn
   * @param {TransactionSaveCard} transactionSaveCard
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public setSavecardWalletTransactionsTxnSavecardPost(
    txn: string,
    transactionSaveCard: TransactionSaveCard,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .setSavecardWalletTransactionsTxnSavecardPost(
        txn,
        transactionSaveCard,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
   * @summary Set Transaction Card
   * @param {string} txn
   * @param {PaymentCardInfo} paymentCardInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public setTransactionCardWalletTransactionsTxnSetcardPost(
    txn: string,
    paymentCardInfo: PaymentCardInfo,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .setTransactionCardWalletTransactionsTxnSetcardPost(
        txn,
        paymentCardInfo,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
   * @summary Webhook
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public webhookWalletWebhookStripePost(options?: AxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .webhookWalletWebhookStripePost(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
