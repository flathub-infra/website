/**
 * Generated by orval 🍺
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  GetTransactionsWalletTransactionsGetParams,
  NascentTransaction,
  PaymentCardInfo,
  PostTransactionResponse,
  StripeKeys,
  Transaction,
  TransactionSaveCard,
  TransactionStripeData,
  TransactionSummary,
  WalletInfo,
} from ".././model"

/**
 * Retrieve the wallet for the currently logged in user.

This will return a list of cards which the user has saved to their account.
 * @summary Get Walletinfo
 */
export type getWalletinfoWalletWalletinfoGetResponse200 = {
  data: WalletInfo
  status: 200
}

export type getWalletinfoWalletWalletinfoGetResponse401 = {
  data: null
  status: 401
}

export type getWalletinfoWalletWalletinfoGetResponse403 = {
  data: null
  status: 403
}

export type getWalletinfoWalletWalletinfoGetResponse500 = {
  data: null
  status: 500
}

export type getWalletinfoWalletWalletinfoGetResponseComposite =
  | getWalletinfoWalletWalletinfoGetResponse200
  | getWalletinfoWalletWalletinfoGetResponse401
  | getWalletinfoWalletWalletinfoGetResponse403
  | getWalletinfoWalletWalletinfoGetResponse500

export type getWalletinfoWalletWalletinfoGetResponse =
  getWalletinfoWalletWalletinfoGetResponseComposite & {
    headers: Headers
  }

export const getGetWalletinfoWalletWalletinfoGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/walletinfo`
}

export const getWalletinfoWalletWalletinfoGet = async (
  options?: RequestInit,
): Promise<getWalletinfoWalletWalletinfoGetResponse> => {
  const res = await fetch(getGetWalletinfoWalletWalletinfoGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWalletinfoWalletWalletinfoGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getWalletinfoWalletWalletinfoGetResponse
}

export const getGetWalletinfoWalletWalletinfoGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/walletinfo`] as const
}

export const getGetWalletinfoWalletWalletinfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = null | null | null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetWalletinfoWalletWalletinfoGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
  > = ({ signal }) =>
    getWalletinfoWalletWalletinfoGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWalletinfoWalletWalletinfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
>
export type GetWalletinfoWalletWalletinfoGetQueryError = null | null | null

export function useGetWalletinfoWalletWalletinfoGet<
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = null | null | null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetWalletinfoWalletWalletinfoGet<
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetWalletinfoWalletWalletinfoGet<
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Walletinfo
 */

export function useGetWalletinfoWalletWalletinfoGet<
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetWalletinfoWalletWalletinfoGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Remove a card from a user's wallet.

The provided information must exactly match a card as would be returned from the
wallet info endpoint.
 * @summary Post Removecard
 */
export type postRemovecardWalletRemovecardPostResponse200 = {
  data: unknown
  status: 200
}

export type postRemovecardWalletRemovecardPostResponse201 = {
  data: null
  status: 201
}

export type postRemovecardWalletRemovecardPostResponse401 = {
  data: null
  status: 401
}

export type postRemovecardWalletRemovecardPostResponse403 = {
  data: null
  status: 403
}

export type postRemovecardWalletRemovecardPostResponse422 = {
  data: null
  status: 422
}

export type postRemovecardWalletRemovecardPostResponse500 = {
  data: null
  status: 500
}

export type postRemovecardWalletRemovecardPostResponseComposite =
  | postRemovecardWalletRemovecardPostResponse200
  | postRemovecardWalletRemovecardPostResponse201
  | postRemovecardWalletRemovecardPostResponse401
  | postRemovecardWalletRemovecardPostResponse403
  | postRemovecardWalletRemovecardPostResponse422
  | postRemovecardWalletRemovecardPostResponse500

export type postRemovecardWalletRemovecardPostResponse =
  postRemovecardWalletRemovecardPostResponseComposite & {
    headers: Headers
  }

export const getPostRemovecardWalletRemovecardPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/removecard`
}

export const postRemovecardWalletRemovecardPost = async (
  paymentCardInfo: PaymentCardInfo,
  options?: RequestInit,
): Promise<postRemovecardWalletRemovecardPostResponse> => {
  const res = await fetch(getPostRemovecardWalletRemovecardPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(paymentCardInfo),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postRemovecardWalletRemovecardPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postRemovecardWalletRemovecardPostResponse
}

export const getPostRemovecardWalletRemovecardPostMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
    TError,
    { data: PaymentCardInfo },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
  TError,
  { data: PaymentCardInfo },
  TContext
> => {
  const mutationKey = ["postRemovecardWalletRemovecardPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
    { data: PaymentCardInfo }
  > = (props) => {
    const { data } = props ?? {}

    return postRemovecardWalletRemovecardPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostRemovecardWalletRemovecardPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>
>
export type PostRemovecardWalletRemovecardPostMutationBody = PaymentCardInfo
export type PostRemovecardWalletRemovecardPostMutationError =
  | null
  | null
  | null
  | null

/**
 * @summary Post Removecard
 */
export const usePostRemovecardWalletRemovecardPost = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
      TError,
      { data: PaymentCardInfo },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
  TError,
  { data: PaymentCardInfo },
  TContext
> => {
  const mutationOptions =
    getPostRemovecardWalletRemovecardPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Return a list of transactions associated with this user.

If anything goes wrong, an error will be returned, otherwise a list of transaction
summaries will be returned.
 * @summary Get Transactions
 */
export type getTransactionsWalletTransactionsGetResponse200 = {
  data: TransactionSummary[]
  status: 200
}

export type getTransactionsWalletTransactionsGetResponse401 = {
  data: null
  status: 401
}

export type getTransactionsWalletTransactionsGetResponse403 = {
  data: null
  status: 403
}

export type getTransactionsWalletTransactionsGetResponse422 = {
  data: null
  status: 422
}

export type getTransactionsWalletTransactionsGetResponse500 = {
  data: null
  status: 500
}

export type getTransactionsWalletTransactionsGetResponseComposite =
  | getTransactionsWalletTransactionsGetResponse200
  | getTransactionsWalletTransactionsGetResponse401
  | getTransactionsWalletTransactionsGetResponse403
  | getTransactionsWalletTransactionsGetResponse422
  | getTransactionsWalletTransactionsGetResponse500

export type getTransactionsWalletTransactionsGetResponse =
  getTransactionsWalletTransactionsGetResponseComposite & {
    headers: Headers
  }

export const getGetTransactionsWalletTransactionsGetUrl = (
  params?: GetTransactionsWalletTransactionsGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions`
}

export const getTransactionsWalletTransactionsGet = async (
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: RequestInit,
): Promise<getTransactionsWalletTransactionsGetResponse> => {
  const res = await fetch(getGetTransactionsWalletTransactionsGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTransactionsWalletTransactionsGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getTransactionsWalletTransactionsGetResponse
}

export const getGetTransactionsWalletTransactionsGetQueryKey = (
  params?: GetTransactionsWalletTransactionsGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetTransactionsWalletTransactionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = null | null | null | null,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTransactionsWalletTransactionsGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
  > = ({ signal }) =>
    getTransactionsWalletTransactionsGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionsWalletTransactionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
>
export type GetTransactionsWalletTransactionsGetQueryError =
  | null
  | null
  | null
  | null

export function useGetTransactionsWalletTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = null | null | null | null,
>(
  params: undefined | GetTransactionsWalletTransactionsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTransactionsWalletTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = null | null | null | null,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTransactionsWalletTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = null | null | null | null,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Transactions
 */

export function useGetTransactionsWalletTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = null | null | null | null,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetTransactionsWalletTransactionsGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new transaction, return the ID.

If the passed in nascent transaction is valid, this will create a transaction and
return the ID of the newly created wallet, otherwise it'll return an error
 * @summary Create Transaction
 */
export type createTransactionWalletTransactionsPostResponse200 = {
  data: PostTransactionResponse
  status: 200
}

export type createTransactionWalletTransactionsPostResponse401 = {
  data: null
  status: 401
}

export type createTransactionWalletTransactionsPostResponse403 = {
  data: null
  status: 403
}

export type createTransactionWalletTransactionsPostResponse422 = {
  data: null
  status: 422
}

export type createTransactionWalletTransactionsPostResponse500 = {
  data: null
  status: 500
}

export type createTransactionWalletTransactionsPostResponseComposite =
  | createTransactionWalletTransactionsPostResponse200
  | createTransactionWalletTransactionsPostResponse401
  | createTransactionWalletTransactionsPostResponse403
  | createTransactionWalletTransactionsPostResponse422
  | createTransactionWalletTransactionsPostResponse500

export type createTransactionWalletTransactionsPostResponse =
  createTransactionWalletTransactionsPostResponseComposite & {
    headers: Headers
  }

export const getCreateTransactionWalletTransactionsPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions`
}

export const createTransactionWalletTransactionsPost = async (
  nascentTransaction: NascentTransaction,
  options?: RequestInit,
): Promise<createTransactionWalletTransactionsPostResponse> => {
  const res = await fetch(getCreateTransactionWalletTransactionsPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(nascentTransaction),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createTransactionWalletTransactionsPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createTransactionWalletTransactionsPostResponse
}

export const getCreateTransactionWalletTransactionsPostMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
    TError,
    { data: NascentTransaction },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
  TError,
  { data: NascentTransaction },
  TContext
> => {
  const mutationKey = ["createTransactionWalletTransactionsPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
    { data: NascentTransaction }
  > = (props) => {
    const { data } = props ?? {}

    return createTransactionWalletTransactionsPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTransactionWalletTransactionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>
>
export type CreateTransactionWalletTransactionsPostMutationBody =
  NascentTransaction
export type CreateTransactionWalletTransactionsPostMutationError =
  | null
  | null
  | null
  | null

/**
 * @summary Create Transaction
 */
export const useCreateTransactionWalletTransactionsPost = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
      TError,
      { data: NascentTransaction },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
  TError,
  { data: NascentTransaction },
  TContext
> => {
  const mutationOptions =
    getCreateTransactionWalletTransactionsPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Retrieve a transaction by its ID

If the transaction ID is valid, and owned by the calling user, then this will
retrieve the whole transaction, including card details and disbursement information
if available.
 * @summary Get Transaction By Id
 */
export type getTransactionByIdWalletTransactionsTxnGetResponse200 = {
  data: Transaction
  status: 200
}

export type getTransactionByIdWalletTransactionsTxnGetResponse401 = {
  data: null
  status: 401
}

export type getTransactionByIdWalletTransactionsTxnGetResponse403 = {
  data: null
  status: 403
}

export type getTransactionByIdWalletTransactionsTxnGetResponse404 = {
  data: null
  status: 404
}

export type getTransactionByIdWalletTransactionsTxnGetResponse422 = {
  data: null
  status: 422
}

export type getTransactionByIdWalletTransactionsTxnGetResponse500 = {
  data: null
  status: 500
}

export type getTransactionByIdWalletTransactionsTxnGetResponseComposite =
  | getTransactionByIdWalletTransactionsTxnGetResponse200
  | getTransactionByIdWalletTransactionsTxnGetResponse401
  | getTransactionByIdWalletTransactionsTxnGetResponse403
  | getTransactionByIdWalletTransactionsTxnGetResponse404
  | getTransactionByIdWalletTransactionsTxnGetResponse422
  | getTransactionByIdWalletTransactionsTxnGetResponse500

export type getTransactionByIdWalletTransactionsTxnGetResponse =
  getTransactionByIdWalletTransactionsTxnGetResponseComposite & {
    headers: Headers
  }

export const getGetTransactionByIdWalletTransactionsTxnGetUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}`
}

export const getTransactionByIdWalletTransactionsTxnGet = async (
  txn: string,
  options?: RequestInit,
): Promise<getTransactionByIdWalletTransactionsTxnGetResponse> => {
  const res = await fetch(
    getGetTransactionByIdWalletTransactionsTxnGetUrl(txn),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTransactionByIdWalletTransactionsTxnGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getTransactionByIdWalletTransactionsTxnGetResponse
}

export const getGetTransactionByIdWalletTransactionsTxnGetQueryKey = (
  txn?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}`,
  ] as const
}

export const getGetTransactionByIdWalletTransactionsTxnGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTransactionByIdWalletTransactionsTxnGetQueryKey(txn)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
  > = ({ signal }) =>
    getTransactionByIdWalletTransactionsTxnGet(txn, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!txn,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionByIdWalletTransactionsTxnGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
>
export type GetTransactionByIdWalletTransactionsTxnGetQueryError =
  | null
  | null
  | null
  | null
  | null

export function useGetTransactionByIdWalletTransactionsTxnGet<
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
          >,
          TError,
          Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTransactionByIdWalletTransactionsTxnGet<
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
          >,
          TError,
          Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTransactionByIdWalletTransactionsTxnGet<
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Transaction By Id
 */

export function useGetTransactionByIdWalletTransactionsTxnGet<
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetTransactionByIdWalletTransactionsTxnGetQueryOptions(txn, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Set the card associated with a transaction.

The posted card must exactly match one of the cards returned by the wallet
info endpoint or else the update may not succeed
 * @summary Set Transaction Card
 */
export type setTransactionCardWalletTransactionsTxnSetcardPostResponse200 = {
  data: unknown
  status: 200
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse401 = {
  data: null
  status: 401
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse403 = {
  data: null
  status: 403
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse404 = {
  data: null
  status: 404
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse422 = {
  data: null
  status: 422
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse500 = {
  data: null
  status: 500
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponseComposite =

    | setTransactionCardWalletTransactionsTxnSetcardPostResponse200
    | setTransactionCardWalletTransactionsTxnSetcardPostResponse401
    | setTransactionCardWalletTransactionsTxnSetcardPostResponse403
    | setTransactionCardWalletTransactionsTxnSetcardPostResponse404
    | setTransactionCardWalletTransactionsTxnSetcardPostResponse422
    | setTransactionCardWalletTransactionsTxnSetcardPostResponse500

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse =
  setTransactionCardWalletTransactionsTxnSetcardPostResponseComposite & {
    headers: Headers
  }

export const getSetTransactionCardWalletTransactionsTxnSetcardPostUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/setcard`
}

export const setTransactionCardWalletTransactionsTxnSetcardPost = async (
  txn: string,
  paymentCardInfo: PaymentCardInfo,
  options?: RequestInit,
): Promise<setTransactionCardWalletTransactionsTxnSetcardPostResponse> => {
  const res = await fetch(
    getSetTransactionCardWalletTransactionsTxnSetcardPostUrl(txn),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(paymentCardInfo),
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: setTransactionCardWalletTransactionsTxnSetcardPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as setTransactionCardWalletTransactionsTxnSetcardPostResponse
}

export const getSetTransactionCardWalletTransactionsTxnSetcardPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
      >,
      TError,
      { txn: string; data: PaymentCardInfo },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
    >,
    TError,
    { txn: string; data: PaymentCardInfo },
    TContext
  > => {
    const mutationKey = ["setTransactionCardWalletTransactionsTxnSetcardPost"]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
      >,
      { txn: string; data: PaymentCardInfo }
    > = (props) => {
      const { txn, data } = props ?? {}

      return setTransactionCardWalletTransactionsTxnSetcardPost(
        txn,
        data,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
    >
  >
export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationBody =
  PaymentCardInfo
export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Set Transaction Card
 */
export const useSetTransactionCardWalletTransactionsTxnSetcardPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
      >,
      TError,
      { txn: string; data: PaymentCardInfo },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
  >,
  TError,
  { txn: string; data: PaymentCardInfo },
  TContext
> => {
  const mutationOptions =
    getSetTransactionCardWalletTransactionsTxnSetcardPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions, queryClient)
}
/**
 * Cancel a transaction in the `new` or `retry` states.

Note that this may actually not cancel if a webhook fires asynchronously
and updates the transaction.  This API will not attempt to prevent stripe
payments from completing.
 * @summary Cancel Transaction
 */
export type cancelTransactionWalletTransactionsTxnCancelPostResponse200 = {
  data: unknown
  status: 200
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse201 = {
  data: null
  status: 201
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse401 = {
  data: null
  status: 401
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse403 = {
  data: null
  status: 403
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse404 = {
  data: null
  status: 404
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse422 = {
  data: null
  status: 422
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse500 = {
  data: null
  status: 500
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponseComposite =
  | cancelTransactionWalletTransactionsTxnCancelPostResponse200
  | cancelTransactionWalletTransactionsTxnCancelPostResponse201
  | cancelTransactionWalletTransactionsTxnCancelPostResponse401
  | cancelTransactionWalletTransactionsTxnCancelPostResponse403
  | cancelTransactionWalletTransactionsTxnCancelPostResponse404
  | cancelTransactionWalletTransactionsTxnCancelPostResponse422
  | cancelTransactionWalletTransactionsTxnCancelPostResponse500

export type cancelTransactionWalletTransactionsTxnCancelPostResponse =
  cancelTransactionWalletTransactionsTxnCancelPostResponseComposite & {
    headers: Headers
  }

export const getCancelTransactionWalletTransactionsTxnCancelPostUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/cancel`
}

export const cancelTransactionWalletTransactionsTxnCancelPost = async (
  txn: string,
  options?: RequestInit,
): Promise<cancelTransactionWalletTransactionsTxnCancelPostResponse> => {
  const res = await fetch(
    getCancelTransactionWalletTransactionsTxnCancelPostUrl(txn),
    {
      ...options,
      method: "POST",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: cancelTransactionWalletTransactionsTxnCancelPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as cancelTransactionWalletTransactionsTxnCancelPostResponse
}

export const getCancelTransactionWalletTransactionsTxnCancelPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
      >,
      TError,
      { txn: string },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
    >,
    TError,
    { txn: string },
    TContext
  > => {
    const mutationKey = ["cancelTransactionWalletTransactionsTxnCancelPost"]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
      >,
      { txn: string }
    > = (props) => {
      const { txn } = props ?? {}

      return cancelTransactionWalletTransactionsTxnCancelPost(txn, fetchOptions)
    }

    return { mutationFn, ...mutationOptions }
  }

export type CancelTransactionWalletTransactionsTxnCancelPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>>
  >

export type CancelTransactionWalletTransactionsTxnCancelPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Cancel Transaction
 */
export const useCancelTransactionWalletTransactionsTxnCancelPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
      >,
      TError,
      { txn: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>>,
  TError,
  { txn: string },
  TContext
> => {
  const mutationOptions =
    getCancelTransactionWalletTransactionsTxnCancelPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Return the stripe public key to use in the frontend.  Since this is not
considered secret, we don't need a login or anything for this
 * @summary Get Stripedata
 */
export type getStripedataWalletStripedataGetResponse200 = {
  data: StripeKeys
  status: 200
}

export type getStripedataWalletStripedataGetResponse500 = {
  data: null
  status: 500
}

export type getStripedataWalletStripedataGetResponseComposite =
  | getStripedataWalletStripedataGetResponse200
  | getStripedataWalletStripedataGetResponse500

export type getStripedataWalletStripedataGetResponse =
  getStripedataWalletStripedataGetResponseComposite & {
    headers: Headers
  }

export const getGetStripedataWalletStripedataGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/stripedata`
}

export const getStripedataWalletStripedataGet = async (
  options?: RequestInit,
): Promise<getStripedataWalletStripedataGetResponse> => {
  const res = await fetch(getGetStripedataWalletStripedataGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getStripedataWalletStripedataGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getStripedataWalletStripedataGetResponse
}

export const getGetStripedataWalletStripedataGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/stripedata`] as const
}

export const getGetStripedataWalletStripedataGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetStripedataWalletStripedataGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
  > = ({ signal }) =>
    getStripedataWalletStripedataGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStripedataWalletStripedataGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
>
export type GetStripedataWalletStripedataGetQueryError = null

export function useGetStripedataWalletStripedataGet<
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
          TError,
          Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetStripedataWalletStripedataGet<
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
          TError,
          Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetStripedataWalletStripedataGet<
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Stripedata
 */

export function useGetStripedataWalletStripedataGet<
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetStripedataWalletStripedataGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Return the Stripe data associated with the given transaction.

This is only applicable to transactions in the `new` or `retry` state and
will only work for transactions which *are* Stripe transactions.
 * @summary Get Txn Stripedata
 */
export type getTxnStripedataWalletTransactionsTxnStripeGetResponse200 = {
  data: TransactionStripeData
  status: 200
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse401 = {
  data: null
  status: 401
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse403 = {
  data: null
  status: 403
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse404 = {
  data: null
  status: 404
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse422 = {
  data: null
  status: 422
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse500 = {
  data: null
  status: 500
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponseComposite =
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse200
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse401
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse403
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse404
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse422
  | getTxnStripedataWalletTransactionsTxnStripeGetResponse500

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse =
  getTxnStripedataWalletTransactionsTxnStripeGetResponseComposite & {
    headers: Headers
  }

export const getGetTxnStripedataWalletTransactionsTxnStripeGetUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/stripe`
}

export const getTxnStripedataWalletTransactionsTxnStripeGet = async (
  txn: string,
  options?: RequestInit,
): Promise<getTxnStripedataWalletTransactionsTxnStripeGetResponse> => {
  const res = await fetch(
    getGetTxnStripedataWalletTransactionsTxnStripeGetUrl(txn),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTxnStripedataWalletTransactionsTxnStripeGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getTxnStripedataWalletTransactionsTxnStripeGetResponse
}

export const getGetTxnStripedataWalletTransactionsTxnStripeGetQueryKey = (
  txn?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/stripe`,
  ] as const
}

export const getGetTxnStripedataWalletTransactionsTxnStripeGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTxnStripedataWalletTransactionsTxnStripeGetQueryKey(txn)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>
  > = ({ signal }) =>
    getTxnStripedataWalletTransactionsTxnStripeGet(txn, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!txn,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTxnStripedataWalletTransactionsTxnStripeGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>
  >
export type GetTxnStripedataWalletTransactionsTxnStripeGetQueryError =
  | null
  | null
  | null
  | null
  | null

export function useGetTxnStripedataWalletTransactionsTxnStripeGet<
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTxnStripedataWalletTransactionsTxnStripeGet<
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTxnStripedataWalletTransactionsTxnStripeGet<
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Txn Stripedata
 */

export function useGetTxnStripedataWalletTransactionsTxnStripeGet<
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = null | null | null | null | null,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetTxnStripedataWalletTransactionsTxnStripeGetQueryOptions(txn, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Set the save-card status.

This is only applicable to transactions in the `new` or `retry` state
and will only work for transactions which are backed by stripe or similar.

If the `save_card` parameter is null, then the card will not be saved,
otherwise it will be saved.  If it's set to `off_session` then an attempt
will be made to create a saved method which can be used without the user
re-authenticating
 * @summary Set Savecard
 */
export type setSavecardWalletTransactionsTxnSavecardPostResponse200 = {
  data: unknown
  status: 200
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse201 = {
  data: null
  status: 201
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse401 = {
  data: null
  status: 401
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse403 = {
  data: null
  status: 403
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse404 = {
  data: null
  status: 404
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse422 = {
  data: null
  status: 422
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse500 = {
  data: null
  status: 500
}

export type setSavecardWalletTransactionsTxnSavecardPostResponseComposite =
  | setSavecardWalletTransactionsTxnSavecardPostResponse200
  | setSavecardWalletTransactionsTxnSavecardPostResponse201
  | setSavecardWalletTransactionsTxnSavecardPostResponse401
  | setSavecardWalletTransactionsTxnSavecardPostResponse403
  | setSavecardWalletTransactionsTxnSavecardPostResponse404
  | setSavecardWalletTransactionsTxnSavecardPostResponse422
  | setSavecardWalletTransactionsTxnSavecardPostResponse500

export type setSavecardWalletTransactionsTxnSavecardPostResponse =
  setSavecardWalletTransactionsTxnSavecardPostResponseComposite & {
    headers: Headers
  }

export const getSetSavecardWalletTransactionsTxnSavecardPostUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/savecard`
}

export const setSavecardWalletTransactionsTxnSavecardPost = async (
  txn: string,
  transactionSaveCard: TransactionSaveCard,
  options?: RequestInit,
): Promise<setSavecardWalletTransactionsTxnSavecardPostResponse> => {
  const res = await fetch(
    getSetSavecardWalletTransactionsTxnSavecardPostUrl(txn),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(transactionSaveCard),
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: setSavecardWalletTransactionsTxnSavecardPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as setSavecardWalletTransactionsTxnSavecardPostResponse
}

export const getSetSavecardWalletTransactionsTxnSavecardPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
    TError,
    { txn: string; data: TransactionSaveCard },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
  TError,
  { txn: string; data: TransactionSaveCard },
  TContext
> => {
  const mutationKey = ["setSavecardWalletTransactionsTxnSavecardPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
    { txn: string; data: TransactionSaveCard }
  > = (props) => {
    const { txn, data } = props ?? {}

    return setSavecardWalletTransactionsTxnSavecardPost(txn, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetSavecardWalletTransactionsTxnSavecardPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>
  >
export type SetSavecardWalletTransactionsTxnSavecardPostMutationBody =
  TransactionSaveCard
export type SetSavecardWalletTransactionsTxnSavecardPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Set Savecard
 */
export const useSetSavecardWalletTransactionsTxnSavecardPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
      TError,
      { txn: string; data: TransactionSaveCard },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
  TError,
  { txn: string; data: TransactionSaveCard },
  TContext
> => {
  const mutationOptions =
    getSetSavecardWalletTransactionsTxnSavecardPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Set the transaction as 'pending' so that we can recover if Stripe
flows don't quite work (e.g. webhook goes missing)
 * @summary Set Pending
 */
export type setPendingWalletTransactionsTxnSetpendingPostResponse200 = {
  data: unknown
  status: 200
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse201 = {
  data: null
  status: 201
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse401 = {
  data: null
  status: 401
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse403 = {
  data: null
  status: 403
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse404 = {
  data: null
  status: 404
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse422 = {
  data: null
  status: 422
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse500 = {
  data: null
  status: 500
}

export type setPendingWalletTransactionsTxnSetpendingPostResponseComposite =
  | setPendingWalletTransactionsTxnSetpendingPostResponse200
  | setPendingWalletTransactionsTxnSetpendingPostResponse201
  | setPendingWalletTransactionsTxnSetpendingPostResponse401
  | setPendingWalletTransactionsTxnSetpendingPostResponse403
  | setPendingWalletTransactionsTxnSetpendingPostResponse404
  | setPendingWalletTransactionsTxnSetpendingPostResponse422
  | setPendingWalletTransactionsTxnSetpendingPostResponse500

export type setPendingWalletTransactionsTxnSetpendingPostResponse =
  setPendingWalletTransactionsTxnSetpendingPostResponseComposite & {
    headers: Headers
  }

export const getSetPendingWalletTransactionsTxnSetpendingPostUrl = (
  txn: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/transactions/${txn}/setpending`
}

export const setPendingWalletTransactionsTxnSetpendingPost = async (
  txn: string,
  options?: RequestInit,
): Promise<setPendingWalletTransactionsTxnSetpendingPostResponse> => {
  const res = await fetch(
    getSetPendingWalletTransactionsTxnSetpendingPostUrl(txn),
    {
      ...options,
      method: "POST",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: setPendingWalletTransactionsTxnSetpendingPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as setPendingWalletTransactionsTxnSetpendingPostResponse
}

export const getSetPendingWalletTransactionsTxnSetpendingPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
    TError,
    { txn: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
  TError,
  { txn: string },
  TContext
> => {
  const mutationKey = ["setPendingWalletTransactionsTxnSetpendingPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
    { txn: string }
  > = (props) => {
    const { txn } = props ?? {}

    return setPendingWalletTransactionsTxnSetpendingPost(txn, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetPendingWalletTransactionsTxnSetpendingPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>
  >

export type SetPendingWalletTransactionsTxnSetpendingPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Set Pending
 */
export const useSetPendingWalletTransactionsTxnSetpendingPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
      TError,
      { txn: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
  TError,
  { txn: string },
  TContext
> => {
  const mutationOptions =
    getSetPendingWalletTransactionsTxnSetpendingPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Clear the fake wallet details
 * @summary Clear Fake
 */
export type clearFakeWalletClearfakePostResponse200 = {
  data: unknown
  status: 200
}

export type clearFakeWalletClearfakePostResponse201 = {
  data: null
  status: 201
}

export type clearFakeWalletClearfakePostResponse500 = {
  data: null
  status: 500
}

export type clearFakeWalletClearfakePostResponseComposite =
  | clearFakeWalletClearfakePostResponse200
  | clearFakeWalletClearfakePostResponse201
  | clearFakeWalletClearfakePostResponse500

export type clearFakeWalletClearfakePostResponse =
  clearFakeWalletClearfakePostResponseComposite & {
    headers: Headers
  }

export const getClearFakeWalletClearfakePostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/clearfake`
}

export const clearFakeWalletClearfakePost = async (
  options?: RequestInit,
): Promise<clearFakeWalletClearfakePostResponse> => {
  const res = await fetch(getClearFakeWalletClearfakePostUrl(), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: clearFakeWalletClearfakePostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as clearFakeWalletClearfakePostResponse
}

export const getClearFakeWalletClearfakePostMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["clearFakeWalletClearfakePost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>,
    void
  > = () => {
    return clearFakeWalletClearfakePost(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ClearFakeWalletClearfakePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>
>

export type ClearFakeWalletClearfakePostMutationError = null

/**
 * @summary Clear Fake
 */
export const useClearFakeWalletClearfakePost = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof clearFakeWalletClearfakePost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getClearFakeWalletClearfakePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * This endpoint is intended to deal with webhooks coming back from payment
mechanisms etc.  It exists only for the deployed wallet, so its name
will vary with the deployed wallet kind.

The exact form of the content posted to the webhook will vary from wallet
kind to wallet kind.
 * @summary Webhook
 */
export type webhookWalletWebhookFakewalletPostResponse200 = {
  data: unknown
  status: 200
}

export type webhookWalletWebhookFakewalletPostResponse400 = {
  data: null
  status: 400
}

export type webhookWalletWebhookFakewalletPostResponse500 = {
  data: null
  status: 500
}

export type webhookWalletWebhookFakewalletPostResponseComposite =
  | webhookWalletWebhookFakewalletPostResponse200
  | webhookWalletWebhookFakewalletPostResponse400
  | webhookWalletWebhookFakewalletPostResponse500

export type webhookWalletWebhookFakewalletPostResponse =
  webhookWalletWebhookFakewalletPostResponseComposite & {
    headers: Headers
  }

export const getWebhookWalletWebhookFakewalletPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/wallet/webhook/fakewallet`
}

export const webhookWalletWebhookFakewalletPost = async (
  options?: RequestInit,
): Promise<webhookWalletWebhookFakewalletPostResponse> => {
  const res = await fetch(getWebhookWalletWebhookFakewalletPostUrl(), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: webhookWalletWebhookFakewalletPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as webhookWalletWebhookFakewalletPostResponse
}

export const getWebhookWalletWebhookFakewalletPostMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["webhookWalletWebhookFakewalletPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>,
    void
  > = () => {
    return webhookWalletWebhookFakewalletPost(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type WebhookWalletWebhookFakewalletPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>
>

export type WebhookWalletWebhookFakewalletPostMutationError = null | null

/**
 * @summary Webhook
 */
export const useWebhookWalletWebhookFakewalletPost = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof webhookWalletWebhookFakewalletPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getWebhookWalletWebhookFakewalletPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
