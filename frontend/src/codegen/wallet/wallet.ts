/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"
import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"
import type {
  CancelTransactionWalletTransactionsTxnCancelPost200,
  GetStripedataWalletStripedataGet200,
  GetTransactionsWalletTransactionsGetParams,
  GetTxnStripedataWalletTransactionsTxnStripeGet200,
  HTTPValidationError,
  NascentTransaction,
  PaymentCardInfo,
  PostRemovecardWalletRemovecardPost200,
  PostTransactionResponse,
  SetPendingWalletTransactionsTxnSetpendingPost200,
  SetSavecardWalletTransactionsTxnSavecardPost200,
  SetTransactionCardWalletTransactionsTxnSetcardPost200,
  Transaction,
  TransactionSaveCard,
  TransactionSummary,
  WalletInfo,
  WebhookWalletWebhookStripePost200,
} from ".././model"

/**
 * Retrieve the wallet for the currently logged in user.

This will return a list of cards which the user has saved to their account.
 * @summary Get Walletinfo
 */
export const getWalletinfoWalletWalletinfoGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<WalletInfo>> => {
  return axios.get(`/wallet/walletinfo`, options)
}

export const getGetWalletinfoWalletWalletinfoGetQueryKey = () => {
  return [`/wallet/walletinfo`] as const
}

export const getGetWalletinfoWalletWalletinfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetWalletinfoWalletWalletinfoGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
  > = ({ signal }) =>
    getWalletinfoWalletWalletinfoGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetWalletinfoWalletWalletinfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>
>
export type GetWalletinfoWalletWalletinfoGetQueryError = AxiosError<unknown>

/**
 * @summary Get Walletinfo
 */
export const useGetWalletinfoWalletWalletinfoGet = <
  TData = Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getWalletinfoWalletWalletinfoGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetWalletinfoWalletWalletinfoGetQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Remove a card from a user's wallet.

The provided information must exactly match a card as would be returned from the
wallet info endpoint.
 * @summary Post Removecard
 */
export const postRemovecardWalletRemovecardPost = (
  paymentCardInfo: PaymentCardInfo,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PostRemovecardWalletRemovecardPost200>> => {
  return axios.post(`/wallet/removecard`, paymentCardInfo, options)
}

export const getPostRemovecardWalletRemovecardPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
    TError,
    { data: PaymentCardInfo },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
  TError,
  { data: PaymentCardInfo },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
    { data: PaymentCardInfo }
  > = (props) => {
    const { data } = props ?? {}

    return postRemovecardWalletRemovecardPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostRemovecardWalletRemovecardPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>
>
export type PostRemovecardWalletRemovecardPostMutationBody = PaymentCardInfo
export type PostRemovecardWalletRemovecardPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Post Removecard
 */
export const usePostRemovecardWalletRemovecardPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRemovecardWalletRemovecardPost>>,
    TError,
    { data: PaymentCardInfo },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getPostRemovecardWalletRemovecardPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Return a list of transactions associated with this user.

If anything goes wrong, an error will be returned, otherwise a list of transaction
summaries will be returned.
 * @summary Get Transactions
 */
export const getTransactionsWalletTransactionsGet = (
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TransactionSummary[]>> => {
  return axios.get(`/wallet/transactions`, {
    ...options,
    params: { ...params, ...options?.params },
  })
}

export const getGetTransactionsWalletTransactionsGetQueryKey = (
  params?: GetTransactionsWalletTransactionsGetParams,
) => {
  return [`/wallet/transactions`, ...(params ? [params] : [])] as const
}

export const getGetTransactionsWalletTransactionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTransactionsWalletTransactionsGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
  > = ({ signal }) =>
    getTransactionsWalletTransactionsGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTransactionsWalletTransactionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>
>
export type GetTransactionsWalletTransactionsGetQueryError =
  AxiosError<HTTPValidationError>

/**
 * @summary Get Transactions
 */
export const useGetTransactionsWalletTransactionsGet = <
  TData = Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetTransactionsWalletTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionsWalletTransactionsGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTransactionsWalletTransactionsGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new transaction, return the ID.

If the passed in nascent transaction is valid, this will create a transaction and
return the ID of the newly created wallet, otherwise it'll return an error
 * @summary Create Transaction
 */
export const createTransactionWalletTransactionsPost = (
  nascentTransaction: NascentTransaction,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PostTransactionResponse>> => {
  return axios.post(`/wallet/transactions`, nascentTransaction, options)
}

export const getCreateTransactionWalletTransactionsPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
    TError,
    { data: NascentTransaction },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
  TError,
  { data: NascentTransaction },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
    { data: NascentTransaction }
  > = (props) => {
    const { data } = props ?? {}

    return createTransactionWalletTransactionsPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTransactionWalletTransactionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>
>
export type CreateTransactionWalletTransactionsPostMutationBody =
  NascentTransaction
export type CreateTransactionWalletTransactionsPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Create Transaction
 */
export const useCreateTransactionWalletTransactionsPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTransactionWalletTransactionsPost>>,
    TError,
    { data: NascentTransaction },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getCreateTransactionWalletTransactionsPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Retrieve a transaction by its ID

If the transaction ID is valid, and owned by the calling user, then this will
retrieve the whole transaction, including card details and disbursement information
if available.
 * @summary Get Transaction By Id
 */
export const getTransactionByIdWalletTransactionsTxnGet = (
  txn: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Transaction>> => {
  return axios.get(`/wallet/transactions/${txn}`, options)
}

export const getGetTransactionByIdWalletTransactionsTxnGetQueryKey = (
  txn: string,
) => {
  return [`/wallet/transactions/${txn}`] as const
}

export const getGetTransactionByIdWalletTransactionsTxnGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTransactionByIdWalletTransactionsTxnGetQueryKey(txn)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
  > = ({ signal }) =>
    getTransactionByIdWalletTransactionsTxnGet(txn, { signal, ...axiosOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!txn,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTransactionByIdWalletTransactionsTxnGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>
>
export type GetTransactionByIdWalletTransactionsTxnGetQueryError =
  AxiosError<HTTPValidationError>

/**
 * @summary Get Transaction By Id
 */
export const useGetTransactionByIdWalletTransactionsTxnGet = <
  TData = Awaited<
    ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionByIdWalletTransactionsTxnGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetTransactionByIdWalletTransactionsTxnGetQueryOptions(txn, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Set the card associated with a transaction.

The posted card must exactly match one of the cards returned by the wallet
info endpoint or else the update may not succeed
 * @summary Set Transaction Card
 */
export const setTransactionCardWalletTransactionsTxnSetcardPost = (
  txn: string,
  paymentCardInfo: PaymentCardInfo,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<SetTransactionCardWalletTransactionsTxnSetcardPost200>
> => {
  return axios.post(
    `/wallet/transactions/${txn}/setcard`,
    paymentCardInfo,
    options,
  )
}

export const getSetTransactionCardWalletTransactionsTxnSetcardPostMutationOptions =
  <TError = AxiosError<HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
      >,
      TError,
      { txn: string; data: PaymentCardInfo },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
    >,
    TError,
    { txn: string; data: PaymentCardInfo },
    TContext
  > => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
      >,
      { txn: string; data: PaymentCardInfo }
    > = (props) => {
      const { txn, data } = props ?? {}

      return setTransactionCardWalletTransactionsTxnSetcardPost(
        txn,
        data,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
    >
  >
export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationBody =
  PaymentCardInfo
export type SetTransactionCardWalletTransactionsTxnSetcardPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Set Transaction Card
 */
export const useSetTransactionCardWalletTransactionsTxnSetcardPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof setTransactionCardWalletTransactionsTxnSetcardPost>
    >,
    TError,
    { txn: string; data: PaymentCardInfo },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getSetTransactionCardWalletTransactionsTxnSetcardPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions)
}
/**
 * Cancel a transaction in the `new` or `retry` states.

Note that this may actually not cancel if a webhook fires asynchronously
and updates the transaction.  This API will not attempt to prevent stripe
payments from completing.
 * @summary Cancel Transaction
 */
export const cancelTransactionWalletTransactionsTxnCancelPost = (
  txn: string,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<CancelTransactionWalletTransactionsTxnCancelPost200>
> => {
  return axios.post(`/wallet/transactions/${txn}/cancel`, undefined, options)
}

export const getCancelTransactionWalletTransactionsTxnCancelPostMutationOptions =
  <TError = AxiosError<HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
      >,
      TError,
      { txn: string },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
    >,
    TError,
    { txn: string },
    TContext
  > => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
      >,
      { txn: string }
    > = (props) => {
      const { txn } = props ?? {}

      return cancelTransactionWalletTransactionsTxnCancelPost(txn, axiosOptions)
    }

    return { mutationFn, ...mutationOptions }
  }

export type CancelTransactionWalletTransactionsTxnCancelPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>>
  >

export type CancelTransactionWalletTransactionsTxnCancelPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Cancel Transaction
 */
export const useCancelTransactionWalletTransactionsTxnCancelPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof cancelTransactionWalletTransactionsTxnCancelPost>
    >,
    TError,
    { txn: string },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getCancelTransactionWalletTransactionsTxnCancelPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Return the stripe public key to use in the frontend.  Since this is not
considered secret, we don't need a login or anything for this
 * @summary Get Stripedata
 */
export const getStripedataWalletStripedataGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetStripedataWalletStripedataGet200>> => {
  return axios.get(`/wallet/stripedata`, options)
}

export const getGetStripedataWalletStripedataGetQueryKey = () => {
  return [`/wallet/stripedata`] as const
}

export const getGetStripedataWalletStripedataGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetStripedataWalletStripedataGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
  > = ({ signal }) =>
    getStripedataWalletStripedataGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetStripedataWalletStripedataGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>
>
export type GetStripedataWalletStripedataGetQueryError = AxiosError<unknown>

/**
 * @summary Get Stripedata
 */
export const useGetStripedataWalletStripedataGet = <
  TData = Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStripedataWalletStripedataGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetStripedataWalletStripedataGetQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Return the Stripe data associated with the given transaction.

This is only applicable to transactions in the `new` or `retry` state and
will only work for transactions which *are* Stripe transactions.
 * @summary Get Txn Stripedata
 */
export const getTxnStripedataWalletTransactionsTxnStripeGet = (
  txn: string,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<GetTxnStripedataWalletTransactionsTxnStripeGet200>
> => {
  return axios.get(`/wallet/transactions/${txn}/stripe`, options)
}

export const getGetTxnStripedataWalletTransactionsTxnStripeGetQueryKey = (
  txn: string,
) => {
  return [`/wallet/transactions/${txn}/stripe`] as const
}

export const getGetTxnStripedataWalletTransactionsTxnStripeGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTxnStripedataWalletTransactionsTxnStripeGetQueryKey(txn)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>
  > = ({ signal }) =>
    getTxnStripedataWalletTransactionsTxnStripeGet(txn, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!txn,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTxnStripedataWalletTransactionsTxnStripeGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>>
  >
export type GetTxnStripedataWalletTransactionsTxnStripeGetQueryError =
  AxiosError<HTTPValidationError>

/**
 * @summary Get Txn Stripedata
 */
export const useGetTxnStripedataWalletTransactionsTxnStripeGet = <
  TData = Awaited<
    ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  txn: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTxnStripedataWalletTransactionsTxnStripeGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetTxnStripedataWalletTransactionsTxnStripeGetQueryOptions(txn, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Set the save-card status.

This is only applicable to transactions in the `new` or `retry` state
and will only work for transactions which are backed by stripe or similar.

If the `save_card` parameter is null, then the card will not be saved,
otherwise it will be saved.  If it's set to `off_session` then an attempt
will be made to create a saved method which can be used without the user
re-authenticating
 * @summary Set Savecard
 */
export const setSavecardWalletTransactionsTxnSavecardPost = (
  txn: string,
  transactionSaveCard: TransactionSaveCard,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SetSavecardWalletTransactionsTxnSavecardPost200>> => {
  return axios.post(
    `/wallet/transactions/${txn}/savecard`,
    transactionSaveCard,
    options,
  )
}

export const getSetSavecardWalletTransactionsTxnSavecardPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
    TError,
    { txn: string; data: TransactionSaveCard },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
  TError,
  { txn: string; data: TransactionSaveCard },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
    { txn: string; data: TransactionSaveCard }
  > = (props) => {
    const { txn, data } = props ?? {}

    return setSavecardWalletTransactionsTxnSavecardPost(txn, data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetSavecardWalletTransactionsTxnSavecardPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>
  >
export type SetSavecardWalletTransactionsTxnSavecardPostMutationBody =
  TransactionSaveCard
export type SetSavecardWalletTransactionsTxnSavecardPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Set Savecard
 */
export const useSetSavecardWalletTransactionsTxnSavecardPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setSavecardWalletTransactionsTxnSavecardPost>>,
    TError,
    { txn: string; data: TransactionSaveCard },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getSetSavecardWalletTransactionsTxnSavecardPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Set the transaction as 'pending' so that we can recover if Stripe
flows don't quite work (e.g. webhook goes missing)
 * @summary Set Pending
 */
export const setPendingWalletTransactionsTxnSetpendingPost = (
  txn: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SetPendingWalletTransactionsTxnSetpendingPost200>> => {
  return axios.post(
    `/wallet/transactions/${txn}/setpending`,
    undefined,
    options,
  )
}

export const getSetPendingWalletTransactionsTxnSetpendingPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
    TError,
    { txn: string },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
  TError,
  { txn: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
    { txn: string }
  > = (props) => {
    const { txn } = props ?? {}

    return setPendingWalletTransactionsTxnSetpendingPost(txn, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetPendingWalletTransactionsTxnSetpendingPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>
  >

export type SetPendingWalletTransactionsTxnSetpendingPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Set Pending
 */
export const useSetPendingWalletTransactionsTxnSetpendingPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPendingWalletTransactionsTxnSetpendingPost>>,
    TError,
    { txn: string },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getSetPendingWalletTransactionsTxnSetpendingPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * This endpoint is intended to deal with webhooks coming back from payment
mechanisms etc.  It exists only for the deployed wallet, so its name
will vary with the deployed wallet kind.

The exact form of the content posted to the webhook will vary from wallet
kind to wallet kind.
 * @summary Webhook
 */
export const webhookWalletWebhookStripePost = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<WebhookWalletWebhookStripePost200>> => {
  return axios.post(`/wallet/webhook/stripe`, undefined, options)
}

export const getWebhookWalletWebhookStripePostMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhookWalletWebhookStripePost>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhookWalletWebhookStripePost>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhookWalletWebhookStripePost>>,
    void
  > = () => {
    return webhookWalletWebhookStripePost(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type WebhookWalletWebhookStripePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhookWalletWebhookStripePost>>
>

export type WebhookWalletWebhookStripePostMutationError = AxiosError<unknown>

/**
 * @summary Webhook
 */
export const useWebhookWalletWebhookStripePost = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhookWalletWebhookStripePost>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationOptions =
    getWebhookWalletWebhookStripePostMutationOptions(options)

  return useMutation(mutationOptions)
}
