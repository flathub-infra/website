/**
 * Generated by orval üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"

import qs from "qs"

import type {
  ContinueGithubFlowAuthLoginGithubPostBody,
  ContinueGitlabFlowAuthLoginGitlabPostBody,
  ContinueGnomeFlowAuthLoginGnomePostBody,
  ContinueGoogleFlowAuthLoginGooglePostBody,
  ContinueKdeFlowAuthLoginKdePostBody,
  DeleteUserResult,
  DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,
  GetDeleteUserResult,
  GetUserinfoAuthUserinfoGet200,
  HTTPValidationError,
  LoginMethod,
  RefreshDevFlatpaksReturn,
  UserDeleteRequest,
} from ".././model"

/**
 * Retrieve the login methods available from the backend.

For each method returned, flow starts with a `GET` to the endpoint
`.../login/{method}` and upon completion from the user-agent, with a `POST`
to that same endpoint name.

Each method is also given a button icon and some text to use, though
frontends with localisation may choose to render other text instead.
 * @summary Get Login Methods
 */
export const getLoginMethodsAuthLoginGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<LoginMethod[]>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login`,
    options,
  )
}

export const getGetLoginMethodsAuthLoginGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login`] as const
}

export const getGetLoginMethodsAuthLoginGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetLoginMethodsAuthLoginGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
  > = ({ signal }) => getLoginMethodsAuthLoginGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLoginMethodsAuthLoginGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
>
export type GetLoginMethodsAuthLoginGetQueryError = AxiosError<unknown>

export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
          TError,
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
          TError,
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Login Methods
 */

export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetLoginMethodsAuthLoginGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Starts a github login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Github

Upon return from Github to the frontend, the frontend should POST to this
endpoint with the relevant data from Github

If the user is already logged in, and has a valid github token stored,
then this will return an error instead.
 * @summary Start Github Flow
 */
export const startGithubFlowAuthLoginGithubGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`,
    options,
  )
}

export const getStartGithubFlowAuthLoginGithubGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`] as const
}

export const getStartGithubFlowAuthLoginGithubGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGithubFlowAuthLoginGithubGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
  > = ({ signal }) =>
    startGithubFlowAuthLoginGithubGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGithubFlowAuthLoginGithubGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
>
export type StartGithubFlowAuthLoginGithubGetQueryError = AxiosError<void>

export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
          TError,
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
          TError,
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Github Flow
 */

export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGithubFlowAuthLoginGithubGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the Github oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the github oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from github",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Github Flow
 */
export const continueGithubFlowAuthLoginGithubPost = (
  continueGithubFlowAuthLoginGithubPostBody: ContinueGithubFlowAuthLoginGithubPostBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`,
    continueGithubFlowAuthLoginGithubPostBody,
    options,
  )
}

export const getContinueGithubFlowAuthLoginGithubPostMutationOptions = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
    TError,
    { data: ContinueGithubFlowAuthLoginGithubPostBody },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
  TError,
  { data: ContinueGithubFlowAuthLoginGithubPostBody },
  TContext
> => {
  const mutationKey = ["continueGithubFlowAuthLoginGithubPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
    { data: ContinueGithubFlowAuthLoginGithubPostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGithubFlowAuthLoginGithubPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGithubFlowAuthLoginGithubPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>
>
export type ContinueGithubFlowAuthLoginGithubPostMutationBody =
  ContinueGithubFlowAuthLoginGithubPostBody
export type ContinueGithubFlowAuthLoginGithubPostMutationError =
  AxiosError<void | HTTPValidationError | void>

/**
 * @summary Continue Github Flow
 */
export const useContinueGithubFlowAuthLoginGithubPost = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
      TError,
      { data: ContinueGithubFlowAuthLoginGithubPostBody },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
  TError,
  { data: ContinueGithubFlowAuthLoginGithubPostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGithubFlowAuthLoginGithubPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Starts a gitlab login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Gitlab

Upon return from Gitlab to the frontend, the frontend should POST to this
endpoint with the relevant data from Gitlab

If the user is already logged in, and has a valid gitlab token stored,
then this will return an error instead.
 * @summary Start Gitlab Flow
 */
export const startGitlabFlowAuthLoginGitlabGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`,
    options,
  )
}

export const getStartGitlabFlowAuthLoginGitlabGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`] as const
}

export const getStartGitlabFlowAuthLoginGitlabGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGitlabFlowAuthLoginGitlabGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
  > = ({ signal }) =>
    startGitlabFlowAuthLoginGitlabGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGitlabFlowAuthLoginGitlabGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
>
export type StartGitlabFlowAuthLoginGitlabGetQueryError = AxiosError<void>

export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
          TError,
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
          TError,
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Gitlab Flow
 */

export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGitlabFlowAuthLoginGitlabGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the Gitlab oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gitlab Flow
 */
export const continueGitlabFlowAuthLoginGitlabPost = (
  continueGitlabFlowAuthLoginGitlabPostBody: ContinueGitlabFlowAuthLoginGitlabPostBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`,
    continueGitlabFlowAuthLoginGitlabPostBody,
    options,
  )
}

export const getContinueGitlabFlowAuthLoginGitlabPostMutationOptions = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
    TError,
    { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
  TError,
  { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
  TContext
> => {
  const mutationKey = ["continueGitlabFlowAuthLoginGitlabPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
    { data: ContinueGitlabFlowAuthLoginGitlabPostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGitlabFlowAuthLoginGitlabPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGitlabFlowAuthLoginGitlabPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>
>
export type ContinueGitlabFlowAuthLoginGitlabPostMutationBody =
  ContinueGitlabFlowAuthLoginGitlabPostBody
export type ContinueGitlabFlowAuthLoginGitlabPostMutationError =
  AxiosError<void | HTTPValidationError | void>

/**
 * @summary Continue Gitlab Flow
 */
export const useContinueGitlabFlowAuthLoginGitlabPost = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
      TError,
      { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
  TError,
  { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGitlabFlowAuthLoginGitlabPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Starts a GNOME login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to GNOME Gitlab

Upon return from GNOME to the frontend, the frontend should POST to this
endpoint with the relevant data from GNOME Gitlab

If the user is already logged in, and has a valid GNOME Gitlab token stored,
then this will return an error instead.
 * @summary Start Gnome Flow
 */
export const startGnomeFlowAuthLoginGnomeGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`,
    options,
  )
}

export const getStartGnomeFlowAuthLoginGnomeGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`] as const
}

export const getStartGnomeFlowAuthLoginGnomeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGnomeFlowAuthLoginGnomeGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
  > = ({ signal }) =>
    startGnomeFlowAuthLoginGnomeGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGnomeFlowAuthLoginGnomeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
>
export type StartGnomeFlowAuthLoginGnomeGetQueryError = AxiosError<void>

export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
          TError,
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
          TError,
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Gnome Flow
 */

export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGnomeFlowAuthLoginGnomeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the GNOME oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from GNOME gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gnome Flow
 */
export const continueGnomeFlowAuthLoginGnomePost = (
  continueGnomeFlowAuthLoginGnomePostBody: ContinueGnomeFlowAuthLoginGnomePostBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`,
    continueGnomeFlowAuthLoginGnomePostBody,
    options,
  )
}

export const getContinueGnomeFlowAuthLoginGnomePostMutationOptions = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
    TError,
    { data: ContinueGnomeFlowAuthLoginGnomePostBody },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
  TError,
  { data: ContinueGnomeFlowAuthLoginGnomePostBody },
  TContext
> => {
  const mutationKey = ["continueGnomeFlowAuthLoginGnomePost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
    { data: ContinueGnomeFlowAuthLoginGnomePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGnomeFlowAuthLoginGnomePost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGnomeFlowAuthLoginGnomePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>
>
export type ContinueGnomeFlowAuthLoginGnomePostMutationBody =
  ContinueGnomeFlowAuthLoginGnomePostBody
export type ContinueGnomeFlowAuthLoginGnomePostMutationError =
  AxiosError<void | HTTPValidationError | void>

/**
 * @summary Continue Gnome Flow
 */
export const useContinueGnomeFlowAuthLoginGnomePost = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
      TError,
      { data: ContinueGnomeFlowAuthLoginGnomePostBody },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
  TError,
  { data: ContinueGnomeFlowAuthLoginGnomePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGnomeFlowAuthLoginGnomePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Start Kde Flow
 */
export const startKdeFlowAuthLoginKdeGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`,
    options,
  )
}

export const getStartKdeFlowAuthLoginKdeGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`] as const
}

export const getStartKdeFlowAuthLoginKdeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartKdeFlowAuthLoginKdeGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
  > = ({ signal }) => startKdeFlowAuthLoginKdeGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartKdeFlowAuthLoginKdeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
>
export type StartKdeFlowAuthLoginKdeGetQueryError = AxiosError<void>

export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
          TError,
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
          TError,
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Kde Flow
 */

export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartKdeFlowAuthLoginKdeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Continue Kde Flow
 */
export const continueKdeFlowAuthLoginKdePost = (
  continueKdeFlowAuthLoginKdePostBody: ContinueKdeFlowAuthLoginKdePostBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`,
    continueKdeFlowAuthLoginKdePostBody,
    options,
  )
}

export const getContinueKdeFlowAuthLoginKdePostMutationOptions = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
    TError,
    { data: ContinueKdeFlowAuthLoginKdePostBody },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
  TError,
  { data: ContinueKdeFlowAuthLoginKdePostBody },
  TContext
> => {
  const mutationKey = ["continueKdeFlowAuthLoginKdePost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
    { data: ContinueKdeFlowAuthLoginKdePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueKdeFlowAuthLoginKdePost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueKdeFlowAuthLoginKdePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>
>
export type ContinueKdeFlowAuthLoginKdePostMutationBody =
  ContinueKdeFlowAuthLoginKdePostBody
export type ContinueKdeFlowAuthLoginKdePostMutationError =
  AxiosError<void | HTTPValidationError | void>

/**
 * @summary Continue Kde Flow
 */
export const useContinueKdeFlowAuthLoginKdePost = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
      TError,
      { data: ContinueKdeFlowAuthLoginKdePostBody },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
  TError,
  { data: ContinueKdeFlowAuthLoginKdePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueKdeFlowAuthLoginKdePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Process the result of the Google oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the google oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from google",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Google Flow
 */
export const continueGoogleFlowAuthLoginGooglePost = (
  continueGoogleFlowAuthLoginGooglePostBody: ContinueGoogleFlowAuthLoginGooglePostBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/google`,
    continueGoogleFlowAuthLoginGooglePostBody,
    options,
  )
}

export const getContinueGoogleFlowAuthLoginGooglePostMutationOptions = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
    TError,
    { data: ContinueGoogleFlowAuthLoginGooglePostBody },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
  TError,
  { data: ContinueGoogleFlowAuthLoginGooglePostBody },
  TContext
> => {
  const mutationKey = ["continueGoogleFlowAuthLoginGooglePost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
    { data: ContinueGoogleFlowAuthLoginGooglePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGoogleFlowAuthLoginGooglePost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGoogleFlowAuthLoginGooglePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>
>
export type ContinueGoogleFlowAuthLoginGooglePostMutationBody =
  ContinueGoogleFlowAuthLoginGooglePostBody
export type ContinueGoogleFlowAuthLoginGooglePostMutationError =
  AxiosError<void | HTTPValidationError | void>

/**
 * @summary Continue Google Flow
 */
export const useContinueGoogleFlowAuthLoginGooglePost = <
  TError = AxiosError<void | HTTPValidationError | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
      TError,
      { data: ContinueGoogleFlowAuthLoginGooglePostBody },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
  TError,
  { data: ContinueGoogleFlowAuthLoginGooglePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGoogleFlowAuthLoginGooglePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Retrieve the current login's user information.  If the user is not logged in
you will get a `204` return.  Otherwise you will receive JSON describing the
currently logged in user, for example:

```
{
    "displayname": "Mx Human Person",
    "dev_flatpaks": [ "org.people.human.Appname" ],
    "owned_flatpaks": [ "org.foo.bar.Appname" ],
    "accepted_publisher-agreement_at": "2023-06-23T20:38:28.553028"
}
```

If the user has an active github login, you'll also get their github login
name, and avatar.  If they have some other login, details for that login
will be provided.

dev_flatpaks is filtered against IDs available in AppStream
 * @summary Get Userinfo
 */
export const getUserinfoAuthUserinfoGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetUserinfoAuthUserinfoGet200 | void>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/userinfo`,
    options,
  )
}

export const getGetUserinfoAuthUserinfoGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/userinfo`] as const
}

export const getGetUserinfoAuthUserinfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetUserinfoAuthUserinfoGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
  > = ({ signal }) => getUserinfoAuthUserinfoGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserinfoAuthUserinfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
>
export type GetUserinfoAuthUserinfoGetQueryError = AxiosError<unknown>

export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Userinfo
 */

export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserinfoAuthUserinfoGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Do Refresh Dev Flatpaks
 */
export const doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RefreshDevFlatpaksReturn>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/refresh-dev-flatpaks`,
    undefined,
    options,
  )
}

export const getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationOptions =
  <TError = AxiosError<void>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      TError,
      void,
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>,
    TError,
    void,
    TContext
  > => {
    const mutationKey = ["doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost"]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      void
    > = () => {
      return doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(axiosOptions)
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>
  >

export type DoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationError =
  AxiosError<void>

/**
 * @summary Do Refresh Dev Flatpaks
 */
export const useDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPost = <
  TError = AxiosError<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      TError,
      void,
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Clear the login state. This will discard tokens which access socials,
and will clear the session cookie so that the user is not logged in.
 * @summary Do Logout
 */
export const doLogoutAuthLogoutPost = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/logout`,
    undefined,
    options,
  )
}

export const getDoLogoutAuthLogoutPostMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["doLogoutAuthLogoutPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
    void
  > = () => {
    return doLogoutAuthLogoutPost(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DoLogoutAuthLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>
>

export type DoLogoutAuthLogoutPostMutationError = AxiosError<void>

/**
 * @summary Do Logout
 */
export const useDoLogoutAuthLogoutPost = <
  TError = AxiosError<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
      TError,
      void,
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getDoLogoutAuthLogoutPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a user's login information.
If they're not logged in, they'll get a `403` return.
Otherwise they will get an option to delete their account
and data.
 * @summary Get Deleteuser
 */
export const getDeleteuserAuthDeleteuserGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetDeleteUserResult>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`,
    options,
  )
}

export const getGetDeleteuserAuthDeleteuserGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`] as const
}

export const getGetDeleteuserAuthDeleteuserGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetDeleteuserAuthDeleteuserGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
  > = ({ signal }) =>
    getDeleteuserAuthDeleteuserGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDeleteuserAuthDeleteuserGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
>
export type GetDeleteuserAuthDeleteuserGetQueryError = AxiosError<void>

export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
          TError,
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
          TError,
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Deleteuser
 */

export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetDeleteuserAuthDeleteuserGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Clear the login state. This will then delete the user's account
and associated data. Unless there is an error.

The input to this should be of the form:

```json
{
    "token": "...",
}
```
 * @summary Do Deleteuser
 */
export const doDeleteuserAuthDeleteuserPost = (
  userDeleteRequest: UserDeleteRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<DeleteUserResult>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`,
    userDeleteRequest,
    options,
  )
}

export const getDoDeleteuserAuthDeleteuserPostMutationOptions = <
  TError = AxiosError<void | void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
    TError,
    { data: UserDeleteRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
  TError,
  { data: UserDeleteRequest },
  TContext
> => {
  const mutationKey = ["doDeleteuserAuthDeleteuserPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
    { data: UserDeleteRequest }
  > = (props) => {
    const { data } = props ?? {}

    return doDeleteuserAuthDeleteuserPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DoDeleteuserAuthDeleteuserPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>
>
export type DoDeleteuserAuthDeleteuserPostMutationBody = UserDeleteRequest
export type DoDeleteuserAuthDeleteuserPostMutationError =
  AxiosError<void | void | HTTPValidationError>

/**
 * @summary Do Deleteuser
 */
export const useDoDeleteuserAuthDeleteuserPost = <
  TError = AxiosError<void | void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
      TError,
      { data: UserDeleteRequest },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
  TError,
  { data: UserDeleteRequest },
  TContext
> => {
  const mutationOptions =
    getDoDeleteuserAuthDeleteuserPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Do Agree To Publisher Agreement
 */
export const doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/accept-publisher-agreement`,
    undefined,
    options,
  )
}

export const getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationOptions =
  <TError = AxiosError<void>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      TError,
      void,
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
      >
    >,
    TError,
    void,
    TContext
  > => {
    const mutationKey = [
      "doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost",
    ]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      void
    > = () => {
      return doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
      >
    >
  >

export type DoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationError =
  AxiosError<void>

/**
 * @summary Do Agree To Publisher Agreement
 */
export const useDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost = <
  TError = AxiosError<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      TError,
      void,
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<
      typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
    >
  >,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions, queryClient)
}
/**
 * Changes the user's default account, which determines which display name and email we use.
 * @summary Do Change Default Account
 */
export const doChangeDefaultAccountAuthChangeDefaultAccountPost = (
  params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/change-default-account`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getDoChangeDefaultAccountAuthChangeDefaultAccountPostMutationOptions =
  <
    TError = AxiosError<void | void | HTTPValidationError>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      TError,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
    >,
    TError,
    { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
    TContext
  > => {
    const mutationKey = ["doChangeDefaultAccountAuthChangeDefaultAccountPost"]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams }
    > = (props) => {
      const { params } = props ?? {}

      return doChangeDefaultAccountAuthChangeDefaultAccountPost(
        params,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoChangeDefaultAccountAuthChangeDefaultAccountPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
    >
  >

export type DoChangeDefaultAccountAuthChangeDefaultAccountPostMutationError =
  AxiosError<void | void | HTTPValidationError>

/**
 * @summary Do Change Default Account
 */
export const useDoChangeDefaultAccountAuthChangeDefaultAccountPost = <
  TError = AxiosError<void | void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      TError,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
  >,
  TError,
  { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
  TContext
> => {
  const mutationOptions =
    getDoChangeDefaultAccountAuthChangeDefaultAccountPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions, queryClient)
}
