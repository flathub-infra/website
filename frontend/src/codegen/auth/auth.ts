/**
 * Generated by orval 🍺
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  ContinueGithubFlowAuthLoginGithubPostBody,
  ContinueGitlabFlowAuthLoginGitlabPostBody,
  ContinueGnomeFlowAuthLoginGnomePostBody,
  ContinueGoogleFlowAuthLoginGooglePostBody,
  ContinueKdeFlowAuthLoginKdePostBody,
  DeleteUserResult,
  DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,
  GetDeleteUserResult,
  HTTPValidationError,
  LoginMethod,
  RefreshDevFlatpaksReturn,
  UserDeleteRequest,
  UserInfo,
} from ".././model"

/**
 * Retrieve the login methods available from the backend.

For each method returned, flow starts with a `GET` to the endpoint
`.../login/{method}` and upon completion from the user-agent, with a `POST`
to that same endpoint name.

Each method is also given a button icon and some text to use, though
frontends with localisation may choose to render other text instead.
 * @summary Get Login Methods
 */
export type getLoginMethodsAuthLoginGetResponse200 = {
  data: LoginMethod[]
  status: 200
}

export type getLoginMethodsAuthLoginGetResponseComposite =
  getLoginMethodsAuthLoginGetResponse200

export type getLoginMethodsAuthLoginGetResponse =
  getLoginMethodsAuthLoginGetResponseComposite & {
    headers: Headers
  }

export const getGetLoginMethodsAuthLoginGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login`
}

export const getLoginMethodsAuthLoginGet = async (
  options?: RequestInit,
): Promise<getLoginMethodsAuthLoginGetResponse> => {
  const res = await fetch(getGetLoginMethodsAuthLoginGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getLoginMethodsAuthLoginGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getLoginMethodsAuthLoginGetResponse
}

export const getGetLoginMethodsAuthLoginGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login`] as const
}

export const getGetLoginMethodsAuthLoginGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetLoginMethodsAuthLoginGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
  > = ({ signal }) => getLoginMethodsAuthLoginGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLoginMethodsAuthLoginGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
>
export type GetLoginMethodsAuthLoginGetQueryError = unknown

export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
          TError,
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
          TError,
          Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Login Methods
 */

export function useGetLoginMethodsAuthLoginGet<
  TData = Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLoginMethodsAuthLoginGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetLoginMethodsAuthLoginGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Starts a github login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Github

Upon return from Github to the frontend, the frontend should POST to this
endpoint with the relevant data from Github

If the user is already logged in, and has a valid github token stored,
then this will return an error instead.
 * @summary Start Github Flow
 */
export type startGithubFlowAuthLoginGithubGetResponse200 = {
  data: unknown
  status: 200
}

export type startGithubFlowAuthLoginGithubGetResponse400 = {
  data: null
  status: 400
}

export type startGithubFlowAuthLoginGithubGetResponseComposite =
  | startGithubFlowAuthLoginGithubGetResponse200
  | startGithubFlowAuthLoginGithubGetResponse400

export type startGithubFlowAuthLoginGithubGetResponse =
  startGithubFlowAuthLoginGithubGetResponseComposite & {
    headers: Headers
  }

export const getStartGithubFlowAuthLoginGithubGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`
}

export const startGithubFlowAuthLoginGithubGet = async (
  options?: RequestInit,
): Promise<startGithubFlowAuthLoginGithubGetResponse> => {
  const res = await fetch(getStartGithubFlowAuthLoginGithubGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: startGithubFlowAuthLoginGithubGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as startGithubFlowAuthLoginGithubGetResponse
}

export const getStartGithubFlowAuthLoginGithubGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`] as const
}

export const getStartGithubFlowAuthLoginGithubGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGithubFlowAuthLoginGithubGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
  > = ({ signal }) =>
    startGithubFlowAuthLoginGithubGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGithubFlowAuthLoginGithubGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
>
export type StartGithubFlowAuthLoginGithubGetQueryError = null

export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
          TError,
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
          TError,
          Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Github Flow
 */

export function useStartGithubFlowAuthLoginGithubGet<
  TData = Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGithubFlowAuthLoginGithubGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGithubFlowAuthLoginGithubGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the Github oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the github oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from github",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Github Flow
 */
export type continueGithubFlowAuthLoginGithubPostResponse200 = {
  data: unknown
  status: 200
}

export type continueGithubFlowAuthLoginGithubPostResponse400 = {
  data: null
  status: 400
}

export type continueGithubFlowAuthLoginGithubPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGithubFlowAuthLoginGithubPostResponse500 = {
  data: null
  status: 500
}

export type continueGithubFlowAuthLoginGithubPostResponseComposite =
  | continueGithubFlowAuthLoginGithubPostResponse200
  | continueGithubFlowAuthLoginGithubPostResponse400
  | continueGithubFlowAuthLoginGithubPostResponse422
  | continueGithubFlowAuthLoginGithubPostResponse500

export type continueGithubFlowAuthLoginGithubPostResponse =
  continueGithubFlowAuthLoginGithubPostResponseComposite & {
    headers: Headers
  }

export const getContinueGithubFlowAuthLoginGithubPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/github`
}

export const continueGithubFlowAuthLoginGithubPost = async (
  continueGithubFlowAuthLoginGithubPostBody: ContinueGithubFlowAuthLoginGithubPostBody,
  options?: RequestInit,
): Promise<continueGithubFlowAuthLoginGithubPostResponse> => {
  const res = await fetch(getContinueGithubFlowAuthLoginGithubPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(continueGithubFlowAuthLoginGithubPostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: continueGithubFlowAuthLoginGithubPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as continueGithubFlowAuthLoginGithubPostResponse
}

export const getContinueGithubFlowAuthLoginGithubPostMutationOptions = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
    TError,
    { data: ContinueGithubFlowAuthLoginGithubPostBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
  TError,
  { data: ContinueGithubFlowAuthLoginGithubPostBody },
  TContext
> => {
  const mutationKey = ["continueGithubFlowAuthLoginGithubPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
    { data: ContinueGithubFlowAuthLoginGithubPostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGithubFlowAuthLoginGithubPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGithubFlowAuthLoginGithubPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>
>
export type ContinueGithubFlowAuthLoginGithubPostMutationBody =
  ContinueGithubFlowAuthLoginGithubPostBody
export type ContinueGithubFlowAuthLoginGithubPostMutationError =
  null | HTTPValidationError | null

/**
 * @summary Continue Github Flow
 */
export const useContinueGithubFlowAuthLoginGithubPost = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
      TError,
      { data: ContinueGithubFlowAuthLoginGithubPostBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGithubFlowAuthLoginGithubPost>>,
  TError,
  { data: ContinueGithubFlowAuthLoginGithubPostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGithubFlowAuthLoginGithubPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Starts a gitlab login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Gitlab

Upon return from Gitlab to the frontend, the frontend should POST to this
endpoint with the relevant data from Gitlab

If the user is already logged in, and has a valid gitlab token stored,
then this will return an error instead.
 * @summary Start Gitlab Flow
 */
export type startGitlabFlowAuthLoginGitlabGetResponse200 = {
  data: unknown
  status: 200
}

export type startGitlabFlowAuthLoginGitlabGetResponse400 = {
  data: null
  status: 400
}

export type startGitlabFlowAuthLoginGitlabGetResponseComposite =
  | startGitlabFlowAuthLoginGitlabGetResponse200
  | startGitlabFlowAuthLoginGitlabGetResponse400

export type startGitlabFlowAuthLoginGitlabGetResponse =
  startGitlabFlowAuthLoginGitlabGetResponseComposite & {
    headers: Headers
  }

export const getStartGitlabFlowAuthLoginGitlabGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`
}

export const startGitlabFlowAuthLoginGitlabGet = async (
  options?: RequestInit,
): Promise<startGitlabFlowAuthLoginGitlabGetResponse> => {
  const res = await fetch(getStartGitlabFlowAuthLoginGitlabGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: startGitlabFlowAuthLoginGitlabGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as startGitlabFlowAuthLoginGitlabGetResponse
}

export const getStartGitlabFlowAuthLoginGitlabGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`] as const
}

export const getStartGitlabFlowAuthLoginGitlabGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGitlabFlowAuthLoginGitlabGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
  > = ({ signal }) =>
    startGitlabFlowAuthLoginGitlabGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGitlabFlowAuthLoginGitlabGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
>
export type StartGitlabFlowAuthLoginGitlabGetQueryError = null

export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
          TError,
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
          TError,
          Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Gitlab Flow
 */

export function useStartGitlabFlowAuthLoginGitlabGet<
  TData = Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGitlabFlowAuthLoginGitlabGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGitlabFlowAuthLoginGitlabGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the Gitlab oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gitlab Flow
 */
export type continueGitlabFlowAuthLoginGitlabPostResponse200 = {
  data: unknown
  status: 200
}

export type continueGitlabFlowAuthLoginGitlabPostResponse400 = {
  data: null
  status: 400
}

export type continueGitlabFlowAuthLoginGitlabPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGitlabFlowAuthLoginGitlabPostResponse500 = {
  data: null
  status: 500
}

export type continueGitlabFlowAuthLoginGitlabPostResponseComposite =
  | continueGitlabFlowAuthLoginGitlabPostResponse200
  | continueGitlabFlowAuthLoginGitlabPostResponse400
  | continueGitlabFlowAuthLoginGitlabPostResponse422
  | continueGitlabFlowAuthLoginGitlabPostResponse500

export type continueGitlabFlowAuthLoginGitlabPostResponse =
  continueGitlabFlowAuthLoginGitlabPostResponseComposite & {
    headers: Headers
  }

export const getContinueGitlabFlowAuthLoginGitlabPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gitlab`
}

export const continueGitlabFlowAuthLoginGitlabPost = async (
  continueGitlabFlowAuthLoginGitlabPostBody: ContinueGitlabFlowAuthLoginGitlabPostBody,
  options?: RequestInit,
): Promise<continueGitlabFlowAuthLoginGitlabPostResponse> => {
  const res = await fetch(getContinueGitlabFlowAuthLoginGitlabPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(continueGitlabFlowAuthLoginGitlabPostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: continueGitlabFlowAuthLoginGitlabPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as continueGitlabFlowAuthLoginGitlabPostResponse
}

export const getContinueGitlabFlowAuthLoginGitlabPostMutationOptions = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
    TError,
    { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
  TError,
  { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
  TContext
> => {
  const mutationKey = ["continueGitlabFlowAuthLoginGitlabPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
    { data: ContinueGitlabFlowAuthLoginGitlabPostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGitlabFlowAuthLoginGitlabPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGitlabFlowAuthLoginGitlabPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>
>
export type ContinueGitlabFlowAuthLoginGitlabPostMutationBody =
  ContinueGitlabFlowAuthLoginGitlabPostBody
export type ContinueGitlabFlowAuthLoginGitlabPostMutationError =
  null | HTTPValidationError | null

/**
 * @summary Continue Gitlab Flow
 */
export const useContinueGitlabFlowAuthLoginGitlabPost = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
      TError,
      { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGitlabFlowAuthLoginGitlabPost>>,
  TError,
  { data: ContinueGitlabFlowAuthLoginGitlabPostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGitlabFlowAuthLoginGitlabPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Starts a GNOME login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to GNOME Gitlab

Upon return from GNOME to the frontend, the frontend should POST to this
endpoint with the relevant data from GNOME Gitlab

If the user is already logged in, and has a valid GNOME Gitlab token stored,
then this will return an error instead.
 * @summary Start Gnome Flow
 */
export type startGnomeFlowAuthLoginGnomeGetResponse200 = {
  data: unknown
  status: 200
}

export type startGnomeFlowAuthLoginGnomeGetResponse400 = {
  data: null
  status: 400
}

export type startGnomeFlowAuthLoginGnomeGetResponseComposite =
  | startGnomeFlowAuthLoginGnomeGetResponse200
  | startGnomeFlowAuthLoginGnomeGetResponse400

export type startGnomeFlowAuthLoginGnomeGetResponse =
  startGnomeFlowAuthLoginGnomeGetResponseComposite & {
    headers: Headers
  }

export const getStartGnomeFlowAuthLoginGnomeGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`
}

export const startGnomeFlowAuthLoginGnomeGet = async (
  options?: RequestInit,
): Promise<startGnomeFlowAuthLoginGnomeGetResponse> => {
  const res = await fetch(getStartGnomeFlowAuthLoginGnomeGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: startGnomeFlowAuthLoginGnomeGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as startGnomeFlowAuthLoginGnomeGetResponse
}

export const getStartGnomeFlowAuthLoginGnomeGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`] as const
}

export const getStartGnomeFlowAuthLoginGnomeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartGnomeFlowAuthLoginGnomeGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
  > = ({ signal }) =>
    startGnomeFlowAuthLoginGnomeGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartGnomeFlowAuthLoginGnomeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
>
export type StartGnomeFlowAuthLoginGnomeGetQueryError = null

export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
          TError,
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
          TError,
          Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Gnome Flow
 */

export function useStartGnomeFlowAuthLoginGnomeGet<
  TData = Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startGnomeFlowAuthLoginGnomeGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartGnomeFlowAuthLoginGnomeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Process the result of the GNOME oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from GNOME gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gnome Flow
 */
export type continueGnomeFlowAuthLoginGnomePostResponse200 = {
  data: unknown
  status: 200
}

export type continueGnomeFlowAuthLoginGnomePostResponse400 = {
  data: null
  status: 400
}

export type continueGnomeFlowAuthLoginGnomePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGnomeFlowAuthLoginGnomePostResponse500 = {
  data: null
  status: 500
}

export type continueGnomeFlowAuthLoginGnomePostResponseComposite =
  | continueGnomeFlowAuthLoginGnomePostResponse200
  | continueGnomeFlowAuthLoginGnomePostResponse400
  | continueGnomeFlowAuthLoginGnomePostResponse422
  | continueGnomeFlowAuthLoginGnomePostResponse500

export type continueGnomeFlowAuthLoginGnomePostResponse =
  continueGnomeFlowAuthLoginGnomePostResponseComposite & {
    headers: Headers
  }

export const getContinueGnomeFlowAuthLoginGnomePostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/gnome`
}

export const continueGnomeFlowAuthLoginGnomePost = async (
  continueGnomeFlowAuthLoginGnomePostBody: ContinueGnomeFlowAuthLoginGnomePostBody,
  options?: RequestInit,
): Promise<continueGnomeFlowAuthLoginGnomePostResponse> => {
  const res = await fetch(getContinueGnomeFlowAuthLoginGnomePostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(continueGnomeFlowAuthLoginGnomePostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: continueGnomeFlowAuthLoginGnomePostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as continueGnomeFlowAuthLoginGnomePostResponse
}

export const getContinueGnomeFlowAuthLoginGnomePostMutationOptions = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
    TError,
    { data: ContinueGnomeFlowAuthLoginGnomePostBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
  TError,
  { data: ContinueGnomeFlowAuthLoginGnomePostBody },
  TContext
> => {
  const mutationKey = ["continueGnomeFlowAuthLoginGnomePost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
    { data: ContinueGnomeFlowAuthLoginGnomePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGnomeFlowAuthLoginGnomePost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGnomeFlowAuthLoginGnomePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>
>
export type ContinueGnomeFlowAuthLoginGnomePostMutationBody =
  ContinueGnomeFlowAuthLoginGnomePostBody
export type ContinueGnomeFlowAuthLoginGnomePostMutationError =
  null | HTTPValidationError | null

/**
 * @summary Continue Gnome Flow
 */
export const useContinueGnomeFlowAuthLoginGnomePost = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
      TError,
      { data: ContinueGnomeFlowAuthLoginGnomePostBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGnomeFlowAuthLoginGnomePost>>,
  TError,
  { data: ContinueGnomeFlowAuthLoginGnomePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGnomeFlowAuthLoginGnomePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Start Kde Flow
 */
export type startKdeFlowAuthLoginKdeGetResponse200 = {
  data: unknown
  status: 200
}

export type startKdeFlowAuthLoginKdeGetResponse400 = {
  data: null
  status: 400
}

export type startKdeFlowAuthLoginKdeGetResponseComposite =
  | startKdeFlowAuthLoginKdeGetResponse200
  | startKdeFlowAuthLoginKdeGetResponse400

export type startKdeFlowAuthLoginKdeGetResponse =
  startKdeFlowAuthLoginKdeGetResponseComposite & {
    headers: Headers
  }

export const getStartKdeFlowAuthLoginKdeGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`
}

export const startKdeFlowAuthLoginKdeGet = async (
  options?: RequestInit,
): Promise<startKdeFlowAuthLoginKdeGetResponse> => {
  const res = await fetch(getStartKdeFlowAuthLoginKdeGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: startKdeFlowAuthLoginKdeGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as startKdeFlowAuthLoginKdeGetResponse
}

export const getStartKdeFlowAuthLoginKdeGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`] as const
}

export const getStartKdeFlowAuthLoginKdeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getStartKdeFlowAuthLoginKdeGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
  > = ({ signal }) => startKdeFlowAuthLoginKdeGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StartKdeFlowAuthLoginKdeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
>
export type StartKdeFlowAuthLoginKdeGetQueryError = null

export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
          TError,
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
          TError,
          Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Start Kde Flow
 */

export function useStartKdeFlowAuthLoginKdeGet<
  TData = Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startKdeFlowAuthLoginKdeGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStartKdeFlowAuthLoginKdeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Continue Kde Flow
 */
export type continueKdeFlowAuthLoginKdePostResponse200 = {
  data: unknown
  status: 200
}

export type continueKdeFlowAuthLoginKdePostResponse400 = {
  data: null
  status: 400
}

export type continueKdeFlowAuthLoginKdePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueKdeFlowAuthLoginKdePostResponse500 = {
  data: null
  status: 500
}

export type continueKdeFlowAuthLoginKdePostResponseComposite =
  | continueKdeFlowAuthLoginKdePostResponse200
  | continueKdeFlowAuthLoginKdePostResponse400
  | continueKdeFlowAuthLoginKdePostResponse422
  | continueKdeFlowAuthLoginKdePostResponse500

export type continueKdeFlowAuthLoginKdePostResponse =
  continueKdeFlowAuthLoginKdePostResponseComposite & {
    headers: Headers
  }

export const getContinueKdeFlowAuthLoginKdePostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/kde`
}

export const continueKdeFlowAuthLoginKdePost = async (
  continueKdeFlowAuthLoginKdePostBody: ContinueKdeFlowAuthLoginKdePostBody,
  options?: RequestInit,
): Promise<continueKdeFlowAuthLoginKdePostResponse> => {
  const res = await fetch(getContinueKdeFlowAuthLoginKdePostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(continueKdeFlowAuthLoginKdePostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: continueKdeFlowAuthLoginKdePostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as continueKdeFlowAuthLoginKdePostResponse
}

export const getContinueKdeFlowAuthLoginKdePostMutationOptions = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
    TError,
    { data: ContinueKdeFlowAuthLoginKdePostBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
  TError,
  { data: ContinueKdeFlowAuthLoginKdePostBody },
  TContext
> => {
  const mutationKey = ["continueKdeFlowAuthLoginKdePost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
    { data: ContinueKdeFlowAuthLoginKdePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueKdeFlowAuthLoginKdePost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueKdeFlowAuthLoginKdePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>
>
export type ContinueKdeFlowAuthLoginKdePostMutationBody =
  ContinueKdeFlowAuthLoginKdePostBody
export type ContinueKdeFlowAuthLoginKdePostMutationError =
  null | HTTPValidationError | null

/**
 * @summary Continue Kde Flow
 */
export const useContinueKdeFlowAuthLoginKdePost = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
      TError,
      { data: ContinueKdeFlowAuthLoginKdePostBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueKdeFlowAuthLoginKdePost>>,
  TError,
  { data: ContinueKdeFlowAuthLoginKdePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueKdeFlowAuthLoginKdePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Process the result of the Google oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the google oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from google",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Google Flow
 */
export type continueGoogleFlowAuthLoginGooglePostResponse200 = {
  data: unknown
  status: 200
}

export type continueGoogleFlowAuthLoginGooglePostResponse400 = {
  data: null
  status: 400
}

export type continueGoogleFlowAuthLoginGooglePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGoogleFlowAuthLoginGooglePostResponse500 = {
  data: null
  status: 500
}

export type continueGoogleFlowAuthLoginGooglePostResponseComposite =
  | continueGoogleFlowAuthLoginGooglePostResponse200
  | continueGoogleFlowAuthLoginGooglePostResponse400
  | continueGoogleFlowAuthLoginGooglePostResponse422
  | continueGoogleFlowAuthLoginGooglePostResponse500

export type continueGoogleFlowAuthLoginGooglePostResponse =
  continueGoogleFlowAuthLoginGooglePostResponseComposite & {
    headers: Headers
  }

export const getContinueGoogleFlowAuthLoginGooglePostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/login/google`
}

export const continueGoogleFlowAuthLoginGooglePost = async (
  continueGoogleFlowAuthLoginGooglePostBody: ContinueGoogleFlowAuthLoginGooglePostBody,
  options?: RequestInit,
): Promise<continueGoogleFlowAuthLoginGooglePostResponse> => {
  const res = await fetch(getContinueGoogleFlowAuthLoginGooglePostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(continueGoogleFlowAuthLoginGooglePostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: continueGoogleFlowAuthLoginGooglePostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as continueGoogleFlowAuthLoginGooglePostResponse
}

export const getContinueGoogleFlowAuthLoginGooglePostMutationOptions = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
    TError,
    { data: ContinueGoogleFlowAuthLoginGooglePostBody },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
  TError,
  { data: ContinueGoogleFlowAuthLoginGooglePostBody },
  TContext
> => {
  const mutationKey = ["continueGoogleFlowAuthLoginGooglePost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
    { data: ContinueGoogleFlowAuthLoginGooglePostBody }
  > = (props) => {
    const { data } = props ?? {}

    return continueGoogleFlowAuthLoginGooglePost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ContinueGoogleFlowAuthLoginGooglePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>
>
export type ContinueGoogleFlowAuthLoginGooglePostMutationBody =
  ContinueGoogleFlowAuthLoginGooglePostBody
export type ContinueGoogleFlowAuthLoginGooglePostMutationError =
  null | HTTPValidationError | null

/**
 * @summary Continue Google Flow
 */
export const useContinueGoogleFlowAuthLoginGooglePost = <
  TError = null | HTTPValidationError | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
      TError,
      { data: ContinueGoogleFlowAuthLoginGooglePostBody },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof continueGoogleFlowAuthLoginGooglePost>>,
  TError,
  { data: ContinueGoogleFlowAuthLoginGooglePostBody },
  TContext
> => {
  const mutationOptions =
    getContinueGoogleFlowAuthLoginGooglePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Retrieve the current login's user information.  If the user is not logged in
you will get a `204` return.  Otherwise you will receive JSON describing the
currently logged in user, for example:

```
{
    "displayname": "Mx Human Person",
    "dev_flatpaks": [ "org.people.human.Appname" ],
    "owned_flatpaks": [ "org.foo.bar.Appname" ],
    "accepted_publisher-agreement_at": "2023-06-23T20:38:28.553028"
}
```

If the user has an active github login, you'll also get their github login
name, and avatar.  If they have some other login, details for that login
will be provided.

dev_flatpaks is filtered against IDs available in AppStream
 * @summary Get Userinfo
 */
export type getUserinfoAuthUserinfoGetResponse200 = {
  data: UserInfo
  status: 200
}

export type getUserinfoAuthUserinfoGetResponse204 = {
  data: null
  status: 204
}

export type getUserinfoAuthUserinfoGetResponseComposite =
  | getUserinfoAuthUserinfoGetResponse200
  | getUserinfoAuthUserinfoGetResponse204

export type getUserinfoAuthUserinfoGetResponse =
  getUserinfoAuthUserinfoGetResponseComposite & {
    headers: Headers
  }

export const getGetUserinfoAuthUserinfoGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/userinfo`
}

export const getUserinfoAuthUserinfoGet = async (
  options?: RequestInit,
): Promise<getUserinfoAuthUserinfoGetResponse> => {
  const res = await fetch(getGetUserinfoAuthUserinfoGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUserinfoAuthUserinfoGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getUserinfoAuthUserinfoGetResponse
}

export const getGetUserinfoAuthUserinfoGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/userinfo`] as const
}

export const getGetUserinfoAuthUserinfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetUserinfoAuthUserinfoGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
  > = ({ signal }) => getUserinfoAuthUserinfoGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserinfoAuthUserinfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
>
export type GetUserinfoAuthUserinfoGetQueryError = unknown

export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
          TError,
          Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Userinfo
 */

export function useGetUserinfoAuthUserinfoGet<
  TData = Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserinfoAuthUserinfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserinfoAuthUserinfoGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Do Refresh Dev Flatpaks
 */
export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse200 = {
  data: RefreshDevFlatpaksReturn
  status: 200
}

export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse401 = {
  data: null
  status: 401
}

export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseComposite =
  | doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse200
  | doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse401

export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse =
  doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseComposite & {
    headers: Headers
  }

export const getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/refresh-dev-flatpaks`
}

export const doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost = async (
  options?: RequestInit,
): Promise<doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse> => {
  const res = await fetch(
    getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostUrl(),
    {
      ...options,
      method: "POST",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse
}

export const getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationOptions =
  <TError = null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>,
    TError,
    void,
    TContext
  > => {
    const mutationKey = ["doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost"]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      void
    > = () => {
      return doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(fetchOptions)
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>
  >

export type DoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationError = null

/**
 * @summary Do Refresh Dev Flatpaks
 */
export const useDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPost = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>
      >,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Clear the login state. This will discard tokens which access socials,
and will clear the session cookie so that the user is not logged in.
 * @summary Do Logout
 */
export type doLogoutAuthLogoutPostResponse200 = {
  data: unknown
  status: 200
}

export type doLogoutAuthLogoutPostResponse500 = {
  data: null
  status: 500
}

export type doLogoutAuthLogoutPostResponseComposite =
  | doLogoutAuthLogoutPostResponse200
  | doLogoutAuthLogoutPostResponse500

export type doLogoutAuthLogoutPostResponse =
  doLogoutAuthLogoutPostResponseComposite & {
    headers: Headers
  }

export const getDoLogoutAuthLogoutPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/logout`
}

export const doLogoutAuthLogoutPost = async (
  options?: RequestInit,
): Promise<doLogoutAuthLogoutPostResponse> => {
  const res = await fetch(getDoLogoutAuthLogoutPostUrl(), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: doLogoutAuthLogoutPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as doLogoutAuthLogoutPostResponse
}

export const getDoLogoutAuthLogoutPostMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
    TError,
    void,
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["doLogoutAuthLogoutPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
    void
  > = () => {
    return doLogoutAuthLogoutPost(fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DoLogoutAuthLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>
>

export type DoLogoutAuthLogoutPostMutationError = null

/**
 * @summary Do Logout
 */
export const useDoLogoutAuthLogoutPost = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doLogoutAuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getDoLogoutAuthLogoutPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a user's login information.
If they're not logged in, they'll get a `403` return.
Otherwise they will get an option to delete their account
and data.
 * @summary Get Deleteuser
 */
export type getDeleteuserAuthDeleteuserGetResponse200 = {
  data: GetDeleteUserResult
  status: 200
}

export type getDeleteuserAuthDeleteuserGetResponse403 = {
  data: null
  status: 403
}

export type getDeleteuserAuthDeleteuserGetResponseComposite =
  | getDeleteuserAuthDeleteuserGetResponse200
  | getDeleteuserAuthDeleteuserGetResponse403

export type getDeleteuserAuthDeleteuserGetResponse =
  getDeleteuserAuthDeleteuserGetResponseComposite & {
    headers: Headers
  }

export const getGetDeleteuserAuthDeleteuserGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`
}

export const getDeleteuserAuthDeleteuserGet = async (
  options?: RequestInit,
): Promise<getDeleteuserAuthDeleteuserGetResponse> => {
  const res = await fetch(getGetDeleteuserAuthDeleteuserGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getDeleteuserAuthDeleteuserGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDeleteuserAuthDeleteuserGetResponse
}

export const getGetDeleteuserAuthDeleteuserGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`] as const
}

export const getGetDeleteuserAuthDeleteuserGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetDeleteuserAuthDeleteuserGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
  > = ({ signal }) =>
    getDeleteuserAuthDeleteuserGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDeleteuserAuthDeleteuserGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
>
export type GetDeleteuserAuthDeleteuserGetQueryError = null

export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
          TError,
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
          TError,
          Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Deleteuser
 */

export function useGetDeleteuserAuthDeleteuserGet<
  TData = Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeleteuserAuthDeleteuserGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetDeleteuserAuthDeleteuserGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Clear the login state. This will then delete the user's account
and associated data. Unless there is an error.

The input to this should be of the form:

```json
{
    "token": "...",
}
```
 * @summary Do Deleteuser
 */
export type doDeleteuserAuthDeleteuserPostResponse200 = {
  data: DeleteUserResult
  status: 200
}

export type doDeleteuserAuthDeleteuserPostResponse400 = {
  data: null
  status: 400
}

export type doDeleteuserAuthDeleteuserPostResponse403 = {
  data: null
  status: 403
}

export type doDeleteuserAuthDeleteuserPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type doDeleteuserAuthDeleteuserPostResponseComposite =
  | doDeleteuserAuthDeleteuserPostResponse200
  | doDeleteuserAuthDeleteuserPostResponse400
  | doDeleteuserAuthDeleteuserPostResponse403
  | doDeleteuserAuthDeleteuserPostResponse422

export type doDeleteuserAuthDeleteuserPostResponse =
  doDeleteuserAuthDeleteuserPostResponseComposite & {
    headers: Headers
  }

export const getDoDeleteuserAuthDeleteuserPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/deleteuser`
}

export const doDeleteuserAuthDeleteuserPost = async (
  userDeleteRequest: UserDeleteRequest,
  options?: RequestInit,
): Promise<doDeleteuserAuthDeleteuserPostResponse> => {
  const res = await fetch(getDoDeleteuserAuthDeleteuserPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userDeleteRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: doDeleteuserAuthDeleteuserPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as doDeleteuserAuthDeleteuserPostResponse
}

export const getDoDeleteuserAuthDeleteuserPostMutationOptions = <
  TError = null | null | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
    TError,
    { data: UserDeleteRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
  TError,
  { data: UserDeleteRequest },
  TContext
> => {
  const mutationKey = ["doDeleteuserAuthDeleteuserPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
    { data: UserDeleteRequest }
  > = (props) => {
    const { data } = props ?? {}

    return doDeleteuserAuthDeleteuserPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DoDeleteuserAuthDeleteuserPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>
>
export type DoDeleteuserAuthDeleteuserPostMutationBody = UserDeleteRequest
export type DoDeleteuserAuthDeleteuserPostMutationError =
  null | null | HTTPValidationError

/**
 * @summary Do Deleteuser
 */
export const useDoDeleteuserAuthDeleteuserPost = <
  TError = null | null | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
      TError,
      { data: UserDeleteRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof doDeleteuserAuthDeleteuserPost>>,
  TError,
  { data: UserDeleteRequest },
  TContext
> => {
  const mutationOptions =
    getDoDeleteuserAuthDeleteuserPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Do Agree To Publisher Agreement
 */
export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse200 =
  {
    data: unknown
    status: 200
  }

export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse403 =
  {
    data: null
    status: 403
  }

export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseComposite =

    | doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse200
    | doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse403

export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse =
  doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseComposite & {
    headers: Headers
  }

export const getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostUrl =
  () => {
    return `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/accept-publisher-agreement`
  }

export const doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost =
  async (
    options?: RequestInit,
  ): Promise<doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse> => {
    const res = await fetch(
      getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostUrl(),
      {
        ...options,
        method: "POST",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse
  }

export const getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationOptions =
  <TError = null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
      >
    >,
    TError,
    void,
    TContext
  > => {
    const mutationKey = [
      "doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost",
    ]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      void
    > = () => {
      return doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
      >
    >
  >

export type DoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationError =
  null

/**
 * @summary Do Agree To Publisher Agreement
 */
export const useDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
        >
      >,
      TError,
      void,
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<
      typeof doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost
    >
  >,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions, queryClient)
}
/**
 * Changes the user's default account, which determines which display name and email we use.
 * @summary Do Change Default Account
 */
export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse204 = {
  data: null
  status: 204
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse403 = {
  data: null
  status: 403
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse404 = {
  data: null
  status: 404
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponseComposite =

    | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse204
    | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse403
    | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse404
    | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse422

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse =
  doChangeDefaultAccountAuthChangeDefaultAccountPostResponseComposite & {
    headers: Headers
  }

export const getDoChangeDefaultAccountAuthChangeDefaultAccountPostUrl = (
  params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/change-default-account?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/auth/change-default-account`
}

export const doChangeDefaultAccountAuthChangeDefaultAccountPost = async (
  params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,
  options?: RequestInit,
): Promise<doChangeDefaultAccountAuthChangeDefaultAccountPostResponse> => {
  const res = await fetch(
    getDoChangeDefaultAccountAuthChangeDefaultAccountPostUrl(params),
    {
      ...options,
      method: "POST",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: doChangeDefaultAccountAuthChangeDefaultAccountPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as doChangeDefaultAccountAuthChangeDefaultAccountPostResponse
}

export const getDoChangeDefaultAccountAuthChangeDefaultAccountPostMutationOptions =
  <TError = null | null | HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      TError,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
    >,
    TError,
    { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
    TContext
  > => {
    const mutationKey = ["doChangeDefaultAccountAuthChangeDefaultAccountPost"]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams }
    > = (props) => {
      const { params } = props ?? {}

      return doChangeDefaultAccountAuthChangeDefaultAccountPost(
        params,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type DoChangeDefaultAccountAuthChangeDefaultAccountPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
    >
  >

export type DoChangeDefaultAccountAuthChangeDefaultAccountPostMutationError =
  null | null | HTTPValidationError

/**
 * @summary Do Change Default Account
 */
export const useDoChangeDefaultAccountAuthChangeDefaultAccountPost = <
  TError = null | null | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
      >,
      TError,
      { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof doChangeDefaultAccountAuthChangeDefaultAccountPost>
  >,
  TError,
  { params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams },
  TContext
> => {
  const mutationOptions =
    getDoChangeDefaultAccountAuthChangeDefaultAccountPostMutationOptions(
      options,
    )

  return useMutation(mutationOptions, queryClient)
}
