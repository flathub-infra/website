/* tslint:disable */
/* eslint-disable */
/**
 * Flathub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AvailableLoginMethodStatus = {
    Ready: 'ready',
    UserDoesNotExist: 'user_does_not_exist',
    UsernameDoesNotMatch: 'username_does_not_match',
    ProviderDeniedAccess: 'provider_denied_access',
    NotLoggedIn: 'not_logged_in',
    NotOrgMember: 'not_org_member',
    NotOrgAdmin: 'not_org_admin'
} as const;

export type AvailableLoginMethodStatus = typeof AvailableLoginMethodStatus[keyof typeof AvailableLoginMethodStatus];


/**
 * 
 * @export
 * @interface AvailableMethod
 */
export interface AvailableMethod {
    /**
     * 
     * @type {AvailableMethodType}
     * @memberof AvailableMethod
     */
    'method': AvailableMethodType;
    /**
     * 
     * @type {string}
     * @memberof AvailableMethod
     */
    'website': string | null;
    /**
     * 
     * @type {string}
     * @memberof AvailableMethod
     */
    'website_token': string | null;
    /**
     * 
     * @type {LoginProvider}
     * @memberof AvailableMethod
     */
    'login_provider': LoginProvider | null;
    /**
     * 
     * @type {string}
     * @memberof AvailableMethod
     */
    'login_name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AvailableMethod
     */
    'login_is_organization': boolean | null;
    /**
     * 
     * @type {AvailableLoginMethodStatus}
     * @memberof AvailableMethod
     */
    'login_status': AvailableLoginMethodStatus | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AvailableMethodType = {
    Website: 'website',
    LoginProvider: 'login_provider'
} as const;

export type AvailableMethodType = typeof AvailableMethodType[keyof typeof AvailableMethodType];


/**
 * 
 * @export
 * @interface AvailableMethods
 */
export interface AvailableMethods {
    /**
     * 
     * @type {}
     * @memberof AvailableMethods
     */
    'methods':  | null;
    /**
     * 
     * @type {string}
     * @memberof AvailableMethods
     */
    'detail': string | null;
}
/**
 * 
 * @export
 * @interface BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost
 */
export interface BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost {
    /**
     * 
     * @type {Array<string>}
     * @memberof BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost
     */
    'appids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost
     */
    'update_token'?: string;
}
/**
 * 
 * @export
 * @interface BuildNotificationRequest
 */
export interface BuildNotificationRequest {
    /**
     * 
     * @type {string}
     * @memberof BuildNotificationRequest
     */
    'app_id': string;
    /**
     * 
     * @type {number}
     * @memberof BuildNotificationRequest
     */
    'build_id': number;
    /**
     * 
     * @type {string}
     * @memberof BuildNotificationRequest
     */
    'build_repo': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BuildNotificationRequest
     */
    'diagnostics': Array<string>;
}
/**
 * 
 * @export
 * @interface CardInfo
 */
export interface CardInfo {
    /**
     * 
     * @type {string}
     * @memberof CardInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CardInfo
     */
    'brand': string;
    /**
     * 
     * @type {string}
     * @memberof CardInfo
     */
    'country': string;
    /**
     * 
     * @type {number}
     * @memberof CardInfo
     */
    'exp_month': number;
    /**
     * 
     * @type {number}
     * @memberof CardInfo
     */
    'exp_year': number;
    /**
     * 
     * @type {string}
     * @memberof CardInfo
     */
    'last4': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectedAccountProvider = {
    Github: 'github',
    Gitlab: 'gitlab',
    Gnome: 'gnome',
    Google: 'google',
    Kde: 'kde'
} as const;

export type ConnectedAccountProvider = typeof ConnectedAccountProvider[keyof typeof ConnectedAccountProvider];


/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'error_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'error_uri'?: string | null;
}
/**
 * 
 * @export
 * @interface Developer
 */
export interface Developer {
    /**
     * 
     * @type {number}
     * @memberof Developer
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof Developer
     */
    'is_self': boolean;
    /**
     * 
     * @type {string}
     * @memberof Developer
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Developer
     */
    'is_primary': boolean | null;
}
/**
 * 
 * @export
 * @interface DevelopersResponse
 */
export interface DevelopersResponse {
    /**
     * 
     * @type {Array<Developer>}
     * @memberof DevelopersResponse
     */
    'developers': Array<Developer>;
    /**
     * 
     * @type {Array<Developer>}
     * @memberof DevelopersResponse
     */
    'invites': Array<Developer>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorDetail = {
    MalformedAppId: 'malformed_app_id',
    NotAppDeveloper: 'not_app_developer',
    InvalidMethod: 'invalid_method',
    FailedToConnect: 'failed_to_connect',
    ServerReturnedError: 'server_returned_error',
    AppNotListed: 'app_not_listed',
    BlockedByAdmins: 'blocked_by_admins',
    NotLoggedIn: 'not_logged_in',
    UsernameDoesNotMatch: 'username_does_not_match',
    UserDoesNotExist: 'user_does_not_exist',
    ProviderError: 'provider_error',
    ProviderDeniedAccess: 'provider_denied_access',
    NotOrgMember: 'not_org_member',
    NotOrgAdmin: 'not_org_admin',
    AppAlreadyVerified: 'app_already_verified',
    MustSetUpFirst: 'must_set_up_first',
    AppAlreadyExists: 'app_already_exists',
    MustAcceptPublisherAgreement: 'must_accept_publisher_agreement'
} as const;

export type ErrorDetail = typeof ErrorDetail[keyof typeof ErrorDetail];


/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'filterType': string;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InviteStatus
 */
export interface InviteStatus {
    /**
     * 
     * @type {boolean}
     * @memberof InviteStatus
     */
    'is_pending': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InviteStatus
     */
    'is_direct_upload_app': boolean;
}
/**
 * 
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
    /**
     * 
     * @type {string}
     * @memberof LinkResponse
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
    /**
     * 
     * @type {string}
     * @memberof LoginMethod
     */
    'method': string;
    /**
     * 
     * @type {string}
     * @memberof LoginMethod
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LoginProvider = {
    Github: 'github',
    Gitlab: 'gitlab',
    Gnome: 'gnome',
    Kde: 'kde'
} as const;

export type LoginProvider = typeof LoginProvider[keyof typeof LoginProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const MainCategory = {
    Audiovideo: 'audiovideo',
    Development: 'development',
    Education: 'education',
    Game: 'game',
    Graphics: 'graphics',
    Network: 'network',
    Office: 'office',
    Science: 'science',
    System: 'system',
    Utility: 'utility'
} as const;

export type MainCategory = typeof MainCategory[keyof typeof MainCategory];


/**
 * 
 * @export
 * @interface ModerationApp
 */
export interface ModerationApp {
    /**
     * 
     * @type {Array<ModerationRequestResponse>}
     * @memberof ModerationApp
     */
    'requests': Array<ModerationRequestResponse>;
    /**
     * 
     * @type {number}
     * @memberof ModerationApp
     */
    'requests_count': number;
}
/**
 * 
 * @export
 * @interface ModerationAppItem
 */
export interface ModerationAppItem {
    /**
     * 
     * @type {string}
     * @memberof ModerationAppItem
     */
    'appid': string;
    /**
     * 
     * @type {boolean}
     * @memberof ModerationAppItem
     */
    'is_new_submission': boolean;
    /**
     * 
     * @type {string}
     * @memberof ModerationAppItem
     */
    'updated_at': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModerationAppItem
     */
    'request_types': Array<string>;
}
/**
 * 
 * @export
 * @interface ModerationAppsResponse
 */
export interface ModerationAppsResponse {
    /**
     * 
     * @type {Array<ModerationAppItem>}
     * @memberof ModerationAppsResponse
     */
    'apps': Array<ModerationAppItem>;
    /**
     * 
     * @type {number}
     * @memberof ModerationAppsResponse
     */
    'apps_count': number;
}
/**
 * 
 * @export
 * @interface ModerationRequestResponse
 */
export interface ModerationRequestResponse {
    /**
     * 
     * @type {number}
     * @memberof ModerationRequestResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'app_id': string;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof ModerationRequestResponse
     */
    'build_id': number;
    /**
     * 
     * @type {number}
     * @memberof ModerationRequestResponse
     */
    'job_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ModerationRequestResponse
     */
    'is_outdated': boolean;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'request_type': string;
    /**
     * 
     * @type {}
     * @memberof ModerationRequestResponse
     */
    'request_data':  | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModerationRequestResponse
     */
    'is_new_submission': boolean;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'handled_by': string | null;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'handled_at': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModerationRequestResponse
     */
    'is_approved': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ModerationRequestResponse
     */
    'comment': string | null;
}
/**
 * 
 * @export
 * @interface NascentTransaction
 */
export interface NascentTransaction {
    /**
     * 
     * @type {NascentTransactionSummary}
     * @memberof NascentTransaction
     */
    'summary': NascentTransactionSummary;
    /**
     * 
     * @type {Array<TransactionRow>}
     * @memberof NascentTransaction
     */
    'details': Array<TransactionRow>;
}
/**
 * 
 * @export
 * @interface NascentTransactionSummary
 */
export interface NascentTransactionSummary {
    /**
     * 
     * @type {number}
     * @memberof NascentTransactionSummary
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof NascentTransactionSummary
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof NascentTransactionSummary
     */
    'kind': NascentTransactionSummaryKindEnum;
}

export const NascentTransactionSummaryKindEnum = {
    Donation: 'donation',
    Purchase: 'purchase'
} as const;

export type NascentTransactionSummaryKindEnum = typeof NascentTransactionSummaryKindEnum[keyof typeof NascentTransactionSummaryKindEnum];

/**
 * 
 * @export
 * @interface OauthLoginResponseFailure
 */
export interface OauthLoginResponseFailure {
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseFailure
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseFailure
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseFailure
     */
    'error_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseFailure
     */
    'error_uri'?: string | null;
}
/**
 * 
 * @export
 * @interface OauthLoginResponseSuccess
 */
export interface OauthLoginResponseSuccess {
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseSuccess
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OauthLoginResponseSuccess
     */
    'state': string;
}
/**
 *      A platform is an expression of dependencies which an application may have.     Applications nominally express a single platform key for themselves, or     none at all if they do not need one.  But platforms may depend on one another.      If no platform is specified for an application, it\'s worth getting the default     platform and using that.     
 * @export
 * @interface Platform
 */
export interface Platform {
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    'depends': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Platform
     */
    'aliases': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Platform
     */
    'keep': number;
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    'stripe_account': string | null;
}
/**
 * 
 * @export
 * @interface PricingInfo
 */
export interface PricingInfo {
    /**
     * 
     * @type {number}
     * @memberof PricingInfo
     */
    'recommended_donation': number | null;
    /**
     * 
     * @type {number}
     * @memberof PricingInfo
     */
    'minimum_payment': number | null;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {boolean}
     * @memberof Review
     */
    'approve': boolean;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface ReviewItem
 */
export interface ReviewItem {
    /**
     * 
     * @type {string}
     * @memberof ReviewItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReviewItem
     */
    'summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReviewItem
     */
    'developer_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReviewItem
     */
    'project_license'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReviewItem
     */
    'project_group'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReviewItem
     */
    'compulsory_for_desktop'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ReviewRequest
 */
export interface ReviewRequest {
    /**
     * 
     * @type {number}
     * @memberof ReviewRequest
     */
    'build_id': number;
    /**
     * 
     * @type {number}
     * @memberof ReviewRequest
     */
    'job_id': number;
    /**
     * 
     * @type {{ [key: string]: ReviewItem; }}
     * @memberof ReviewRequest
     */
    'app_metadata': { [key: string]: ReviewItem; };
}
/**
 * 
 * @export
 * @interface ReviewRequestResponse
 */
export interface ReviewRequestResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ReviewRequestResponse
     */
    'requires_review': boolean;
}
/**
 * 
 * @export
 * @interface SearchQuery
 */
export interface SearchQuery {
    /**
     * 
     * @type {string}
     * @memberof SearchQuery
     */
    'query': string;
    /**
     * 
     * @type {}
     * @memberof SearchQuery
     */
    'filters'?:  | null;
}
/**
 * 
 * @export
 * @interface StorefrontInfo
 */
export interface StorefrontInfo {
    /**
     * 
     * @type {VerificationStatus}
     * @memberof StorefrontInfo
     */
    'verification': VerificationStatus | null;
    /**
     * 
     * @type {PricingInfo}
     * @memberof StorefrontInfo
     */
    'pricing': PricingInfo | null;
    /**
     * 
     * @type {boolean}
     * @memberof StorefrontInfo
     */
    'is_free_software': boolean;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {TransactionSummary}
     * @memberof Transaction
     */
    'summary': TransactionSummary;
    /**
     * 
     * @type {CardInfo}
     * @memberof Transaction
     */
    'card': CardInfo | null;
    /**
     * 
     * @type {Array<TransactionRow>}
     * @memberof Transaction
     */
    'details': Array<TransactionRow>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'receipt': string | null;
}
/**
 * 
 * @export
 * @interface TransactionRow
 */
export interface TransactionRow {
    /**
     * 
     * @type {string}
     * @memberof TransactionRow
     */
    'recipient': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionRow
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionRow
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRow
     */
    'kind': TransactionRowKindEnum;
}

export const TransactionRowKindEnum = {
    Donation: 'donation',
    Purchase: 'purchase'
} as const;

export type TransactionRowKindEnum = typeof TransactionRowKindEnum[keyof typeof TransactionRowKindEnum];

/**
 * 
 * @export
 * @interface TransactionSaveCard
 */
export interface TransactionSaveCard {
    /**
     * 
     * @type {string}
     * @memberof TransactionSaveCard
     */
    'save_card'?: TransactionSaveCardSaveCardEnum;
}

export const TransactionSaveCardSaveCardEnum = {
    OffSession: 'off_session',
    OnSession: 'on_session'
} as const;

export type TransactionSaveCardSaveCardEnum = typeof TransactionSaveCardSaveCardEnum[keyof typeof TransactionSaveCardSaveCardEnum];

/**
 * Sorting of transactions, either most-recent first, or oldest first
 * @export
 * @enum {string}
 */

export const TransactionSortOrder = {
    Recent: 'recent',
    Oldest: 'oldest'
} as const;

export type TransactionSortOrder = typeof TransactionSortOrder[keyof typeof TransactionSortOrder];


/**
 * 
 * @export
 * @interface TransactionSummary
 */
export interface TransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionSummary
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    'kind': TransactionSummaryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    'reason': string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionSummary
     */
    'created': number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionSummary
     */
    'updated': number | null;
}

export const TransactionSummaryKindEnum = {
    Donation: 'donation',
    Purchase: 'purchase'
} as const;

export type TransactionSummaryKindEnum = typeof TransactionSummaryKindEnum[keyof typeof TransactionSummaryKindEnum];

/**
 * 
 * @export
 * @interface UpsertQualityModeration
 */
export interface UpsertQualityModeration {
    /**
     * 
     * @type {string}
     * @memberof UpsertQualityModeration
     */
    'guideline_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertQualityModeration
     */
    'passed': boolean;
}
/**
 * 
 * @export
 * @interface UserDeleteRequest
 */
export interface UserDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserDeleteRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VerificationMethod = {
    None: 'none',
    Manual: 'manual',
    Website: 'website',
    LoginProvider: 'login_provider'
} as const;

export type VerificationMethod = typeof VerificationMethod[keyof typeof VerificationMethod];


/**
 * 
 * @export
 * @interface VerificationStatus
 */
export interface VerificationStatus {
    /**
     * 
     * @type {boolean}
     * @memberof VerificationStatus
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof VerificationStatus
     */
    'timestamp': string | null;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof VerificationStatus
     */
    'method': VerificationMethod | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationStatus
     */
    'website': string | null;
    /**
     * 
     * @type {LoginProvider}
     * @memberof VerificationStatus
     */
    'login_provider': LoginProvider | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationStatus
     */
    'login_name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VerificationStatus
     */
    'login_is_organization': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationStatus
     */
    'detail': string | null;
}


/**
 * 
 * @export
 * @interface WebsiteVerificationResult
 */
export interface WebsiteVerificationResult {
    /**
     * 
     * @type {boolean}
     * @memberof WebsiteVerificationResult
     */
    'verified': boolean;
    /**
     * 
     * @type {ErrorDetail}
     * @memberof WebsiteVerificationResult
     */
    'detail': ErrorDetail | null;
    /**
     * 
     * @type {number}
     * @memberof WebsiteVerificationResult
     */
    'status_code': number | null;
}


/**
 * 
 * @export
 * @interface WebsiteVerificationToken
 */
export interface WebsiteVerificationToken {
    /**
     * 
     * @type {string}
     * @memberof WebsiteVerificationToken
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteVerificationToken
     */
    'token': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteInvitesAppIdAcceptPost: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('acceptInviteInvitesAppIdAcceptPost', 'appId', appId)
            const localVarPath = `/invites/{app_id}/accept`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Notification
         * @param {BuildNotificationRequest} buildNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildNotificationEmailsBuildNotificationPost: async (buildNotificationRequest: BuildNotificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildNotificationRequest' is not null or undefined
            assertParamExists('buildNotificationEmailsBuildNotificationPost', 'buildNotificationRequest', buildNotificationRequest)
            const localVarPath = `/emails/build-notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
         * @summary Cancel Transaction
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransactionWalletTransactionsTxnCancelPost: async (txn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('cancelTransactionWalletTransactionsTxnCancelPost', 'txn', txn)
            const localVarPath = `/wallet/transactions/{txn}/cancel`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks whether the logged in user is able to download all of the given app refs.  App IDs can be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\", or just the app ID, e.g. \"org.gnome.Maps\".
         * @summary Check Purchases
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPurchasesPurchasesCheckPurchasesPost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('checkPurchasesPurchasesCheckPurchasesPost', 'requestBody', requestBody)
            const localVarPath = `/purchases/check-purchases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear the fake wallet details
         * @summary Clear Fake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFakeWalletClearfakePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/clearfake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks website verification, and if it succeeds, marks the app as verified for the current account.
         * @summary Confirm Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost: async (appId: string, newApp?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost', 'appId', appId)
            const localVarPath = `/verification/{app_id}/confirm-website-verification`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newApp !== undefined) {
                localVarQueryParameter['new_app'] = newApp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Github Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGithubFlowAuthLoginGithubPost: async (data: Data, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('continueGithubFlowAuthLoginGithubPost', 'data', data)
            const localVarPath = `/auth/login/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gitlab Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGitlabFlowAuthLoginGitlabPost: async (data: Data, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('continueGitlabFlowAuthLoginGitlabPost', 'data', data)
            const localVarPath = `/auth/login/gitlab`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gnome Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGnomeFlowAuthLoginGnomePost: async (data: Data, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('continueGnomeFlowAuthLoginGnomePost', 'data', data)
            const localVarPath = `/auth/login/gnome`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Google Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGoogleFlowAuthLoginGooglePost: async (data: Data, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('continueGoogleFlowAuthLoginGooglePost', 'data', data)
            const localVarPath = `/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Continue Kde Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueKdeFlowAuthLoginKdePost: async (data: Data, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('continueKdeFlowAuthLoginKdePost', 'data', data)
            const localVarPath = `/auth/login/kde`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
         * @summary Create Transaction
         * @param {NascentTransaction} nascentTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionWalletTransactionsPost: async (nascentTransaction: NascentTransaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nascentTransaction' is not null or undefined
            assertParamExists('createTransactionWalletTransactionsPost', 'nascentTransaction', nascentTransaction)
            const localVarPath = `/wallet/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nascentTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInviteInvitesAppIdDeclinePost: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('declineInviteInvitesAppIdDeclinePost', 'appId', appId)
            const localVarPath = `/invites/{app_id}/decline`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Do Agree To Publisher Agreement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/accept-publisher-agreement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the user\'s default account, which determines which display name and email we use.
         * @summary Do Change Default Account
         * @param {ConnectedAccountProvider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doChangeDefaultAccountAuthChangeDefaultAccountPost: async (provider: ConnectedAccountProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('doChangeDefaultAccountAuthChangeDefaultAccountPost', 'provider', provider)
            const localVarPath = `/auth/change-default-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
         * @summary Do Deleteuser
         * @param {UserDeleteRequest} userDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeleteuserAuthDeleteuserPost: async (userDeleteRequest: UserDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userDeleteRequest' is not null or undefined
            assertParamExists('doDeleteuserAuthDeleteuserPost', 'userDeleteRequest', userDeleteRequest)
            const localVarPath = `/auth/deleteuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
         * @summary Do Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLogoutAuthLogoutPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Do Refresh Dev Flatpaks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-dev-flatpaks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Addons
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddonsAddonAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAddonsAddonAppIdGet', 'appId', appId)
            const localVarPath = `/addon/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppsCompatAppsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Apps In Category
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppsInCategoryCompatAppsCategoryCategoryGet: async (category: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('getAppsInCategoryCompatAppsCategoryCategoryGet', 'category', category)
            const localVarPath = `/compat/apps/category/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Appstream
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppstreamAppstreamAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAppstreamAppstreamAppIdGet', 'appId', appId)
            const localVarPath = `/appstream/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the ways an app may be verified.
         * @summary Get Available Methods
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableMethodsVerificationAppIdAvailableMethodsGet: async (appId: string, newApp?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAvailableMethodsVerificationAppIdAvailableMethodsGet', 'appId', appId)
            const localVarPath = `/verification/{app_id}/available-methods`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newApp !== undefined) {
                localVarQueryParameter['new_app'] = newApp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoriesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Category
         * @param {MainCategory} category 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryCategoryCategoryGet: async (category: MainCategory, page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('getCategoryCategoryCategoryGet', 'category', category)
            const localVarPath = `/category/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
         * @summary Get Deleteuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeleteuserAuthDeleteuserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/deleteuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Developer
         * @param {string} developer 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperDeveloperDeveloperGet: async (developer: string, page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'developer' is not null or undefined
            assertParamExists('getDeveloperDeveloperDeveloperGet', 'developer', developer)
            const localVarPath = `/developer/{developer}`
                .replace(`{${"developer"}}`, encodeURIComponent(String(developer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Developers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevelopersDeveloperGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Developers
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevelopersInvitesAppIdDevelopersGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDevelopersInvitesAppIdDevelopersGet', 'appId', appId)
            const localVarPath = `/invites/{app_id}/developers`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a download token for the given app IDs. App IDs should be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\".
         * @summary Get Download Token
         * @param {BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost} bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadTokenPurchasesGenerateDownloadTokenPost: async (bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost: BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost' is not null or undefined
            assertParamExists('getDownloadTokenPurchasesGenerateDownloadTokenPost', 'bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost', bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost)
            const localVarPath = `/purchases/generate-download-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Eol Message Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolMessageAppidEolMessageAppIdGet: async (appId: string, branch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEolMessageAppidEolMessageAppIdGet', 'appId', appId)
            const localVarPath = `/eol/message/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Eol Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolMessageEolMessageGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eol/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Eol Rebase Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolRebaseAppidEolRebaseAppIdGet: async (appId: string, branch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEolRebaseAppidEolRebaseAppIdGet', 'appId', appId)
            const localVarPath = `/eol/rebase/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Eol Rebase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolRebaseEolRebaseGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eol/rebase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Exceptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExceptionsExceptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exceptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Exceptions For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExceptionsForAppExceptionsAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getExceptionsForAppExceptionsAppIdGet', 'appId', appId)
            const localVarPath = `/exceptions/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Invite Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteStatusInvitesAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getInviteStatusInvitesAppIdGet', 'appId', appId)
            const localVarPath = `/invites/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets whether the app is Free Software based on the app ID and license, even if the app is not in the appstream database yet. This is needed in flat-manager-hooks to run validations the first time an app is uploaded.
         * @summary Get Is Free Software
         * @param {string} appId 
         * @param {string | null} [license] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet: async (appId: string, license?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet', 'appId', appId)
            const localVarPath = `/purchases/storefront-info/is-free-software`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }

            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of moderation requests for an app.
         * @summary Get Moderation App
         * @param {string} appId 
         * @param {boolean} [includeOutdated] 
         * @param {boolean} [includeHandled] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModerationAppModerationAppsAppIdGet: async (appId: string, includeOutdated?: boolean, includeHandled?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getModerationAppModerationAppsAppIdGet', 'appId', appId)
            const localVarPath = `/moderation/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeOutdated !== undefined) {
                localVarQueryParameter['include_outdated'] = includeOutdated;
            }

            if (includeHandled !== undefined) {
                localVarQueryParameter['include_handled'] = includeHandled;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of apps with unhandled moderation requests.
         * @summary Get Moderation Apps
         * @param {boolean | null} [newSubmissions] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModerationAppsModerationAppsGet: async (newSubmissions?: boolean | null, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/moderation/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newSubmissions !== undefined) {
                localVarQueryParameter['new_submissions'] = newSubmissions;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get New Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewAppsFeedFeedNewGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feed/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a mapping from org-name to platform aliases and dependencies which are recognised by the backend.  These are used by things such as the transactions and donations APIs to address amounts to the platforms.
         * @summary Get Platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsPlatformsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/platforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularAppsCompatAppsCollectionPopular50Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/popular/50`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularAppsCompatAppsCollectionPopularGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/popular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Popular Last Month
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularLastMonthPopularLastMonthGet: async (page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/popular/last-month`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Project Group
         * @param {string} projectGroup 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectGroupProjectgroupProjectGroupGet: async (projectGroup: string, page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectGroup' is not null or undefined
            assertParamExists('getProjectGroupProjectgroupProjectGroupGet', 'projectGroup', projectGroup)
            const localVarPath = `/projectgroup/{project_group}`
                .replace(`{${"project_group"}}`, encodeURIComponent(String(projectGroup)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Project Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectGroupsProjectgroupGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projectgroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Quality Moderation For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationForAppQualityModerationAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getQualityModerationForAppQualityModerationAppIdGet', 'appId', appId)
            const localVarPath = `/quality-moderation/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Quality Moderation Status For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationStatusForAppQualityModerationAppIdStatusGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getQualityModerationStatusForAppQualityModerationAppIdStatusGet', 'appId', appId)
            const localVarPath = `/quality-moderation/{app_id}/status`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Quality Moderation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationStatusQualityModerationStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/quality-moderation/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCollectionRecentlyAddedGet: async (page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection/recently-added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCompatAppsCollectionNew50Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/new/50`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCompatAppsCollectionNewGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Updated Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feed/recently-updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCollectionRecentlyUpdatedGet: async (page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection/recently-updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/recently-updated/50`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compat/apps/collection/recently-updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntimeListRuntimesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runtimes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Search
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchCompatAppsSearchQueryGet: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getSearchCompatAppsSearchQueryGet', 'query', query)
            const localVarPath = `/compat/apps/search/{query}`
                .replace(`{${"query"}}`, encodeURIComponent(String(query)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleAppCompatAppsAppIdGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSingleAppCompatAppsAppIdGet', 'appId', appId)
            const localVarPath = `/compat/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Stats For App
         * @param {string} appId 
         * @param {boolean} [all] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsForAppStatsAppIdGet: async (appId: string, all?: boolean, days?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getStatsForAppStatsAppIdGet', 'appId', appId)
            const localVarPath = `/stats/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsStatsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by the flathub-hooks scripts to get information about an app to insert into the appstream file and commit metadata.
         * @summary Get Storefront Info
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorefrontInfoPurchasesStorefrontInfoGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getStorefrontInfoPurchasesStorefrontInfoGet', 'appId', appId)
            const localVarPath = `/purchases/storefront-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
         * @summary Get Stripedata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripedataWalletStripedataGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/stripedata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subcategory
         * @param {MainCategory} category 
         * @param {string} subcategory 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubcategoryCategoryCategorySubcategoriesSubcategoryGet: async (category: MainCategory, subcategory: string, page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('getSubcategoryCategoryCategorySubcategoriesSubcategoryGet', 'category', category)
            // verify required parameter 'subcategory' is not null or undefined
            assertParamExists('getSubcategoryCategoryCategorySubcategoriesSubcategoryGet', 'subcategory', subcategory)
            const localVarPath = `/category/{category}/subcategories/{subcategory}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)))
                .replace(`{${"subcategory"}}`, encodeURIComponent(String(subcategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Summary
         * @param {string} appId 
         * @param {string | null} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarySummaryAppIdGet: async (appId: string, branch?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSummarySummaryAppIdGet', 'appId', appId)
            const localVarPath = `/summary/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
         * @summary Get Transaction By Id
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdWalletTransactionsTxnGet: async (txn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('getTransactionByIdWalletTransactionsTxnGet', 'txn', txn)
            const localVarPath = `/wallet/transactions/{txn}`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
         * @summary Get Transactions
         * @param {TransactionSortOrder} [sort] 
         * @param {string | null} [since] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsWalletTransactionsGet: async (sort?: TransactionSortOrder, since?: string | null, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
         * @summary Get Txn Stripedata
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxnStripedataWalletTransactionsTxnStripeGet: async (txn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('getTxnStripedataWalletTransactionsTxnStripeGet', 'txn', txn)
            const localVarPath = `/wallet/transactions/{txn}/stripe`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an update token for a user account. This token allows the user to generate download tokens for apps they already own, but does not grant permission to do anything else. By storing this token, flathub-authenticator is able to update apps without user interaction.
         * @summary Get Update Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateTokenPurchasesGenerateUpdateTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/generate-update-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
         * @summary Get Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserinfoAuthUserinfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the verification status of the given app.
         * @summary Get Verification Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStatusVerificationAppIdStatusGet: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getVerificationStatusVerificationAppIdStatusGet', 'appId', appId)
            const localVarPath = `/verification/{app_id}/status`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Verified
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedCollectionVerifiedGet: async (page?: number | null, perPage?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
         * @summary Get Walletinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletinfoWalletWalletinfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/walletinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheckStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite Developer
         * @param {string} appId 
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteDeveloperInvitesAppIdInvitePost: async (appId: string, inviteCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('inviteDeveloperInvitesAppIdInvitePost', 'appId', appId)
            // verify required parameter 'inviteCode' is not null or undefined
            assertParamExists('inviteDeveloperInvitesAppIdInvitePost', 'inviteCode', inviteCode)
            const localVarPath = `/invites/{app_id}/invite`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inviteCode !== undefined) {
                localVarQueryParameter['invite_code'] = inviteCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave Team
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeamInvitesAppIdLeavePost: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('leaveTeamInvitesAppIdLeavePost', 'appId', appId)
            const localVarPath = `/invites/{app_id}/leave`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Appstream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAppstreamAppstreamGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/appstream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
         * @summary Post Removecard
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRemovecardWalletRemovecardPost: async (cardInfo: CardInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardInfo' is not null or undefined
            assertParamExists('postRemovecardWalletRemovecardPost', 'cardInfo', cardInfo)
            const localVarPath = `/wallet/removecard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Search
         * @param {SearchQuery} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearchSearchPost: async (searchQuery: SearchQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('postSearchSearchPost', 'searchQuery', searchQuery)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview Template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewTemplateEmailsPreviewNameGet: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('previewTemplateEmailsPreviewNameGet', 'name', name)
            const localVarPath = `/emails/preview/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewTemplatesEmailsPreviewGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/emails/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process any pending transfers which may be in the system
         * @summary Process Transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTransfersUpdateProcessPendingTransfersPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/update/process-pending-transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Developer
         * @param {string} appId 
         * @param {number} developerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeveloperInvitesAppIdRemoveDeveloperPost: async (appId: string, developerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('removeDeveloperInvitesAppIdRemoveDeveloperPost', 'appId', appId)
            // verify required parameter 'developerId' is not null or undefined
            assertParamExists('removeDeveloperInvitesAppIdRemoveDeveloperPost', 'developerId', developerId)
            const localVarPath = `/invites/{app_id}/remove-developer`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (developerId !== undefined) {
                localVarQueryParameter['developer_id'] = developerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the URL to request access to the organization so we can verify the user\'s membership.
         * @summary Request Organization Access Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verification/request-organization-access/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke Invite
         * @param {string} appId 
         * @param {number} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInviteInvitesAppIdRevokePost: async (appId: string, inviteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('revokeInviteInvitesAppIdRevokePost', 'appId', appId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('revokeInviteInvitesAppIdRevokePost', 'inviteId', inviteId)
            const localVarPath = `/invites/{app_id}/revoke`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inviteId !== undefined) {
                localVarQueryParameter['invite_id'] = inviteId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
         * @summary Set Pending
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPendingWalletTransactionsTxnSetpendingPost: async (txn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('setPendingWalletTransactionsTxnSetpendingPost', 'txn', txn)
            const localVarPath = `/wallet/transactions/{txn}/setpending`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Quality Moderation For App
         * @param {string} appId 
         * @param {UpsertQualityModeration} upsertQualityModeration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setQualityModerationForAppQualityModerationAppIdPost: async (appId: string, upsertQualityModeration: UpsertQualityModeration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('setQualityModerationForAppQualityModerationAppIdPost', 'appId', appId)
            // verify required parameter 'upsertQualityModeration' is not null or undefined
            assertParamExists('setQualityModerationForAppQualityModerationAppIdPost', 'upsertQualityModeration', upsertQualityModeration)
            const localVarPath = `/quality-moderation/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertQualityModeration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
         * @summary Set Savecard
         * @param {string} txn 
         * @param {TransactionSaveCard} transactionSaveCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSavecardWalletTransactionsTxnSavecardPost: async (txn: string, transactionSaveCard: TransactionSaveCard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('setSavecardWalletTransactionsTxnSavecardPost', 'txn', txn)
            // verify required parameter 'transactionSaveCard' is not null or undefined
            assertParamExists('setSavecardWalletTransactionsTxnSavecardPost', 'transactionSaveCard', transactionSaveCard)
            const localVarPath = `/wallet/transactions/{txn}/savecard`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionSaveCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
         * @summary Set Transaction Card
         * @param {string} txn 
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionCardWalletTransactionsTxnSetcardPost: async (txn: string, cardInfo: CardInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txn' is not null or undefined
            assertParamExists('setTransactionCardWalletTransactionsTxnSetcardPost', 'txn', txn)
            // verify required parameter 'cardInfo' is not null or undefined
            assertParamExists('setTransactionCardWalletTransactionsTxnSetcardPost', 'cardInfo', cardInfo)
            const localVarPath = `/wallet/transactions/{txn}/setcard`
                .replace(`{${"txn"}}`, encodeURIComponent(String(txn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a token for the user to verify the app via website.
         * @summary Setup Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost: async (appId: string, newApp?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost', 'appId', appId)
            const localVarPath = `/verification/{app_id}/setup-website-verification`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newApp !== undefined) {
                localVarQueryParameter['new_app'] = newApp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
         * @summary Start Github Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGithubFlowAuthLoginGithubGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
         * @summary Start Gitlab Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGitlabFlowAuthLoginGitlabGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login/gitlab`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
         * @summary Start Gnome Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGnomeFlowAuthLoginGnomeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login/gnome`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Kde Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startKdeFlowAuthLoginKdeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login/kde`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve or reject the moderation request with a comment. If all requests for a job are approved, the job is marked as successful in flat-manager.
         * @summary Submit Review
         * @param {number} id 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReviewModerationRequestsIdReviewPost: async (id: number, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReviewModerationRequestsIdReviewPost', 'id', id)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('submitReviewModerationRequestsIdReviewPost', 'review', review)
            const localVarPath = `/moderation/requests/{id}/review`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit Review Request
         * @param {ReviewRequest} reviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReviewRequestModerationSubmitReviewRequestPost: async (reviewRequest: ReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewRequest' is not null or undefined
            assertParamExists('submitReviewRequestModerationSubmitReviewRequestPost', 'reviewRequest', reviewRequest)
            const localVarPath = `/moderation/submit_review_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the current account has verified the given app, mark it as no longer verified.
         * @summary Unverify
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyVerificationAppIdUnverifyPost: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('unverifyVerificationAppIdUnverifyPost', 'appId', appId)
            const localVarPath = `/verification/{app_id}/unverify`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatsUpdateStatsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/update/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpdatePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
         * @summary Verify By Login Provider
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost: async (appId: string, newApp?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost', 'appId', appId)
            const localVarPath = `/verification/{app_id}/verify-by-login-provider`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newApp !== undefined) {
                localVarQueryParameter['new_app'] = newApp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookWalletWebhookFakewalletPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/webhook/fakewallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteInvitesAppIdAcceptPost(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInviteInvitesAppIdAcceptPost(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Build Notification
         * @param {BuildNotificationRequest} buildNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildNotificationEmailsBuildNotificationPost(buildNotificationRequest: BuildNotificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildNotificationEmailsBuildNotificationPost(buildNotificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
         * @summary Cancel Transaction
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransactionWalletTransactionsTxnCancelPost(txn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransactionWalletTransactionsTxnCancelPost(txn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks whether the logged in user is able to download all of the given app refs.  App IDs can be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\", or just the app ID, e.g. \"org.gnome.Maps\".
         * @summary Check Purchases
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPurchasesPurchasesCheckPurchasesPost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPurchasesPurchasesCheckPurchasesPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear the fake wallet details
         * @summary Clear Fake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearFakeWalletClearfakePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearFakeWalletClearfakePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks website verification, and if it succeeds, marks the app as verified for the current account.
         * @summary Confirm Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteVerificationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId, newApp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Github Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueGithubFlowAuthLoginGithubPost(data: Data, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueGithubFlowAuthLoginGithubPost(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gitlab Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueGitlabFlowAuthLoginGitlabPost(data: Data, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueGitlabFlowAuthLoginGitlabPost(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gnome Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueGnomeFlowAuthLoginGnomePost(data: Data, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueGnomeFlowAuthLoginGnomePost(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Google Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueGoogleFlowAuthLoginGooglePost(data: Data, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueGoogleFlowAuthLoginGooglePost(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Continue Kde Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueKdeFlowAuthLoginKdePost(data: Data, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueKdeFlowAuthLoginKdePost(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
         * @summary Create Transaction
         * @param {NascentTransaction} nascentTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionWalletTransactionsPost(nascentTransaction: NascentTransaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionWalletTransactionsPost(nascentTransaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Decline Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineInviteInvitesAppIdDeclinePost(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineInviteInvitesAppIdDeclinePost(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Do Agree To Publisher Agreement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes the user\'s default account, which determines which display name and email we use.
         * @summary Do Change Default Account
         * @param {ConnectedAccountProvider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doChangeDefaultAccountAuthChangeDefaultAccountPost(provider: ConnectedAccountProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doChangeDefaultAccountAuthChangeDefaultAccountPost(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
         * @summary Do Deleteuser
         * @param {UserDeleteRequest} userDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doDeleteuserAuthDeleteuserPost(userDeleteRequest: UserDeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doDeleteuserAuthDeleteuserPost(userDeleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
         * @summary Do Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doLogoutAuthLogoutPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doLogoutAuthLogoutPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Do Refresh Dev Flatpaks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Addons
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddonsAddonAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddonsAddonAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppsCompatAppsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppsCompatAppsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Apps In Category
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppsInCategoryCompatAppsCategoryCategoryGet(category: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppsInCategoryCompatAppsCategoryCategoryGet(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Appstream
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppstreamAppstreamAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppstreamAppstreamAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the ways an app may be verified.
         * @summary Get Available Methods
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId: string, newApp?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableMethods>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId, newApp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesCategoriesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesCategoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Category
         * @param {MainCategory} category 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryCategoryCategoryGet(category: MainCategory, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryCategoryCategoryGet(category, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
         * @summary Get Deleteuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeleteuserAuthDeleteuserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeleteuserAuthDeleteuserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Developer
         * @param {string} developer 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperDeveloperDeveloperGet(developer: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperDeveloperDeveloperGet(developer, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Developers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevelopersDeveloperGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevelopersDeveloperGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Developers
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevelopersInvitesAppIdDevelopersGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DevelopersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevelopersInvitesAppIdDevelopersGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a download token for the given app IDs. App IDs should be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\".
         * @summary Get Download Token
         * @param {BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost} bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost: BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Eol Message Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEolMessageAppidEolMessageAppIdGet(appId: string, branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEolMessageAppidEolMessageAppIdGet(appId, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Eol Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEolMessageEolMessageGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEolMessageEolMessageGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Eol Rebase Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEolRebaseAppidEolRebaseAppIdGet(appId: string, branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEolRebaseAppidEolRebaseAppIdGet(appId, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Eol Rebase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEolRebaseEolRebaseGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEolRebaseEolRebaseGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Exceptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExceptionsExceptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExceptionsExceptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Exceptions For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExceptionsForAppExceptionsAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExceptionsForAppExceptionsAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Invite Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInviteStatusInvitesAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInviteStatusInvitesAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets whether the app is Free Software based on the app ID and license, even if the app is not in the appstream database yet. This is needed in flat-manager-hooks to run validations the first time an app is uploaded.
         * @summary Get Is Free Software
         * @param {string} appId 
         * @param {string | null} [license] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId: string, license?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId, license, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of moderation requests for an app.
         * @summary Get Moderation App
         * @param {string} appId 
         * @param {boolean} [includeOutdated] 
         * @param {boolean} [includeHandled] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModerationAppModerationAppsAppIdGet(appId: string, includeOutdated?: boolean, includeHandled?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModerationApp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModerationAppModerationAppsAppIdGet(appId, includeOutdated, includeHandled, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of apps with unhandled moderation requests.
         * @summary Get Moderation Apps
         * @param {boolean | null} [newSubmissions] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModerationAppsModerationAppsGet(newSubmissions?: boolean | null, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModerationAppsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModerationAppsModerationAppsGet(newSubmissions, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get New Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewAppsFeedFeedNewGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewAppsFeedFeedNewGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a mapping from org-name to platform aliases and dependencies which are recognised by the backend.  These are used by things such as the transactions and donations APIs to address amounts to the platforms.
         * @summary Get Platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformsPlatformsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Platform; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformsPlatformsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularAppsCompatAppsCollectionPopular50Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularAppsCompatAppsCollectionPopular50Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularAppsCompatAppsCollectionPopularGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularAppsCompatAppsCollectionPopularGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Popular Last Month
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularLastMonthPopularLastMonthGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularLastMonthPopularLastMonthGet(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Project Group
         * @param {string} projectGroup 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectGroupProjectgroupProjectGroupGet(projectGroup: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectGroupProjectgroupProjectGroupGet(projectGroup, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Project Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectGroupsProjectgroupGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectGroupsProjectgroupGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Quality Moderation For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQualityModerationForAppQualityModerationAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQualityModerationForAppQualityModerationAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Quality Moderation Status For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Quality Moderation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQualityModerationStatusQualityModerationStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQualityModerationStatusQualityModerationStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyAddedCollectionRecentlyAddedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyAddedCollectionRecentlyAddedGet(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyAddedCompatAppsCollectionNew50Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyAddedCompatAppsCollectionNew50Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyAddedCompatAppsCollectionNewGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyAddedCompatAppsCollectionNewGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Updated Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyUpdatedCollectionRecentlyUpdatedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyUpdatedCollectionRecentlyUpdatedGet(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuntimeListRuntimesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuntimeListRuntimesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Search
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchCompatAppsSearchQueryGet(query: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchCompatAppsSearchQueryGet(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Single App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleAppCompatAppsAppIdGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleAppCompatAppsAppIdGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Stats For App
         * @param {string} appId 
         * @param {boolean} [all] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatsForAppStatsAppIdGet(appId: string, all?: boolean, days?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsForAppStatsAppIdGet(appId, all, days, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatsStatsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsStatsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by the flathub-hooks scripts to get information about an app to insert into the appstream file and commit metadata.
         * @summary Get Storefront Info
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorefrontInfoPurchasesStorefrontInfoGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorefrontInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorefrontInfoPurchasesStorefrontInfoGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
         * @summary Get Stripedata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripedataWalletStripedataGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStripedataWalletStripedataGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Subcategory
         * @param {MainCategory} category 
         * @param {string} subcategory 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category: MainCategory, subcategory: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category, subcategory, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Summary
         * @param {string} appId 
         * @param {string | null} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummarySummaryAppIdGet(appId: string, branch?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummarySummaryAppIdGet(appId, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
         * @summary Get Transaction By Id
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByIdWalletTransactionsTxnGet(txn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByIdWalletTransactionsTxnGet(txn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
         * @summary Get Transactions
         * @param {TransactionSortOrder} [sort] 
         * @param {string | null} [since] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsWalletTransactionsGet(sort?: TransactionSortOrder, since?: string | null, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsWalletTransactionsGet(sort, since, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
         * @summary Get Txn Stripedata
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxnStripedataWalletTransactionsTxnStripeGet(txn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxnStripedataWalletTransactionsTxnStripeGet(txn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates an update token for a user account. This token allows the user to generate download tokens for apps they already own, but does not grant permission to do anything else. By storing this token, flathub-authenticator is able to update apps without user interaction.
         * @summary Get Update Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdateTokenPurchasesGenerateUpdateTokenPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdateTokenPurchasesGenerateUpdateTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
         * @summary Get Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserinfoAuthUserinfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserinfoAuthUserinfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the verification status of the given app.
         * @summary Get Verification Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationStatusVerificationAppIdStatusGet(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationStatusVerificationAppIdStatusGet(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Verified
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedCollectionVerifiedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerifiedCollectionVerifiedGet(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
         * @summary Get Walletinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletinfoWalletWalletinfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletinfoWalletWalletinfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheckStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheckStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite Developer
         * @param {string} appId 
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteDeveloperInvitesAppIdInvitePost(appId: string, inviteCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteDeveloperInvitesAppIdInvitePost(appId, inviteCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave Team
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveTeamInvitesAppIdLeavePost(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeamInvitesAppIdLeavePost(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Appstream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAppstreamAppstreamGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAppstreamAppstreamGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
         * @summary Post Removecard
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRemovecardWalletRemovecardPost(cardInfo: CardInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRemovecardWalletRemovecardPost(cardInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Search
         * @param {SearchQuery} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSearchSearchPost(searchQuery: SearchQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSearchSearchPost(searchQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview Template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewTemplateEmailsPreviewNameGet(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewTemplateEmailsPreviewNameGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewTemplatesEmailsPreviewGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewTemplatesEmailsPreviewGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process any pending transfers which may be in the system
         * @summary Process Transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processTransfersUpdateProcessPendingTransfersPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processTransfersUpdateProcessPendingTransfersPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Developer
         * @param {string} appId 
         * @param {number} developerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDeveloperInvitesAppIdRemoveDeveloperPost(appId: string, developerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDeveloperInvitesAppIdRemoveDeveloperPost(appId, developerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the URL to request access to the organization so we can verify the user\'s membership.
         * @summary Request Organization Access Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke Invite
         * @param {string} appId 
         * @param {number} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeInviteInvitesAppIdRevokePost(appId: string, inviteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeInviteInvitesAppIdRevokePost(appId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
         * @summary Set Pending
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPendingWalletTransactionsTxnSetpendingPost(txn: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPendingWalletTransactionsTxnSetpendingPost(txn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Quality Moderation For App
         * @param {string} appId 
         * @param {UpsertQualityModeration} upsertQualityModeration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setQualityModerationForAppQualityModerationAppIdPost(appId: string, upsertQualityModeration: UpsertQualityModeration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setQualityModerationForAppQualityModerationAppIdPost(appId, upsertQualityModeration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
         * @summary Set Savecard
         * @param {string} txn 
         * @param {TransactionSaveCard} transactionSaveCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSavecardWalletTransactionsTxnSavecardPost(txn: string, transactionSaveCard: TransactionSaveCard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSavecardWalletTransactionsTxnSavecardPost(txn, transactionSaveCard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
         * @summary Set Transaction Card
         * @param {string} txn 
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTransactionCardWalletTransactionsTxnSetcardPost(txn: string, cardInfo: CardInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTransactionCardWalletTransactionsTxnSetcardPost(txn, cardInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a token for the user to verify the app via website.
         * @summary Setup Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteVerificationToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId, newApp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
         * @summary Start Github Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startGithubFlowAuthLoginGithubGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGithubFlowAuthLoginGithubGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
         * @summary Start Gitlab Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startGitlabFlowAuthLoginGitlabGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGitlabFlowAuthLoginGitlabGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
         * @summary Start Gnome Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startGnomeFlowAuthLoginGnomeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGnomeFlowAuthLoginGnomeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start Kde Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startKdeFlowAuthLoginKdeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startKdeFlowAuthLoginKdeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve or reject the moderation request with a comment. If all requests for a job are approved, the job is marked as successful in flat-manager.
         * @summary Submit Review
         * @param {number} id 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitReviewModerationRequestsIdReviewPost(id: number, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReviewModerationRequestsIdReviewPost(id, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit Review Request
         * @param {ReviewRequest} reviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest: ReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the current account has verified the given app, mark it as no longer verified.
         * @summary Unverify
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unverifyVerificationAppIdUnverifyPost(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unverifyVerificationAppIdUnverifyPost(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatsUpdateStatsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatsUpdateStatsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUpdatePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUpdatePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
         * @summary Verify By Login Provider
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId, newApp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookWalletWebhookFakewalletPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookWalletWebhookFakewalletPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteInvitesAppIdAcceptPost(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptInviteInvitesAppIdAcceptPost(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Notification
         * @param {BuildNotificationRequest} buildNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildNotificationEmailsBuildNotificationPost(buildNotificationRequest: BuildNotificationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.buildNotificationEmailsBuildNotificationPost(buildNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
         * @summary Cancel Transaction
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransactionWalletTransactionsTxnCancelPost(txn: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTransactionWalletTransactionsTxnCancelPost(txn, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks whether the logged in user is able to download all of the given app refs.  App IDs can be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\", or just the app ID, e.g. \"org.gnome.Maps\".
         * @summary Check Purchases
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPurchasesPurchasesCheckPurchasesPost(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.checkPurchasesPurchasesCheckPurchasesPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear the fake wallet details
         * @summary Clear Fake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFakeWalletClearfakePost(options?: any): AxiosPromise<void> {
            return localVarFp.clearFakeWalletClearfakePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks website verification, and if it succeeds, marks the app as verified for the current account.
         * @summary Confirm Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId: string, newApp?: boolean, options?: any): AxiosPromise<WebsiteVerificationResult> {
            return localVarFp.confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId, newApp, options).then((request) => request(axios, basePath));
        },
        /**
         * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Github Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGithubFlowAuthLoginGithubPost(data: Data, options?: any): AxiosPromise<void> {
            return localVarFp.continueGithubFlowAuthLoginGithubPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gitlab Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGitlabFlowAuthLoginGitlabPost(data: Data, options?: any): AxiosPromise<void> {
            return localVarFp.continueGitlabFlowAuthLoginGitlabPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Gnome Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGnomeFlowAuthLoginGnomePost(data: Data, options?: any): AxiosPromise<void> {
            return localVarFp.continueGnomeFlowAuthLoginGnomePost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
         * @summary Continue Google Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueGoogleFlowAuthLoginGooglePost(data: Data, options?: any): AxiosPromise<void> {
            return localVarFp.continueGoogleFlowAuthLoginGooglePost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Continue Kde Flow
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueKdeFlowAuthLoginKdePost(data: Data, options?: any): AxiosPromise<void> {
            return localVarFp.continueKdeFlowAuthLoginKdePost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
         * @summary Create Transaction
         * @param {NascentTransaction} nascentTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionWalletTransactionsPost(nascentTransaction: NascentTransaction, options?: any): AxiosPromise<void> {
            return localVarFp.createTransactionWalletTransactionsPost(nascentTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline Invite
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInviteInvitesAppIdDeclinePost(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.declineInviteInvitesAppIdDeclinePost(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Do Agree To Publisher Agreement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options?: any): AxiosPromise<void> {
            return localVarFp.doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the user\'s default account, which determines which display name and email we use.
         * @summary Do Change Default Account
         * @param {ConnectedAccountProvider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doChangeDefaultAccountAuthChangeDefaultAccountPost(provider: ConnectedAccountProvider, options?: any): AxiosPromise<void> {
            return localVarFp.doChangeDefaultAccountAuthChangeDefaultAccountPost(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
         * @summary Do Deleteuser
         * @param {UserDeleteRequest} userDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeleteuserAuthDeleteuserPost(userDeleteRequest: UserDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.doDeleteuserAuthDeleteuserPost(userDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
         * @summary Do Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLogoutAuthLogoutPost(options?: any): AxiosPromise<void> {
            return localVarFp.doLogoutAuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Do Refresh Dev Flatpaks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options?: any): AxiosPromise<void> {
            return localVarFp.doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Addons
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddonsAddonAppIdGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAddonsAddonAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppsCompatAppsGet(options?: any): AxiosPromise<void> {
            return localVarFp.getAppsCompatAppsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Apps In Category
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppsInCategoryCompatAppsCategoryCategoryGet(category: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAppsInCategoryCompatAppsCategoryCategoryGet(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Appstream
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppstreamAppstreamAppIdGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAppstreamAppstreamAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the ways an app may be verified.
         * @summary Get Available Methods
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId: string, newApp?: boolean, options?: any): AxiosPromise<AvailableMethods> {
            return localVarFp.getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId, newApp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoriesGet(options?: any): AxiosPromise<void> {
            return localVarFp.getCategoriesCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Category
         * @param {MainCategory} category 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryCategoryCategoryGet(category: MainCategory, page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getCategoryCategoryCategoryGet(category, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
         * @summary Get Deleteuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeleteuserAuthDeleteuserGet(options?: any): AxiosPromise<void> {
            return localVarFp.getDeleteuserAuthDeleteuserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Developer
         * @param {string} developer 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperDeveloperDeveloperGet(developer: string, page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getDeveloperDeveloperDeveloperGet(developer, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Developers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevelopersDeveloperGet(options?: any): AxiosPromise<void> {
            return localVarFp.getDevelopersDeveloperGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Developers
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevelopersInvitesAppIdDevelopersGet(appId: string, options?: any): AxiosPromise<DevelopersResponse> {
            return localVarFp.getDevelopersInvitesAppIdDevelopersGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a download token for the given app IDs. App IDs should be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\".
         * @summary Get Download Token
         * @param {BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost} bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost: BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options?: any): AxiosPromise<void> {
            return localVarFp.getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Eol Message Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolMessageAppidEolMessageAppIdGet(appId: string, branch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getEolMessageAppidEolMessageAppIdGet(appId, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Eol Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolMessageEolMessageGet(options?: any): AxiosPromise<void> {
            return localVarFp.getEolMessageEolMessageGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Eol Rebase Appid
         * @param {string} appId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolRebaseAppidEolRebaseAppIdGet(appId: string, branch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getEolRebaseAppidEolRebaseAppIdGet(appId, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Eol Rebase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEolRebaseEolRebaseGet(options?: any): AxiosPromise<void> {
            return localVarFp.getEolRebaseEolRebaseGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Exceptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExceptionsExceptionsGet(options?: any): AxiosPromise<void> {
            return localVarFp.getExceptionsExceptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Exceptions For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExceptionsForAppExceptionsAppIdGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getExceptionsForAppExceptionsAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Invite Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteStatusInvitesAppIdGet(appId: string, options?: any): AxiosPromise<InviteStatus> {
            return localVarFp.getInviteStatusInvitesAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets whether the app is Free Software based on the app ID and license, even if the app is not in the appstream database yet. This is needed in flat-manager-hooks to run validations the first time an app is uploaded.
         * @summary Get Is Free Software
         * @param {string} appId 
         * @param {string | null} [license] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId: string, license?: string | null, options?: any): AxiosPromise<boolean> {
            return localVarFp.getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId, license, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of moderation requests for an app.
         * @summary Get Moderation App
         * @param {string} appId 
         * @param {boolean} [includeOutdated] 
         * @param {boolean} [includeHandled] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModerationAppModerationAppsAppIdGet(appId: string, includeOutdated?: boolean, includeHandled?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<ModerationApp> {
            return localVarFp.getModerationAppModerationAppsAppIdGet(appId, includeOutdated, includeHandled, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of apps with unhandled moderation requests.
         * @summary Get Moderation Apps
         * @param {boolean | null} [newSubmissions] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModerationAppsModerationAppsGet(newSubmissions?: boolean | null, limit?: number, offset?: number, options?: any): AxiosPromise<ModerationAppsResponse> {
            return localVarFp.getModerationAppsModerationAppsGet(newSubmissions, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get New Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewAppsFeedFeedNewGet(options?: any): AxiosPromise<void> {
            return localVarFp.getNewAppsFeedFeedNewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a mapping from org-name to platform aliases and dependencies which are recognised by the backend.  These are used by things such as the transactions and donations APIs to address amounts to the platforms.
         * @summary Get Platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformsPlatformsGet(options?: any): AxiosPromise<{ [key: string]: Platform; }> {
            return localVarFp.getPlatformsPlatformsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularAppsCompatAppsCollectionPopular50Get(options?: any): AxiosPromise<void> {
            return localVarFp.getPopularAppsCompatAppsCollectionPopular50Get(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Popular Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularAppsCompatAppsCollectionPopularGet(options?: any): AxiosPromise<void> {
            return localVarFp.getPopularAppsCompatAppsCollectionPopularGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Popular Last Month
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularLastMonthPopularLastMonthGet(page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getPopularLastMonthPopularLastMonthGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Project Group
         * @param {string} projectGroup 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectGroupProjectgroupProjectGroupGet(projectGroup: string, page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getProjectGroupProjectgroupProjectGroupGet(projectGroup, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Project Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectGroupsProjectgroupGet(options?: any): AxiosPromise<void> {
            return localVarFp.getProjectGroupsProjectgroupGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Quality Moderation For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationForAppQualityModerationAppIdGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getQualityModerationForAppQualityModerationAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Quality Moderation Status For App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Quality Moderation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityModerationStatusQualityModerationStatusGet(options?: any): AxiosPromise<void> {
            return localVarFp.getQualityModerationStatusQualityModerationStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCollectionRecentlyAddedGet(page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyAddedCollectionRecentlyAddedGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCompatAppsCollectionNew50Get(options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyAddedCompatAppsCollectionNew50Get(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAddedCompatAppsCollectionNewGet(options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyAddedCompatAppsCollectionNewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Updated Apps Feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCollectionRecentlyUpdatedGet(page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyUpdatedCollectionRecentlyUpdatedGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recently Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options?: any): AxiosPromise<void> {
            return localVarFp.getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntimeListRuntimesGet(options?: any): AxiosPromise<void> {
            return localVarFp.getRuntimeListRuntimesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Search
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchCompatAppsSearchQueryGet(query: string, options?: any): AxiosPromise<void> {
            return localVarFp.getSearchCompatAppsSearchQueryGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single App
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleAppCompatAppsAppIdGet(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getSingleAppCompatAppsAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Stats For App
         * @param {string} appId 
         * @param {boolean} [all] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsForAppStatsAppIdGet(appId: string, all?: boolean, days?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getStatsForAppStatsAppIdGet(appId, all, days, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsStatsGet(options?: any): AxiosPromise<void> {
            return localVarFp.getStatsStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by the flathub-hooks scripts to get information about an app to insert into the appstream file and commit metadata.
         * @summary Get Storefront Info
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorefrontInfoPurchasesStorefrontInfoGet(appId: string, options?: any): AxiosPromise<StorefrontInfo> {
            return localVarFp.getStorefrontInfoPurchasesStorefrontInfoGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
         * @summary Get Stripedata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripedataWalletStripedataGet(options?: any): AxiosPromise<void> {
            return localVarFp.getStripedataWalletStripedataGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subcategory
         * @param {MainCategory} category 
         * @param {string} subcategory 
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category: MainCategory, subcategory: string, page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category, subcategory, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Summary
         * @param {string} appId 
         * @param {string | null} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarySummaryAppIdGet(appId: string, branch?: string | null, options?: any): AxiosPromise<void> {
            return localVarFp.getSummarySummaryAppIdGet(appId, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
         * @summary Get Transaction By Id
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdWalletTransactionsTxnGet(txn: string, options?: any): AxiosPromise<Transaction> {
            return localVarFp.getTransactionByIdWalletTransactionsTxnGet(txn, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
         * @summary Get Transactions
         * @param {TransactionSortOrder} [sort] 
         * @param {string | null} [since] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsWalletTransactionsGet(sort?: TransactionSortOrder, since?: string | null, limit?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getTransactionsWalletTransactionsGet(sort, since, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
         * @summary Get Txn Stripedata
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxnStripedataWalletTransactionsTxnStripeGet(txn: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTxnStripedataWalletTransactionsTxnStripeGet(txn, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an update token for a user account. This token allows the user to generate download tokens for apps they already own, but does not grant permission to do anything else. By storing this token, flathub-authenticator is able to update apps without user interaction.
         * @summary Get Update Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateTokenPurchasesGenerateUpdateTokenPost(options?: any): AxiosPromise<void> {
            return localVarFp.getUpdateTokenPurchasesGenerateUpdateTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
         * @summary Get Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserinfoAuthUserinfoGet(options?: any): AxiosPromise<void> {
            return localVarFp.getUserinfoAuthUserinfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the verification status of the given app.
         * @summary Get Verification Status
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStatusVerificationAppIdStatusGet(appId: string, options?: any): AxiosPromise<VerificationStatus> {
            return localVarFp.getVerificationStatusVerificationAppIdStatusGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Verified
         * @param {number | null} [page] 
         * @param {number | null} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedCollectionVerifiedGet(page?: number | null, perPage?: number | null, options?: any): AxiosPromise<void> {
            return localVarFp.getVerifiedCollectionVerifiedGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
         * @summary Get Walletinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletinfoWalletWalletinfoGet(options?: any): AxiosPromise<void> {
            return localVarFp.getWalletinfoWalletWalletinfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheckStatusGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthcheckStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite Developer
         * @param {string} appId 
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteDeveloperInvitesAppIdInvitePost(appId: string, inviteCode: string, options?: any): AxiosPromise<void> {
            return localVarFp.inviteDeveloperInvitesAppIdInvitePost(appId, inviteCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave Team
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeamInvitesAppIdLeavePost(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.leaveTeamInvitesAppIdLeavePost(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Appstream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAppstreamAppstreamGet(options?: any): AxiosPromise<void> {
            return localVarFp.listAppstreamAppstreamGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
         * @summary Post Removecard
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRemovecardWalletRemovecardPost(cardInfo: CardInfo, options?: any): AxiosPromise<void> {
            return localVarFp.postRemovecardWalletRemovecardPost(cardInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Search
         * @param {SearchQuery} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearchSearchPost(searchQuery: SearchQuery, options?: any): AxiosPromise<void> {
            return localVarFp.postSearchSearchPost(searchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview Template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewTemplateEmailsPreviewNameGet(name: string, options?: any): AxiosPromise<string> {
            return localVarFp.previewTemplateEmailsPreviewNameGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewTemplatesEmailsPreviewGet(options?: any): AxiosPromise<string> {
            return localVarFp.previewTemplatesEmailsPreviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Process any pending transfers which may be in the system
         * @summary Process Transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTransfersUpdateProcessPendingTransfersPost(options?: any): AxiosPromise<void> {
            return localVarFp.processTransfersUpdateProcessPendingTransfersPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Developer
         * @param {string} appId 
         * @param {number} developerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeveloperInvitesAppIdRemoveDeveloperPost(appId: string, developerId: number, options?: any): AxiosPromise<void> {
            return localVarFp.removeDeveloperInvitesAppIdRemoveDeveloperPost(appId, developerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the URL to request access to the organization so we can verify the user\'s membership.
         * @summary Request Organization Access Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options?: any): AxiosPromise<LinkResponse> {
            return localVarFp.requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke Invite
         * @param {string} appId 
         * @param {number} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInviteInvitesAppIdRevokePost(appId: string, inviteId: number, options?: any): AxiosPromise<void> {
            return localVarFp.revokeInviteInvitesAppIdRevokePost(appId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
         * @summary Set Pending
         * @param {string} txn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPendingWalletTransactionsTxnSetpendingPost(txn: string, options?: any): AxiosPromise<void> {
            return localVarFp.setPendingWalletTransactionsTxnSetpendingPost(txn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Quality Moderation For App
         * @param {string} appId 
         * @param {UpsertQualityModeration} upsertQualityModeration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setQualityModerationForAppQualityModerationAppIdPost(appId: string, upsertQualityModeration: UpsertQualityModeration, options?: any): AxiosPromise<void> {
            return localVarFp.setQualityModerationForAppQualityModerationAppIdPost(appId, upsertQualityModeration, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
         * @summary Set Savecard
         * @param {string} txn 
         * @param {TransactionSaveCard} transactionSaveCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSavecardWalletTransactionsTxnSavecardPost(txn: string, transactionSaveCard: TransactionSaveCard, options?: any): AxiosPromise<void> {
            return localVarFp.setSavecardWalletTransactionsTxnSavecardPost(txn, transactionSaveCard, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
         * @summary Set Transaction Card
         * @param {string} txn 
         * @param {CardInfo} cardInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionCardWalletTransactionsTxnSetcardPost(txn: string, cardInfo: CardInfo, options?: any): AxiosPromise<void> {
            return localVarFp.setTransactionCardWalletTransactionsTxnSetcardPost(txn, cardInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a token for the user to verify the app via website.
         * @summary Setup Website Verification
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId: string, newApp?: boolean, options?: any): AxiosPromise<WebsiteVerificationToken> {
            return localVarFp.setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId, newApp, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
         * @summary Start Github Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGithubFlowAuthLoginGithubGet(options?: any): AxiosPromise<void> {
            return localVarFp.startGithubFlowAuthLoginGithubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
         * @summary Start Gitlab Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGitlabFlowAuthLoginGitlabGet(options?: any): AxiosPromise<void> {
            return localVarFp.startGitlabFlowAuthLoginGitlabGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
         * @summary Start Gnome Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGnomeFlowAuthLoginGnomeGet(options?: any): AxiosPromise<void> {
            return localVarFp.startGnomeFlowAuthLoginGnomeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Kde Flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startKdeFlowAuthLoginKdeGet(options?: any): AxiosPromise<void> {
            return localVarFp.startKdeFlowAuthLoginKdeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Approve or reject the moderation request with a comment. If all requests for a job are approved, the job is marked as successful in flat-manager.
         * @summary Submit Review
         * @param {number} id 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReviewModerationRequestsIdReviewPost(id: number, review: Review, options?: any): AxiosPromise<void> {
            return localVarFp.submitReviewModerationRequestsIdReviewPost(id, review, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit Review Request
         * @param {ReviewRequest} reviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest: ReviewRequest, options?: any): AxiosPromise<ReviewRequestResponse> {
            return localVarFp.submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If the current account has verified the given app, mark it as no longer verified.
         * @summary Unverify
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyVerificationAppIdUnverifyPost(appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unverifyVerificationAppIdUnverifyPost(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatsUpdateStatsPost(options?: any): AxiosPromise<void> {
            return localVarFp.updateStatsUpdateStatsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpdatePost(options?: any): AxiosPromise<void> {
            return localVarFp.updateUpdatePost(options).then((request) => request(axios, basePath));
        },
        /**
         * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
         * @summary Verify By Login Provider
         * @param {string} appId 
         * @param {boolean} [newApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId: string, newApp?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId, newApp, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookWalletWebhookFakewalletPost(options?: any): AxiosPromise<void> {
            return localVarFp.webhookWalletWebhookFakewalletPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Accept Invite
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acceptInviteInvitesAppIdAcceptPost(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acceptInviteInvitesAppIdAcceptPost(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build Notification
     * @param {BuildNotificationRequest} buildNotificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public buildNotificationEmailsBuildNotificationPost(buildNotificationRequest: BuildNotificationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).buildNotificationEmailsBuildNotificationPost(buildNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a transaction in the `new` or `retry` states.  Note that this may actually not cancel if a webhook fires asynchronously and updates the transaction.  This API will not attempt to prevent stripe payments from completing.
     * @summary Cancel Transaction
     * @param {string} txn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelTransactionWalletTransactionsTxnCancelPost(txn: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelTransactionWalletTransactionsTxnCancelPost(txn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks whether the logged in user is able to download all of the given app refs.  App IDs can be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\", or just the app ID, e.g. \"org.gnome.Maps\".
     * @summary Check Purchases
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkPurchasesPurchasesCheckPurchasesPost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkPurchasesPurchasesCheckPurchasesPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear the fake wallet details
     * @summary Clear Fake
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clearFakeWalletClearfakePost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clearFakeWalletClearfakePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks website verification, and if it succeeds, marks the app as verified for the current account.
     * @summary Confirm Website Verification
     * @param {string} appId 
     * @param {boolean} [newApp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(appId, newApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process the result of the Github oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the github oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from github\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Github Flow
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueGithubFlowAuthLoginGithubPost(data: Data, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueGithubFlowAuthLoginGithubPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process the result of the Gitlab oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gitlab Flow
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueGitlabFlowAuthLoginGitlabPost(data: Data, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueGitlabFlowAuthLoginGitlabPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process the result of the GNOME oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the gitlab oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from GNOME gitlab\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Gnome Flow
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueGnomeFlowAuthLoginGnomePost(data: Data, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueGnomeFlowAuthLoginGnomePost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process the result of the Google oauth flow  This expects to have some JSON posted to it which (on success) contains:  ``` {     \"state\": \"the state code\",     \"code\": \"the google oauth code\", } ```  On failure, the frontend should pass through the state and error so that the backend can clear the flow tokens  ``` {     \"state\": \"the state code\",     \"error\": \"the error code returned from google\", } ```  This endpoint will either return an error, if something was wrong in the backend state machines; or it will return a success code with an indication of whether or not the login sequence completed OK.
     * @summary Continue Google Flow
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueGoogleFlowAuthLoginGooglePost(data: Data, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueGoogleFlowAuthLoginGooglePost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Continue Kde Flow
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueKdeFlowAuthLoginKdePost(data: Data, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueKdeFlowAuthLoginKdePost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transaction, return the ID.  If the passed in nascent transaction is valid, this will create a transaction and return the ID of the newly created wallet, otherwise it\'ll return an error
     * @summary Create Transaction
     * @param {NascentTransaction} nascentTransaction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTransactionWalletTransactionsPost(nascentTransaction: NascentTransaction, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTransactionWalletTransactionsPost(nascentTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline Invite
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public declineInviteInvitesAppIdDeclinePost(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).declineInviteInvitesAppIdDeclinePost(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Do Agree To Publisher Agreement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the user\'s default account, which determines which display name and email we use.
     * @summary Do Change Default Account
     * @param {ConnectedAccountProvider} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public doChangeDefaultAccountAuthChangeDefaultAccountPost(provider: ConnectedAccountProvider, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).doChangeDefaultAccountAuthChangeDefaultAccountPost(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear the login state. This will then delete the user\'s account and associated data. Unless there is an error.  The input to this should be of the form:  ```json {     \"token\": \"...\", } ```
     * @summary Do Deleteuser
     * @param {UserDeleteRequest} userDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public doDeleteuserAuthDeleteuserPost(userDeleteRequest: UserDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).doDeleteuserAuthDeleteuserPost(userDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear the login state.  This will discard tokens which access socials, and will clear the session cookie so that the user is not logged in.
     * @summary Do Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public doLogoutAuthLogoutPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).doLogoutAuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Do Refresh Dev Flatpaks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Addons
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAddonsAddonAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAddonsAddonAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppsCompatAppsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppsCompatAppsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Apps In Category
     * @param {string} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppsInCategoryCompatAppsCategoryCategoryGet(category: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppsInCategoryCompatAppsCategoryCategoryGet(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Appstream
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppstreamAppstreamAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppstreamAppstreamAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the ways an app may be verified.
     * @summary Get Available Methods
     * @param {string} appId 
     * @param {boolean} [newApp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId: string, newApp?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId, newApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoriesCategoriesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoriesCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Category
     * @param {MainCategory} category 
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoryCategoryCategoryGet(category: MainCategory, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoryCategoryCategoryGet(category, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user\'s login information. If they\'re not logged in, they\'ll get a `403` return. Otherwise they will get an option to delete their account and data.
     * @summary Get Deleteuser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDeleteuserAuthDeleteuserGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDeleteuserAuthDeleteuserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Developer
     * @param {string} developer 
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDeveloperDeveloperDeveloperGet(developer: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDeveloperDeveloperDeveloperGet(developer, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Developers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDevelopersDeveloperGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDevelopersDeveloperGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Developers
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDevelopersInvitesAppIdDevelopersGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDevelopersInvitesAppIdDevelopersGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a download token for the given app IDs. App IDs should be in the form of full refs, e.g. \"app/org.gnome.Maps/x86_64/stable\".
     * @summary Get Download Token
     * @param {BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost} bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost: BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDownloadTokenPurchasesGenerateDownloadTokenPost(bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Eol Message Appid
     * @param {string} appId 
     * @param {string} [branch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEolMessageAppidEolMessageAppIdGet(appId: string, branch?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEolMessageAppidEolMessageAppIdGet(appId, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Eol Message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEolMessageEolMessageGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEolMessageEolMessageGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Eol Rebase Appid
     * @param {string} appId 
     * @param {string} [branch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEolRebaseAppidEolRebaseAppIdGet(appId: string, branch?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEolRebaseAppidEolRebaseAppIdGet(appId, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Eol Rebase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEolRebaseEolRebaseGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEolRebaseEolRebaseGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Exceptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExceptionsExceptionsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getExceptionsExceptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Exceptions For App
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExceptionsForAppExceptionsAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getExceptionsForAppExceptionsAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Invite Status
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInviteStatusInvitesAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInviteStatusInvitesAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets whether the app is Free Software based on the app ID and license, even if the app is not in the appstream database yet. This is needed in flat-manager-hooks to run validations the first time an app is uploaded.
     * @summary Get Is Free Software
     * @param {string} appId 
     * @param {string | null} [license] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId: string, license?: string | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet(appId, license, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of moderation requests for an app.
     * @summary Get Moderation App
     * @param {string} appId 
     * @param {boolean} [includeOutdated] 
     * @param {boolean} [includeHandled] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getModerationAppModerationAppsAppIdGet(appId: string, includeOutdated?: boolean, includeHandled?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getModerationAppModerationAppsAppIdGet(appId, includeOutdated, includeHandled, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of apps with unhandled moderation requests.
     * @summary Get Moderation Apps
     * @param {boolean | null} [newSubmissions] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getModerationAppsModerationAppsGet(newSubmissions?: boolean | null, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getModerationAppsModerationAppsGet(newSubmissions, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get New Apps Feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNewAppsFeedFeedNewGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNewAppsFeedFeedNewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a mapping from org-name to platform aliases and dependencies which are recognised by the backend.  These are used by things such as the transactions and donations APIs to address amounts to the platforms.
     * @summary Get Platforms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPlatformsPlatformsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPlatformsPlatformsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Popular Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPopularAppsCompatAppsCollectionPopular50Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPopularAppsCompatAppsCollectionPopular50Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Popular Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPopularAppsCompatAppsCollectionPopularGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPopularAppsCompatAppsCollectionPopularGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Popular Last Month
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPopularLastMonthPopularLastMonthGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPopularLastMonthPopularLastMonthGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Project Group
     * @param {string} projectGroup 
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectGroupProjectgroupProjectGroupGet(projectGroup: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectGroupProjectgroupProjectGroupGet(projectGroup, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Project Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectGroupsProjectgroupGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectGroupsProjectgroupGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Quality Moderation For App
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQualityModerationForAppQualityModerationAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQualityModerationForAppQualityModerationAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Quality Moderation Status For App
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQualityModerationStatusForAppQualityModerationAppIdStatusGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Quality Moderation Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQualityModerationStatusQualityModerationStatusGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQualityModerationStatusQualityModerationStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Added
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyAddedCollectionRecentlyAddedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyAddedCollectionRecentlyAddedGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyAddedCompatAppsCollectionNew50Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyAddedCompatAppsCollectionNew50Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyAddedCompatAppsCollectionNewGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyAddedCompatAppsCollectionNewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Updated Apps Feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Updated
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyUpdatedCollectionRecentlyUpdatedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyUpdatedCollectionRecentlyUpdatedGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated50Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recently Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRuntimeListRuntimesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRuntimeListRuntimesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Search
     * @param {string} query 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSearchCompatAppsSearchQueryGet(query: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSearchCompatAppsSearchQueryGet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single App
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSingleAppCompatAppsAppIdGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleAppCompatAppsAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Stats For App
     * @param {string} appId 
     * @param {boolean} [all] 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatsForAppStatsAppIdGet(appId: string, all?: boolean, days?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatsForAppStatsAppIdGet(appId, all, days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatsStatsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatsStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by the flathub-hooks scripts to get information about an app to insert into the appstream file and commit metadata.
     * @summary Get Storefront Info
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStorefrontInfoPurchasesStorefrontInfoGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStorefrontInfoPurchasesStorefrontInfoGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the stripe public key to use in the frontend.  Since this is not considered secret, we don\'t need a login or anything for this
     * @summary Get Stripedata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStripedataWalletStripedataGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStripedataWalletStripedataGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subcategory
     * @param {MainCategory} category 
     * @param {string} subcategory 
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category: MainCategory, subcategory: string, page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSubcategoryCategoryCategorySubcategoriesSubcategoryGet(category, subcategory, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Summary
     * @param {string} appId 
     * @param {string | null} [branch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSummarySummaryAppIdGet(appId: string, branch?: string | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSummarySummaryAppIdGet(appId, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a transaction by its ID  If the transaction ID is valid, and owned by the calling user, then this will retrieve the whole transaction, including card details and disbursement information if available.
     * @summary Get Transaction By Id
     * @param {string} txn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionByIdWalletTransactionsTxnGet(txn: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionByIdWalletTransactionsTxnGet(txn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of transactions associated with this user.  If anything goes wrong, an error will be returned, otherwise a list of transaction summaries will be returned.
     * @summary Get Transactions
     * @param {TransactionSortOrder} [sort] 
     * @param {string | null} [since] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionsWalletTransactionsGet(sort?: TransactionSortOrder, since?: string | null, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionsWalletTransactionsGet(sort, since, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the Stripe data associated with the given transaction.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which *are* Stripe transactions.
     * @summary Get Txn Stripedata
     * @param {string} txn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTxnStripedataWalletTransactionsTxnStripeGet(txn: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTxnStripedataWalletTransactionsTxnStripeGet(txn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an update token for a user account. This token allows the user to generate download tokens for apps they already own, but does not grant permission to do anything else. By storing this token, flathub-authenticator is able to update apps without user interaction.
     * @summary Get Update Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUpdateTokenPurchasesGenerateUpdateTokenPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUpdateTokenPurchasesGenerateUpdateTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current login\'s user information.  If the user is not logged in you will get a `204` return.  Otherwise you will receive JSON describing the currently logged in user, for example:  ``` {     \"displayname\": \"Mx Human Person\",     \"dev-flatpaks\": [ \"org.people.human.Appname\" ],     \"owned-flatpaks\": [ \"org.foo.bar.Appname\" ],     \"accepted-publisher-agreement-at\": \"2023-06-23T20:38:28.553028\" } ```  If the user has an active github login, you\'ll also get their github login name, and avatar.  If they have some other login, details for that login will be provided.  dev-flatpaks is filtered against IDs available in AppStream
     * @summary Get Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserinfoAuthUserinfoGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserinfoAuthUserinfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the verification status of the given app.
     * @summary Get Verification Status
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVerificationStatusVerificationAppIdStatusGet(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVerificationStatusVerificationAppIdStatusGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Verified
     * @param {number | null} [page] 
     * @param {number | null} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVerifiedCollectionVerifiedGet(page?: number | null, perPage?: number | null, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVerifiedCollectionVerifiedGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the wallet for the currently logged in user.  This will return a list of cards which the user has saved to their account.
     * @summary Get Walletinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWalletinfoWalletWalletinfoGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWalletinfoWalletWalletinfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthcheckStatusGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthcheckStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite Developer
     * @param {string} appId 
     * @param {string} inviteCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public inviteDeveloperInvitesAppIdInvitePost(appId: string, inviteCode: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).inviteDeveloperInvitesAppIdInvitePost(appId, inviteCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave Team
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public leaveTeamInvitesAppIdLeavePost(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).leaveTeamInvitesAppIdLeavePost(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Appstream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listAppstreamAppstreamGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listAppstreamAppstreamGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a card from a user\'s wallet.  The provided information must exactly match a card as would be returned from the wallet info endpoint.
     * @summary Post Removecard
     * @param {CardInfo} cardInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postRemovecardWalletRemovecardPost(cardInfo: CardInfo, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postRemovecardWalletRemovecardPost(cardInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Search
     * @param {SearchQuery} searchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSearchSearchPost(searchQuery: SearchQuery, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSearchSearchPost(searchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview Template
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public previewTemplateEmailsPreviewNameGet(name: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).previewTemplateEmailsPreviewNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public previewTemplatesEmailsPreviewGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).previewTemplatesEmailsPreviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process any pending transfers which may be in the system
     * @summary Process Transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public processTransfersUpdateProcessPendingTransfersPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).processTransfersUpdateProcessPendingTransfersPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Developer
     * @param {string} appId 
     * @param {number} developerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeDeveloperInvitesAppIdRemoveDeveloperPost(appId: string, developerId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeDeveloperInvitesAppIdRemoveDeveloperPost(appId, developerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the URL to request access to the organization so we can verify the user\'s membership.
     * @summary Request Organization Access Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke Invite
     * @param {string} appId 
     * @param {number} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public revokeInviteInvitesAppIdRevokePost(appId: string, inviteId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).revokeInviteInvitesAppIdRevokePost(appId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the transaction as \'pending\' so that we can recover if Stripe flows don\'t quite work (e.g. webhook goes missing)
     * @summary Set Pending
     * @param {string} txn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setPendingWalletTransactionsTxnSetpendingPost(txn: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setPendingWalletTransactionsTxnSetpendingPost(txn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Quality Moderation For App
     * @param {string} appId 
     * @param {UpsertQualityModeration} upsertQualityModeration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setQualityModerationForAppQualityModerationAppIdPost(appId: string, upsertQualityModeration: UpsertQualityModeration, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setQualityModerationForAppQualityModerationAppIdPost(appId, upsertQualityModeration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the save-card status.  This is only applicable to transactions in the `new` or `retry` state and will only work for transactions which are backed by stripe or similar.  If the `save_card` parameter is null, then the card will not be saved, otherwise it will be saved.  If it\'s set to `off_session` then an attempt will be made to create a saved method which can be used without the user re-authenticating
     * @summary Set Savecard
     * @param {string} txn 
     * @param {TransactionSaveCard} transactionSaveCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSavecardWalletTransactionsTxnSavecardPost(txn: string, transactionSaveCard: TransactionSaveCard, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSavecardWalletTransactionsTxnSavecardPost(txn, transactionSaveCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the card associated with a transaction.  The posted card must exactly match one of the cards returned by the wallet info endpoint or else the update may not succeed
     * @summary Set Transaction Card
     * @param {string} txn 
     * @param {CardInfo} cardInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setTransactionCardWalletTransactionsTxnSetcardPost(txn: string, cardInfo: CardInfo, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setTransactionCardWalletTransactionsTxnSetcardPost(txn, cardInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a token for the user to verify the app via website.
     * @summary Setup Website Verification
     * @param {string} appId 
     * @param {boolean} [newApp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(appId, newApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a github login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Github  Upon return from Github to the frontend, the frontend should POST to this endpoint with the relevant data from Github  If the user is already logged in, and has a valid github token stored, then this will return an error instead.
     * @summary Start Github Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startGithubFlowAuthLoginGithubGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startGithubFlowAuthLoginGithubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a gitlab login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to Gitlab  Upon return from Gitlab to the frontend, the frontend should POST to this endpoint with the relevant data from Gitlab  If the user is already logged in, and has a valid gitlab token stored, then this will return an error instead.
     * @summary Start Gitlab Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startGitlabFlowAuthLoginGitlabGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startGitlabFlowAuthLoginGitlabGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a GNOME login flow.  This will set session cookie values and will return a redirect.  The frontend is expected to save the cookie for use later, and follow the redirect to GNOME Gitlab  Upon return from GNOME to the frontend, the frontend should POST to this endpoint with the relevant data from GNOME Gitlab  If the user is already logged in, and has a valid GNOME Gitlab token stored, then this will return an error instead.
     * @summary Start Gnome Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startGnomeFlowAuthLoginGnomeGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startGnomeFlowAuthLoginGnomeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Kde Flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startKdeFlowAuthLoginKdeGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startKdeFlowAuthLoginKdeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve or reject the moderation request with a comment. If all requests for a job are approved, the job is marked as successful in flat-manager.
     * @summary Submit Review
     * @param {number} id 
     * @param {Review} review 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitReviewModerationRequestsIdReviewPost(id: number, review: Review, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitReviewModerationRequestsIdReviewPost(id, review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit Review Request
     * @param {ReviewRequest} reviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest: ReviewRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitReviewRequestModerationSubmitReviewRequestPost(reviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the current account has verified the given app, mark it as no longer verified.
     * @summary Unverify
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unverifyVerificationAppIdUnverifyPost(appId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unverifyVerificationAppIdUnverifyPost(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateStatsUpdateStatsPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateStatsUpdateStatsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUpdatePost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateUpdatePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the current account is eligible to verify the given account via SSO, and the app is not already verified by someone else, marks the app as verified.
     * @summary Verify By Login Provider
     * @param {string} appId 
     * @param {boolean} [newApp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId: string, newApp?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(appId, newApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is intended to deal with webhooks coming back from payment mechanisms etc.  It exists only for the deployed wallet, so its name will vary with the deployed wallet kind.  The exact form of the content posted to the webhook will vary from wallet kind to wallet kind.
     * @summary Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webhookWalletWebhookFakewalletPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhookWalletWebhookFakewalletPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
         * @summary Get Login Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginMethodsAuthLoginGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
         * @summary Get Login Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginMethodsAuthLoginGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoginMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginMethodsAuthLoginGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
         * @summary Get Login Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginMethodsAuthLoginGet(options?: any): AxiosPromise<Array<LoginMethod>> {
            return localVarFp.getLoginMethodsAuthLoginGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * Retrieve the login methods available from the backend.  For each method returned, flow starts with a `GET` to the endpoint `.../login/{method}` and upon completion from the user-agent, with a `POST` to that same endpoint name.  Each method is also given a button icon and some text to use, though frontends with localisation may choose to render other text instead.
     * @summary Get Login Methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public getLoginMethodsAuthLoginGet(options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).getLoginMethodsAuthLoginGet(options).then((request) => request(this.axios, this.basePath));
    }
}



