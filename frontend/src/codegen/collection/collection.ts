/**
 * Generated by orval ðŸº
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  AppSearchDevelopersResponse,
  GetCategoryCollectionCategoryCategoryGetParams,
  GetDeveloperCollectionDeveloperDeveloperGetParams,
  GetDevelopersCollectionDeveloperGetParams,
  GetKeywordCollectionKeywordGetParams,
  GetMobileCollectionMobileGetParams,
  GetPopularLastMonthCollectionPopularGetParams,
  GetRecentlyAddedCollectionRecentlyAddedGetParams,
  GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  GetVerifiedCollectionVerifiedGetParams,
  HTTPValidationError,
  MainCategory,
  MeilisearchResponseAppsIndex,
} from ".././model"

/**
 * @summary Get Categories
 */
export type getCategoriesCollectionCategoryGetResponse200 = {
  data: string[]
  status: 200
}

export type getCategoriesCollectionCategoryGetResponseComposite =
  getCategoriesCollectionCategoryGetResponse200

export type getCategoriesCollectionCategoryGetResponse =
  getCategoriesCollectionCategoryGetResponseComposite & {
    headers: Headers
  }

export const getGetCategoriesCollectionCategoryGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category`
}

export const getCategoriesCollectionCategoryGet = async (
  options?: RequestInit,
): Promise<getCategoriesCollectionCategoryGetResponse> => {
  const res = await fetch(getGetCategoriesCollectionCategoryGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getCategoriesCollectionCategoryGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCategoriesCollectionCategoryGetResponse
}

export const getGetCategoriesCollectionCategoryGetQueryKey = () => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category`,
  ] as const
}

export const getGetCategoriesCollectionCategoryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoriesCollectionCategoryGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
  > = ({ signal }) =>
    getCategoriesCollectionCategoryGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoriesCollectionCategoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
>
export type GetCategoriesCollectionCategoryGetQueryError = unknown

export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Categories
 */

export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetCategoriesCollectionCategoryGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Category
 */
export type getCategoryCollectionCategoryCategoryGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getCategoryCollectionCategoryCategoryGetResponse400 = {
  data: null
  status: 400
}

export type getCategoryCollectionCategoryCategoryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getCategoryCollectionCategoryCategoryGetResponseComposite =
  | getCategoryCollectionCategoryCategoryGetResponse200
  | getCategoryCollectionCategoryCategoryGetResponse400
  | getCategoryCollectionCategoryCategoryGetResponse422

export type getCategoryCollectionCategoryCategoryGetResponse =
  getCategoryCollectionCategoryCategoryGetResponseComposite & {
    headers: Headers
  }

export const getGetCategoryCollectionCategoryCategoryGetUrl = (
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["exclude_subcategories"]

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) =>
        normalizedParams.append(key, v === null ? "null" : v.toString()),
      )
      return
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}`
}

export const getCategoryCollectionCategoryCategoryGet = async (
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: RequestInit,
): Promise<getCategoryCollectionCategoryCategoryGetResponse> => {
  const res = await fetch(
    getGetCategoryCollectionCategoryCategoryGetUrl(category, params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getCategoryCollectionCategoryCategoryGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCategoryCollectionCategoryCategoryGetResponse
}

export const getGetCategoryCollectionCategoryCategoryGetQueryKey = (
  category?: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetCategoryCollectionCategoryCategoryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetCategoryCollectionCategoryCategoryGetQueryKey(category, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
  > = ({ signal }) =>
    getCategoryCollectionCategoryCategoryGet(category, params, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!category,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryCollectionCategoryCategoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
>
export type GetCategoryCollectionCategoryCategoryGetQueryError =
  null | HTTPValidationError

export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params: undefined | GetCategoryCollectionCategoryCategoryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Category
 */

export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetCategoryCollectionCategoryCategoryGetQueryOptions(
    category,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Subcategory
 */
export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse200 =
  {
    data: MeilisearchResponseAppsIndex
    status: 200
  }

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse400 =
  {
    data: null
    status: 400
  }

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse422 =
  {
    data: HTTPValidationError
    status: 422
  }

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseComposite =

    | getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse200
    | getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse400
    | getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse422

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse =
  getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseComposite & {
    headers: Headers
  }

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetUrl = (
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["subcategory", "exclude_subcategories"]

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) =>
        normalizedParams.append(key, v === null ? "null" : v.toString()),
      )
      return
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}/subcategories?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}/subcategories`
}

export const getSubcategoryCollectionCategoryCategorySubcategoriesGet = async (
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: RequestInit,
): Promise<getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse> => {
  const res = await fetch(
    getGetSubcategoryCollectionCategoryCategorySubcategoriesGetUrl(
      category,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse
}

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryKey =
  (
    category?: MainCategory,
    params?: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  ) => {
    return [
      `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}/subcategories`,
      ...(params ? [params] : []),
    ] as const
  }

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
      >
    >,
    TError = null | HTTPValidationError,
  >(
    category: MainCategory,
    params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          TData
        >
      >
      fetch?: RequestInit
    },
  ) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryKey(
        category,
        params,
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
        >
      >
    > = ({ signal }) =>
      getSubcategoryCollectionCategoryCategorySubcategoriesGet(
        category,
        params,
        { signal, ...fetchOptions },
      )

    return {
      queryKey,
      queryFn,
      enabled: !!category,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
      >
    >
  >
export type GetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryError =
  null | HTTPValidationError

export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Subcategory
 */

export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = null | HTTPValidationError,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryOptions(
      category,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Keyword
 */
export type getKeywordCollectionKeywordGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getKeywordCollectionKeywordGetResponse400 = {
  data: null
  status: 400
}

export type getKeywordCollectionKeywordGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getKeywordCollectionKeywordGetResponseComposite =
  | getKeywordCollectionKeywordGetResponse200
  | getKeywordCollectionKeywordGetResponse400
  | getKeywordCollectionKeywordGetResponse422

export type getKeywordCollectionKeywordGetResponse =
  getKeywordCollectionKeywordGetResponseComposite & {
    headers: Headers
  }

export const getGetKeywordCollectionKeywordGetUrl = (
  params: GetKeywordCollectionKeywordGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/keyword?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/keyword`
}

export const getKeywordCollectionKeywordGet = async (
  params: GetKeywordCollectionKeywordGetParams,
  options?: RequestInit,
): Promise<getKeywordCollectionKeywordGetResponse> => {
  const res = await fetch(getGetKeywordCollectionKeywordGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getKeywordCollectionKeywordGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getKeywordCollectionKeywordGetResponse
}

export const getGetKeywordCollectionKeywordGetQueryKey = (
  params?: GetKeywordCollectionKeywordGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/keyword`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetKeywordCollectionKeywordGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = null | HTTPValidationError,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetKeywordCollectionKeywordGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
  > = ({ signal }) =>
    getKeywordCollectionKeywordGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetKeywordCollectionKeywordGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
>
export type GetKeywordCollectionKeywordGetQueryError =
  null | HTTPValidationError

export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = null | HTTPValidationError,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
          TError,
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = null | HTTPValidationError,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
          TError,
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = null | HTTPValidationError,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Keyword
 */

export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = null | HTTPValidationError,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetKeywordCollectionKeywordGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Developers
 */
export type getDevelopersCollectionDeveloperGetResponse200 = {
  data: AppSearchDevelopersResponse
  status: 200
}

export type getDevelopersCollectionDeveloperGetResponse400 = {
  data: null
  status: 400
}

export type getDevelopersCollectionDeveloperGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getDevelopersCollectionDeveloperGetResponseComposite =
  | getDevelopersCollectionDeveloperGetResponse200
  | getDevelopersCollectionDeveloperGetResponse400
  | getDevelopersCollectionDeveloperGetResponse422

export type getDevelopersCollectionDeveloperGetResponse =
  getDevelopersCollectionDeveloperGetResponseComposite & {
    headers: Headers
  }

export const getGetDevelopersCollectionDeveloperGetUrl = (
  params?: GetDevelopersCollectionDeveloperGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer`
}

export const getDevelopersCollectionDeveloperGet = async (
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: RequestInit,
): Promise<getDevelopersCollectionDeveloperGetResponse> => {
  const res = await fetch(getGetDevelopersCollectionDeveloperGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getDevelopersCollectionDeveloperGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDevelopersCollectionDeveloperGetResponse
}

export const getGetDevelopersCollectionDeveloperGetQueryKey = (
  params?: GetDevelopersCollectionDeveloperGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetDevelopersCollectionDeveloperGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDevelopersCollectionDeveloperGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
  > = ({ signal }) =>
    getDevelopersCollectionDeveloperGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDevelopersCollectionDeveloperGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
>
export type GetDevelopersCollectionDeveloperGetQueryError =
  null | HTTPValidationError

export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetDevelopersCollectionDeveloperGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Developers
 */

export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetDevelopersCollectionDeveloperGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Developer
 */
export type getDeveloperCollectionDeveloperDeveloperGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getDeveloperCollectionDeveloperDeveloperGetResponse400 = {
  data: null
  status: 400
}

export type getDeveloperCollectionDeveloperDeveloperGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getDeveloperCollectionDeveloperDeveloperGetResponseComposite =
  | getDeveloperCollectionDeveloperDeveloperGetResponse200
  | getDeveloperCollectionDeveloperDeveloperGetResponse400
  | getDeveloperCollectionDeveloperDeveloperGetResponse422

export type getDeveloperCollectionDeveloperDeveloperGetResponse =
  getDeveloperCollectionDeveloperDeveloperGetResponseComposite & {
    headers: Headers
  }

export const getGetDeveloperCollectionDeveloperDeveloperGetUrl = (
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer/${developer}?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer/${developer}`
}

export const getDeveloperCollectionDeveloperDeveloperGet = async (
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: RequestInit,
): Promise<getDeveloperCollectionDeveloperDeveloperGetResponse> => {
  const res = await fetch(
    getGetDeveloperCollectionDeveloperDeveloperGetUrl(developer, params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getDeveloperCollectionDeveloperDeveloperGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDeveloperCollectionDeveloperDeveloperGetResponse
}

export const getGetDeveloperCollectionDeveloperDeveloperGetQueryKey = (
  developer?: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer/${developer}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetDeveloperCollectionDeveloperDeveloperGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = null | HTTPValidationError,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDeveloperCollectionDeveloperDeveloperGetQueryKey(developer, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>
  > = ({ signal }) =>
    getDeveloperCollectionDeveloperDeveloperGet(developer, params, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!developer,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDeveloperCollectionDeveloperDeveloperGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>
  >
export type GetDeveloperCollectionDeveloperDeveloperGetQueryError =
  null | HTTPValidationError

export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = null | HTTPValidationError,
>(
  developer: string,
  params: undefined | GetDeveloperCollectionDeveloperDeveloperGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = null | HTTPValidationError,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = null | HTTPValidationError,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Developer
 */

export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = null | HTTPValidationError,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetDeveloperCollectionDeveloperDeveloperGetQueryOptions(
      developer,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Recently Updated
 */
export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse400 = {
  data: null
  status: 400
}

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseComposite =
  | getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse200
  | getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse400
  | getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse422

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse =
  getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseComposite & {
    headers: Headers
  }

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetUrl = (
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-updated?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-updated`
}

export const getRecentlyUpdatedCollectionRecentlyUpdatedGet = async (
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: RequestInit,
): Promise<getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse> => {
  const res = await fetch(
    getGetRecentlyUpdatedCollectionRecentlyUpdatedGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse
}

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryKey = (
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-updated`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>
  > = ({ signal }) =>
    getRecentlyUpdatedCollectionRecentlyUpdatedGet(params, {
      signal,
      ...fetchOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>
  >
export type GetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryError =
  null | HTTPValidationError

export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Recently Updated
 */

export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryOptions(
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Recently Added
 */
export type getRecentlyAddedCollectionRecentlyAddedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getRecentlyAddedCollectionRecentlyAddedGetResponse400 = {
  data: null
  status: 400
}

export type getRecentlyAddedCollectionRecentlyAddedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getRecentlyAddedCollectionRecentlyAddedGetResponseComposite =
  | getRecentlyAddedCollectionRecentlyAddedGetResponse200
  | getRecentlyAddedCollectionRecentlyAddedGetResponse400
  | getRecentlyAddedCollectionRecentlyAddedGetResponse422

export type getRecentlyAddedCollectionRecentlyAddedGetResponse =
  getRecentlyAddedCollectionRecentlyAddedGetResponseComposite & {
    headers: Headers
  }

export const getGetRecentlyAddedCollectionRecentlyAddedGetUrl = (
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-added?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-added`
}

export const getRecentlyAddedCollectionRecentlyAddedGet = async (
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: RequestInit,
): Promise<getRecentlyAddedCollectionRecentlyAddedGetResponse> => {
  const res = await fetch(
    getGetRecentlyAddedCollectionRecentlyAddedGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getRecentlyAddedCollectionRecentlyAddedGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getRecentlyAddedCollectionRecentlyAddedGetResponse
}

export const getGetRecentlyAddedCollectionRecentlyAddedGetQueryKey = (
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-added`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetRecentlyAddedCollectionRecentlyAddedGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRecentlyAddedCollectionRecentlyAddedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
  > = ({ signal }) =>
    getRecentlyAddedCollectionRecentlyAddedGet(params, {
      signal,
      ...fetchOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentlyAddedCollectionRecentlyAddedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
>
export type GetRecentlyAddedCollectionRecentlyAddedGetQueryError =
  null | HTTPValidationError

export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
          >,
          TError,
          Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
          >,
          TError,
          Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Recently Added
 */

export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRecentlyAddedCollectionRecentlyAddedGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Verified
 */
export type getVerifiedCollectionVerifiedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getVerifiedCollectionVerifiedGetResponse400 = {
  data: null
  status: 400
}

export type getVerifiedCollectionVerifiedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getVerifiedCollectionVerifiedGetResponseComposite =
  | getVerifiedCollectionVerifiedGetResponse200
  | getVerifiedCollectionVerifiedGetResponse400
  | getVerifiedCollectionVerifiedGetResponse422

export type getVerifiedCollectionVerifiedGetResponse =
  getVerifiedCollectionVerifiedGetResponseComposite & {
    headers: Headers
  }

export const getGetVerifiedCollectionVerifiedGetUrl = (
  params?: GetVerifiedCollectionVerifiedGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/verified?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/verified`
}

export const getVerifiedCollectionVerifiedGet = async (
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: RequestInit,
): Promise<getVerifiedCollectionVerifiedGetResponse> => {
  const res = await fetch(getGetVerifiedCollectionVerifiedGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getVerifiedCollectionVerifiedGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getVerifiedCollectionVerifiedGetResponse
}

export const getGetVerifiedCollectionVerifiedGetQueryKey = (
  params?: GetVerifiedCollectionVerifiedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/verified`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetVerifiedCollectionVerifiedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerifiedCollectionVerifiedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
  > = ({ signal }) =>
    getVerifiedCollectionVerifiedGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVerifiedCollectionVerifiedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
>
export type GetVerifiedCollectionVerifiedGetQueryError =
  null | HTTPValidationError

export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetVerifiedCollectionVerifiedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Verified
 */

export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetVerifiedCollectionVerifiedGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Mobile
 */
export type getMobileCollectionMobileGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getMobileCollectionMobileGetResponse400 = {
  data: null
  status: 400
}

export type getMobileCollectionMobileGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getMobileCollectionMobileGetResponseComposite =
  | getMobileCollectionMobileGetResponse200
  | getMobileCollectionMobileGetResponse400
  | getMobileCollectionMobileGetResponse422

export type getMobileCollectionMobileGetResponse =
  getMobileCollectionMobileGetResponseComposite & {
    headers: Headers
  }

export const getGetMobileCollectionMobileGetUrl = (
  params?: GetMobileCollectionMobileGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/mobile?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/mobile`
}

export const getMobileCollectionMobileGet = async (
  params?: GetMobileCollectionMobileGetParams,
  options?: RequestInit,
): Promise<getMobileCollectionMobileGetResponse> => {
  const res = await fetch(getGetMobileCollectionMobileGetUrl(params), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getMobileCollectionMobileGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getMobileCollectionMobileGetResponse
}

export const getGetMobileCollectionMobileGetQueryKey = (
  params?: GetMobileCollectionMobileGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/mobile`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetMobileCollectionMobileGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetMobileCollectionMobileGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
  > = ({ signal }) =>
    getMobileCollectionMobileGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMobileCollectionMobileGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
>
export type GetMobileCollectionMobileGetQueryError = null | HTTPValidationError

export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetMobileCollectionMobileGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
          TError,
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
          TError,
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Mobile
 */

export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetMobileCollectionMobileGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Popular Last Month
 */
export type getPopularLastMonthCollectionPopularGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getPopularLastMonthCollectionPopularGetResponse400 = {
  data: null
  status: 400
}

export type getPopularLastMonthCollectionPopularGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getPopularLastMonthCollectionPopularGetResponseComposite =
  | getPopularLastMonthCollectionPopularGetResponse200
  | getPopularLastMonthCollectionPopularGetResponse400
  | getPopularLastMonthCollectionPopularGetResponse422

export type getPopularLastMonthCollectionPopularGetResponse =
  getPopularLastMonthCollectionPopularGetResponseComposite & {
    headers: Headers
  }

export const getGetPopularLastMonthCollectionPopularGetUrl = (
  params?: GetPopularLastMonthCollectionPopularGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/popular?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/popular`
}

export const getPopularLastMonthCollectionPopularGet = async (
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: RequestInit,
): Promise<getPopularLastMonthCollectionPopularGetResponse> => {
  const res = await fetch(
    getGetPopularLastMonthCollectionPopularGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPopularLastMonthCollectionPopularGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getPopularLastMonthCollectionPopularGetResponse
}

export const getGetPopularLastMonthCollectionPopularGetQueryKey = (
  params?: GetPopularLastMonthCollectionPopularGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/popular`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetPopularLastMonthCollectionPopularGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetPopularLastMonthCollectionPopularGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
  > = ({ signal }) =>
    getPopularLastMonthCollectionPopularGet(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPopularLastMonthCollectionPopularGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
>
export type GetPopularLastMonthCollectionPopularGetQueryError =
  null | HTTPValidationError

export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetPopularLastMonthCollectionPopularGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Popular Last Month
 */

export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = null | HTTPValidationError,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetPopularLastMonthCollectionPopularGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Trending Last Two Weeks
 */
export type getTrendingLastTwoWeeksCollectionTrendingGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse400 = {
  data: null
  status: 400
}

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getTrendingLastTwoWeeksCollectionTrendingGetResponseComposite =
  | getTrendingLastTwoWeeksCollectionTrendingGetResponse200
  | getTrendingLastTwoWeeksCollectionTrendingGetResponse400
  | getTrendingLastTwoWeeksCollectionTrendingGetResponse422

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse =
  getTrendingLastTwoWeeksCollectionTrendingGetResponseComposite & {
    headers: Headers
  }

export const getGetTrendingLastTwoWeeksCollectionTrendingGetUrl = (
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/trending?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/trending`
}

export const getTrendingLastTwoWeeksCollectionTrendingGet = async (
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: RequestInit,
): Promise<getTrendingLastTwoWeeksCollectionTrendingGetResponse> => {
  const res = await fetch(
    getGetTrendingLastTwoWeeksCollectionTrendingGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTrendingLastTwoWeeksCollectionTrendingGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getTrendingLastTwoWeeksCollectionTrendingGetResponse
}

export const getGetTrendingLastTwoWeeksCollectionTrendingGetQueryKey = (
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/trending`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetTrendingLastTwoWeeksCollectionTrendingGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTrendingLastTwoWeeksCollectionTrendingGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>
  > = ({ signal }) =>
    getTrendingLastTwoWeeksCollectionTrendingGet(params, {
      signal,
      ...fetchOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTrendingLastTwoWeeksCollectionTrendingGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>
  >
export type GetTrendingLastTwoWeeksCollectionTrendingGetQueryError =
  null | HTTPValidationError

export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = null | HTTPValidationError,
>(
  params: undefined | GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Trending Last Two Weeks
 */

export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = null | HTTPValidationError,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetTrendingLastTwoWeeksCollectionTrendingGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
