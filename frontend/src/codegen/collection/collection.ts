/**
 * Generated by orval üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"

import qs from "qs"

import type {
  AppSearchDevelopersResponse,
  GetCategoryCollectionCategoryCategoryGetParams,
  GetDeveloperCollectionDeveloperDeveloperGetParams,
  GetDevelopersCollectionDeveloperGetParams,
  GetKeywordCollectionKeywordGetParams,
  GetMobileCollectionMobileGetParams,
  GetMostFavoritedCollectionFavoritesGetParams,
  GetPopularLastMonthCollectionPopularGetParams,
  GetRecentlyAddedCollectionRecentlyAddedGetParams,
  GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  GetVerifiedCollectionVerifiedGetParams,
  HTTPValidationError,
  MainCategory,
  MeilisearchResponseAppsIndex,
} from ".././model"

/**
 * Get a list of all available main categories for filtering applications.
 * @summary Get Categories
 */
export const getCategoriesCollectionCategoryGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string[]>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category`,
    options,
  )
}

export const getGetCategoriesCollectionCategoryGetQueryKey = () => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category`,
  ] as const
}

export const getGetCategoriesCollectionCategoryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoriesCollectionCategoryGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
  > = ({ signal }) =>
    getCategoriesCollectionCategoryGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoriesCollectionCategoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
>
export type GetCategoriesCollectionCategoryGetQueryError = AxiosError<unknown>

export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Categories
 */

export function useGetCategoriesCollectionCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesCollectionCategoryGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetCategoriesCollectionCategoryGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications in a specific main category.

Supports pagination, subcategory exclusion, and custom sorting.
 * @summary Get Category
 */
export const getCategoryCollectionCategoryCategoryGet = (
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetCategoryCollectionCategoryCategoryGetQueryKey = (
  category?: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetCategoryCollectionCategoryCategoryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetCategoryCollectionCategoryCategoryGetQueryKey(category, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
  > = ({ signal }) =>
    getCategoryCollectionCategoryCategoryGet(category, params, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!category,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryCollectionCategoryCategoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
>
export type GetCategoryCollectionCategoryCategoryGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params: undefined | GetCategoryCollectionCategoryCategoryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Category
 */

export function useGetCategoryCollectionCategoryCategoryGet<
  TData = Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params?: GetCategoryCollectionCategoryCategoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryCollectionCategoryCategoryGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetCategoryCollectionCategoryCategoryGetQueryOptions(
    category,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications in specific subcategories within a main category.

Filters by one or more subcategories (e.g., "ActionGame", "ArcadeGame")
with optional exclusions and sorting.
 * @summary Get Subcategory
 */
export const getSubcategoryCollectionCategoryCategorySubcategoriesGet = (
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}/subcategories`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryKey =
  (
    category?: MainCategory,
    params?: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  ) => {
    return [
      `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/category/${category}/subcategories`,
      ...(params ? [params] : []),
    ] as const
  }

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
      >
    >,
    TError = AxiosError<void | HTTPValidationError>,
  >(
    category: MainCategory,
    params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          TData
        >
      >
      axios?: AxiosRequestConfig
    },
  ) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryKey(
        category,
        params,
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
        >
      >
    > = ({ signal }) =>
      getSubcategoryCollectionCategoryCategorySubcategoriesGet(
        category,
        params,
        { signal, ...axiosOptions },
      )

    return {
      queryKey,
      queryFn,
      enabled: !!category,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
      >
    >
  >
export type GetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Subcategory
 */

export function useGetSubcategoryCollectionCategoryCategorySubcategoriesGet<
  TData = Awaited<
    ReturnType<typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  category: MainCategory,
  params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSubcategoryCollectionCategoryCategorySubcategoriesGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetSubcategoryCollectionCategoryCategorySubcategoriesGetQueryOptions(
      category,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Search for applications by keyword.

Returns apps that have the specified keyword in their metadata.
 * @summary Get Keyword
 */
export const getKeywordCollectionKeywordGet = (
  params: GetKeywordCollectionKeywordGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/keyword`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetKeywordCollectionKeywordGetQueryKey = (
  params?: GetKeywordCollectionKeywordGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/keyword`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetKeywordCollectionKeywordGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetKeywordCollectionKeywordGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
  > = ({ signal }) =>
    getKeywordCollectionKeywordGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetKeywordCollectionKeywordGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
>
export type GetKeywordCollectionKeywordGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
          TError,
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
          TError,
          Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Keyword
 */

export function useGetKeywordCollectionKeywordGet<
  TData = Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: GetKeywordCollectionKeywordGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getKeywordCollectionKeywordGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetKeywordCollectionKeywordGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a paginated list of all developers/publishers on Flathub.

Returns developer names that can be used to filter applications.
 * @summary Get Developers
 */
export const getDevelopersCollectionDeveloperGet = (
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<AppSearchDevelopersResponse>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetDevelopersCollectionDeveloperGetQueryKey = (
  params?: GetDevelopersCollectionDeveloperGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetDevelopersCollectionDeveloperGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDevelopersCollectionDeveloperGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
  > = ({ signal }) =>
    getDevelopersCollectionDeveloperGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDevelopersCollectionDeveloperGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
>
export type GetDevelopersCollectionDeveloperGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetDevelopersCollectionDeveloperGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Developers
 */

export function useGetDevelopersCollectionDeveloperGet<
  TData = Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetDevelopersCollectionDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersCollectionDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetDevelopersCollectionDeveloperGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all applications published by a specific developer.

The developer parameter should match the developer_name field from appstream data.
 * @summary Get Developer
 */
export const getDeveloperCollectionDeveloperDeveloperGet = (
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer/${developer}`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetDeveloperCollectionDeveloperDeveloperGetQueryKey = (
  developer?: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/developer/${developer}`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetDeveloperCollectionDeveloperDeveloperGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDeveloperCollectionDeveloperDeveloperGetQueryKey(developer, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>
  > = ({ signal }) =>
    getDeveloperCollectionDeveloperDeveloperGet(developer, params, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!developer,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDeveloperCollectionDeveloperDeveloperGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>
  >
export type GetDeveloperCollectionDeveloperDeveloperGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  developer: string,
  params: undefined | GetDeveloperCollectionDeveloperDeveloperGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Developer
 */

export function useGetDeveloperCollectionDeveloperDeveloperGet<
  TData = Awaited<
    ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  developer: string,
  params?: GetDeveloperCollectionDeveloperDeveloperGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperCollectionDeveloperDeveloperGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetDeveloperCollectionDeveloperDeveloperGetQueryOptions(
      developer,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications that have been recently updated.

Sorted by the most recent release timestamp.
 * @summary Get Recently Updated
 */
export const getRecentlyUpdatedCollectionRecentlyUpdatedGet = (
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-updated`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryKey = (
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-updated`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>
  > = ({ signal }) =>
    getRecentlyUpdatedCollectionRecentlyUpdatedGet(params, {
      signal,
      ...axiosOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>>
  >
export type GetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Recently Updated
 */

export function useGetRecentlyUpdatedCollectionRecentlyUpdatedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getRecentlyUpdatedCollectionRecentlyUpdatedGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRecentlyUpdatedCollectionRecentlyUpdatedGetQueryOptions(
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications that have been recently added to Flathub.

Sorted by the date the app was first published.
 * @summary Get Recently Added
 */
export const getRecentlyAddedCollectionRecentlyAddedGet = (
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-added`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetRecentlyAddedCollectionRecentlyAddedGetQueryKey = (
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/recently-added`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetRecentlyAddedCollectionRecentlyAddedGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRecentlyAddedCollectionRecentlyAddedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
  > = ({ signal }) =>
    getRecentlyAddedCollectionRecentlyAddedGet(params, {
      signal,
      ...axiosOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentlyAddedCollectionRecentlyAddedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
>
export type GetRecentlyAddedCollectionRecentlyAddedGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
          >,
          TError,
          Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
          >,
          TError,
          Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Recently Added
 */

export function useGetRecentlyAddedCollectionRecentlyAddedGet<
  TData = Awaited<
    ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyAddedCollectionRecentlyAddedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRecentlyAddedCollectionRecentlyAddedGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications that have been verified by Flathub.

Verified apps have proven ownership/authenticity through one of the
verification methods (website, GitHub org, GitLab group, etc.).
 * @summary Get Verified
 */
export const getVerifiedCollectionVerifiedGet = (
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/verified`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetVerifiedCollectionVerifiedGetQueryKey = (
  params?: GetVerifiedCollectionVerifiedGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/verified`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetVerifiedCollectionVerifiedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerifiedCollectionVerifiedGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
  > = ({ signal }) =>
    getVerifiedCollectionVerifiedGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVerifiedCollectionVerifiedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
>
export type GetVerifiedCollectionVerifiedGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetVerifiedCollectionVerifiedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Verified
 */

export function useGetVerifiedCollectionVerifiedGet<
  TData = Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetVerifiedCollectionVerifiedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerifiedCollectionVerifiedGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetVerifiedCollectionVerifiedGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications that are mobile-friendly.

These apps are designed to work well on mobile devices and
have the isMobileFriendly flag set in their metadata.
 * @summary Get Mobile
 */
export const getMobileCollectionMobileGet = (
  params?: GetMobileCollectionMobileGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/mobile`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetMobileCollectionMobileGetQueryKey = (
  params?: GetMobileCollectionMobileGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/mobile`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetMobileCollectionMobileGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetMobileCollectionMobileGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
  > = ({ signal }) =>
    getMobileCollectionMobileGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMobileCollectionMobileGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
>
export type GetMobileCollectionMobileGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetMobileCollectionMobileGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
          TError,
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
          TError,
          Awaited<ReturnType<typeof getMobileCollectionMobileGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Mobile
 */

export function useGetMobileCollectionMobileGet<
  TData = Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMobileCollectionMobileGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMobileCollectionMobileGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetMobileCollectionMobileGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get the most popular applications based on installs in the last month.

Sorted by the number of installations in the previous 30 days.
 * @summary Get Popular Last Month
 */
export const getPopularLastMonthCollectionPopularGet = (
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/popular`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetPopularLastMonthCollectionPopularGetQueryKey = (
  params?: GetPopularLastMonthCollectionPopularGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/popular`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetPopularLastMonthCollectionPopularGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetPopularLastMonthCollectionPopularGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
  > = ({ signal }) =>
    getPopularLastMonthCollectionPopularGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPopularLastMonthCollectionPopularGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
>
export type GetPopularLastMonthCollectionPopularGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetPopularLastMonthCollectionPopularGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
          TError,
          Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Popular Last Month
 */

export function useGetPopularLastMonthCollectionPopularGet<
  TData = Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetPopularLastMonthCollectionPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularLastMonthCollectionPopularGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetPopularLastMonthCollectionPopularGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get trending applications based on recent growth in installs.

Uses a trending score calculated from install growth over the last two weeks,
highlighting apps that are gaining popularity.
 * @summary Get Trending Last Two Weeks
 */
export const getTrendingLastTwoWeeksCollectionTrendingGet = (
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/trending`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetTrendingLastTwoWeeksCollectionTrendingGetQueryKey = (
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/trending`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetTrendingLastTwoWeeksCollectionTrendingGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetTrendingLastTwoWeeksCollectionTrendingGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>
  > = ({ signal }) =>
    getTrendingLastTwoWeeksCollectionTrendingGet(params, {
      signal,
      ...axiosOptions,
    })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTrendingLastTwoWeeksCollectionTrendingGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>>
  >
export type GetTrendingLastTwoWeeksCollectionTrendingGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Trending Last Two Weeks
 */

export function useGetTrendingLastTwoWeeksCollectionTrendingGet<
  TData = Awaited<
    ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getTrendingLastTwoWeeksCollectionTrendingGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetTrendingLastTwoWeeksCollectionTrendingGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get applications sorted by the number of times they have been favorited.

Returns apps ordered by their favorites count in descending order,
showing the most popular apps among users.
 * @summary Get Most Favorited
 */
export const getMostFavoritedCollectionFavoritesGet = (
  params?: GetMostFavoritedCollectionFavoritesGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MeilisearchResponseAppsIndex>> => {
  return axios.get(
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/favorites`,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getGetMostFavoritedCollectionFavoritesGetQueryKey = (
  params?: GetMostFavoritedCollectionFavoritesGetParams,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/collection/favorites`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetMostFavoritedCollectionFavoritesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMostFavoritedCollectionFavoritesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetMostFavoritedCollectionFavoritesGetQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>
  > = ({ signal }) =>
    getMostFavoritedCollectionFavoritesGet(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMostFavoritedCollectionFavoritesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>
>
export type GetMostFavoritedCollectionFavoritesGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetMostFavoritedCollectionFavoritesGet<
  TData = Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params: undefined | GetMostFavoritedCollectionFavoritesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
          TError,
          Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMostFavoritedCollectionFavoritesGet<
  TData = Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMostFavoritedCollectionFavoritesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
          TError,
          Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetMostFavoritedCollectionFavoritesGet<
  TData = Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMostFavoritedCollectionFavoritesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Most Favorited
 */

export function useGetMostFavoritedCollectionFavoritesGet<
  TData = Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
  TError = AxiosError<void | HTTPValidationError>,
>(
  params?: GetMostFavoritedCollectionFavoritesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostFavoritedCollectionFavoritesGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetMostFavoritedCollectionFavoritesGetQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
