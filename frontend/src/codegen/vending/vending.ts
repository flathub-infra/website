/**
 * Generated by orval 🍺
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  ProposedPayment,
  RedemptionResult,
  TokenCancellation,
  TokenList,
  TokenModel,
  VendingApplicationInformation,
  VendingConfig,
  VendingOnboardingRequest,
  VendingOutput,
  VendingRedirect,
  VendingSetup,
  VendingSetupRequest,
  VendingStatus,
} from ".././model"

/**
 * Retrieve the vending status of the logged in user.

This will return `201` if the logged in user has never begun the onboarding
flow to be a vendor on Flathub.
 * @summary Status
 */
export type statusVendingStatusGetResponse200 = {
  data: VendingStatus
  status: 200
}

export type statusVendingStatusGetResponse201 = {
  data: null
  status: 201
}

export type statusVendingStatusGetResponse401 = {
  data: null
  status: 401
}

export type statusVendingStatusGetResponse403 = {
  data: null
  status: 403
}

export type statusVendingStatusGetResponse500 = {
  data: null
  status: 500
}

export type statusVendingStatusGetResponseComposite =
  | statusVendingStatusGetResponse200
  | statusVendingStatusGetResponse201
  | statusVendingStatusGetResponse401
  | statusVendingStatusGetResponse403
  | statusVendingStatusGetResponse500

export type statusVendingStatusGetResponse =
  statusVendingStatusGetResponseComposite & {
    headers: Headers
  }

export const getStatusVendingStatusGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/status`
}

export const statusVendingStatusGet = async (
  options?: RequestInit,
): Promise<statusVendingStatusGetResponse> => {
  const res = await fetch(getStatusVendingStatusGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statusVendingStatusGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as statusVendingStatusGetResponse
}

export const getStatusVendingStatusGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/status`] as const
}

export const getStatusVendingStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = null | null | null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStatusVendingStatusGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statusVendingStatusGet>>
  > = ({ signal }) => statusVendingStatusGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statusVendingStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatusVendingStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof statusVendingStatusGet>>
>
export type StatusVendingStatusGetQueryError = null | null | null

export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = null | null | null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statusVendingStatusGet>>,
          TError,
          Awaited<ReturnType<typeof statusVendingStatusGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statusVendingStatusGet>>,
          TError,
          Awaited<ReturnType<typeof statusVendingStatusGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Status
 */

export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStatusVendingStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Start or continue the onboarding process.
 * @summary Start Onboarding
 */
export type startOnboardingVendingStatusOnboardingPostResponse200 = {
  data: VendingRedirect
  status: 200
}

export type startOnboardingVendingStatusOnboardingPostResponse401 = {
  data: null
  status: 401
}

export type startOnboardingVendingStatusOnboardingPostResponse403 = {
  data: null
  status: 403
}

export type startOnboardingVendingStatusOnboardingPostResponse422 = {
  data: null
  status: 422
}

export type startOnboardingVendingStatusOnboardingPostResponse500 = {
  data: null
  status: 500
}

export type startOnboardingVendingStatusOnboardingPostResponseComposite =
  | startOnboardingVendingStatusOnboardingPostResponse200
  | startOnboardingVendingStatusOnboardingPostResponse401
  | startOnboardingVendingStatusOnboardingPostResponse403
  | startOnboardingVendingStatusOnboardingPostResponse422
  | startOnboardingVendingStatusOnboardingPostResponse500

export type startOnboardingVendingStatusOnboardingPostResponse =
  startOnboardingVendingStatusOnboardingPostResponseComposite & {
    headers: Headers
  }

export const getStartOnboardingVendingStatusOnboardingPostUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/status/onboarding`
}

export const startOnboardingVendingStatusOnboardingPost = async (
  vendingOnboardingRequest: VendingOnboardingRequest,
  options?: RequestInit,
): Promise<startOnboardingVendingStatusOnboardingPostResponse> => {
  const res = await fetch(getStartOnboardingVendingStatusOnboardingPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(vendingOnboardingRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: startOnboardingVendingStatusOnboardingPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as startOnboardingVendingStatusOnboardingPostResponse
}

export const getStartOnboardingVendingStatusOnboardingPostMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
    TError,
    { data: VendingOnboardingRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
  TError,
  { data: VendingOnboardingRequest },
  TContext
> => {
  const mutationKey = ["startOnboardingVendingStatusOnboardingPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
    { data: VendingOnboardingRequest }
  > = (props) => {
    const { data } = props ?? {}

    return startOnboardingVendingStatusOnboardingPost(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type StartOnboardingVendingStatusOnboardingPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>
  >
export type StartOnboardingVendingStatusOnboardingPostMutationBody =
  VendingOnboardingRequest
export type StartOnboardingVendingStatusOnboardingPostMutationError =
  | null
  | null
  | null
  | null

/**
 * @summary Start Onboarding
 */
export const useStartOnboardingVendingStatusOnboardingPost = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
      TError,
      { data: VendingOnboardingRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
  TError,
  { data: VendingOnboardingRequest },
  TContext
> => {
  const mutationOptions =
    getStartOnboardingVendingStatusOnboardingPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Retrieve a link to the logged in user's Stripe express dashboard.

The user must be logged in and must have onboarded.
 * @summary Get Dashboard Link
 */
export type getDashboardLinkVendingStatusDashboardlinkGetResponse200 = {
  data: VendingRedirect
  status: 200
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse401 = {
  data: null
  status: 401
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse403 = {
  data: null
  status: 403
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse404 = {
  data: null
  status: 404
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse500 = {
  data: null
  status: 500
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponseComposite =
  | getDashboardLinkVendingStatusDashboardlinkGetResponse200
  | getDashboardLinkVendingStatusDashboardlinkGetResponse401
  | getDashboardLinkVendingStatusDashboardlinkGetResponse403
  | getDashboardLinkVendingStatusDashboardlinkGetResponse404
  | getDashboardLinkVendingStatusDashboardlinkGetResponse500

export type getDashboardLinkVendingStatusDashboardlinkGetResponse =
  getDashboardLinkVendingStatusDashboardlinkGetResponseComposite & {
    headers: Headers
  }

export const getGetDashboardLinkVendingStatusDashboardlinkGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/status/dashboardlink`
}

export const getDashboardLinkVendingStatusDashboardlinkGet = async (
  options?: RequestInit,
): Promise<getDashboardLinkVendingStatusDashboardlinkGetResponse> => {
  const res = await fetch(
    getGetDashboardLinkVendingStatusDashboardlinkGetUrl(),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getDashboardLinkVendingStatusDashboardlinkGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDashboardLinkVendingStatusDashboardlinkGetResponse
}

export const getGetDashboardLinkVendingStatusDashboardlinkGetQueryKey = () => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/status/dashboardlink`,
  ] as const
}

export const getGetDashboardLinkVendingStatusDashboardlinkGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = null | null | null | null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDashboardLinkVendingStatusDashboardlinkGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>
  > = ({ signal }) =>
    getDashboardLinkVendingStatusDashboardlinkGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardLinkVendingStatusDashboardlinkGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>
  >
export type GetDashboardLinkVendingStatusDashboardlinkGetQueryError =
  | null
  | null
  | null
  | null

export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = null | null | null | null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = null | null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = null | null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Dashboard Link
 */

export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = null | null | null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetDashboardLinkVendingStatusDashboardlinkGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve the configuration values needed to calculate application
vending splits client-side.

Configuration includes:
- Fee values
- Platform values
 * @summary Get Global Vending Config
 */
export type getGlobalVendingConfigVendingConfigGetResponse200 = {
  data: VendingConfig
  status: 200
}

export type getGlobalVendingConfigVendingConfigGetResponse500 = {
  data: null
  status: 500
}

export type getGlobalVendingConfigVendingConfigGetResponseComposite =
  | getGlobalVendingConfigVendingConfigGetResponse200
  | getGlobalVendingConfigVendingConfigGetResponse500

export type getGlobalVendingConfigVendingConfigGetResponse =
  getGlobalVendingConfigVendingConfigGetResponseComposite & {
    headers: Headers
  }

export const getGetGlobalVendingConfigVendingConfigGetUrl = () => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/config`
}

export const getGlobalVendingConfigVendingConfigGet = async (
  options?: RequestInit,
): Promise<getGlobalVendingConfigVendingConfigGetResponse> => {
  const res = await fetch(getGetGlobalVendingConfigVendingConfigGetUrl(), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGlobalVendingConfigVendingConfigGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getGlobalVendingConfigVendingConfigGetResponse
}

export const getGetGlobalVendingConfigVendingConfigGetQueryKey = () => {
  return [`${process.env.NEXT_PUBLIC_API_BASE_URI}/vending/config`] as const
}

export const getGetGlobalVendingConfigVendingConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  >
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetGlobalVendingConfigVendingConfigGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
  > = ({ signal }) =>
    getGlobalVendingConfigVendingConfigGet({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGlobalVendingConfigVendingConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
>
export type GetGlobalVendingConfigVendingConfigGetQueryError = null

export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Global Vending Config
 */

export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetGlobalVendingConfigVendingConfigGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve the vending status for a given application.
 * @summary Get App Vending Setup
 */
export type getAppVendingSetupVendingappAppIdSetupGetResponse200 = {
  data: VendingSetup
  status: 200
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse401 = {
  data: null
  status: 401
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse403 = {
  data: null
  status: 403
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse404 = {
  data: null
  status: 404
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse422 = {
  data: null
  status: 422
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse500 = {
  data: null
  status: 500
}

export type getAppVendingSetupVendingappAppIdSetupGetResponseComposite =
  | getAppVendingSetupVendingappAppIdSetupGetResponse200
  | getAppVendingSetupVendingappAppIdSetupGetResponse401
  | getAppVendingSetupVendingappAppIdSetupGetResponse403
  | getAppVendingSetupVendingappAppIdSetupGetResponse404
  | getAppVendingSetupVendingappAppIdSetupGetResponse422
  | getAppVendingSetupVendingappAppIdSetupGetResponse500

export type getAppVendingSetupVendingappAppIdSetupGetResponse =
  getAppVendingSetupVendingappAppIdSetupGetResponseComposite & {
    headers: Headers
  }

export const getGetAppVendingSetupVendingappAppIdSetupGetUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/setup`
}

export const getAppVendingSetupVendingappAppIdSetupGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getAppVendingSetupVendingappAppIdSetupGetResponse> => {
  const res = await fetch(
    getGetAppVendingSetupVendingappAppIdSetupGetUrl(appId),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAppVendingSetupVendingappAppIdSetupGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getAppVendingSetupVendingappAppIdSetupGetResponse
}

export const getGetAppVendingSetupVendingappAppIdSetupGetQueryKey = (
  appId?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/setup`,
  ] as const
}

export const getGetAppVendingSetupVendingappAppIdSetupGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAppVendingSetupVendingappAppIdSetupGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
  > = ({ signal }) =>
    getAppVendingSetupVendingappAppIdSetupGet(appId, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppVendingSetupVendingappAppIdSetupGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
>
export type GetAppVendingSetupVendingappAppIdSetupGetQueryError =
  | null
  | null
  | null
  | null
  | null

export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = null | null | null | null | null,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
          TError,
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
          TError,
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get App Vending Setup
 */

export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAppVendingSetupVendingappAppIdSetupGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create/update the vending status for a given application.  Returns an error
if the appid is not known, or if it's already set up for vending with a
user other than the one calling this API.

If you do not have the right to set the vending status for this application
then you will also be refused.

In addition, if any of the currency or amount values constraints are violated
then you will get an error
 * @summary Post App Vending Setup
 */
export type postAppVendingSetupVendingappAppIdSetupPostResponse200 = {
  data: VendingSetup
  status: 200
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse401 = {
  data: null
  status: 401
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse403 = {
  data: null
  status: 403
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse404 = {
  data: null
  status: 404
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse422 = {
  data: null
  status: 422
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse500 = {
  data: null
  status: 500
}

export type postAppVendingSetupVendingappAppIdSetupPostResponseComposite =
  | postAppVendingSetupVendingappAppIdSetupPostResponse200
  | postAppVendingSetupVendingappAppIdSetupPostResponse401
  | postAppVendingSetupVendingappAppIdSetupPostResponse403
  | postAppVendingSetupVendingappAppIdSetupPostResponse404
  | postAppVendingSetupVendingappAppIdSetupPostResponse422
  | postAppVendingSetupVendingappAppIdSetupPostResponse500

export type postAppVendingSetupVendingappAppIdSetupPostResponse =
  postAppVendingSetupVendingappAppIdSetupPostResponseComposite & {
    headers: Headers
  }

export const getPostAppVendingSetupVendingappAppIdSetupPostUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/setup`
}

export const postAppVendingSetupVendingappAppIdSetupPost = async (
  appId: string,
  vendingSetupRequest: VendingSetupRequest,
  options?: RequestInit,
): Promise<postAppVendingSetupVendingappAppIdSetupPostResponse> => {
  const res = await fetch(
    getPostAppVendingSetupVendingappAppIdSetupPostUrl(appId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(vendingSetupRequest),
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postAppVendingSetupVendingappAppIdSetupPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postAppVendingSetupVendingappAppIdSetupPostResponse
}

export const getPostAppVendingSetupVendingappAppIdSetupPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
    TError,
    { appId: string; data: VendingSetupRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
  TError,
  { appId: string; data: VendingSetupRequest },
  TContext
> => {
  const mutationKey = ["postAppVendingSetupVendingappAppIdSetupPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
    { appId: string; data: VendingSetupRequest }
  > = (props) => {
    const { appId, data } = props ?? {}

    return postAppVendingSetupVendingappAppIdSetupPost(
      appId,
      data,
      fetchOptions,
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type PostAppVendingSetupVendingappAppIdSetupPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>
  >
export type PostAppVendingSetupVendingappAppIdSetupPostMutationBody =
  VendingSetupRequest
export type PostAppVendingSetupVendingappAppIdSetupPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Post App Vending Setup
 */
export const usePostAppVendingSetupVendingappAppIdSetupPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
      TError,
      { appId: string; data: VendingSetupRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
  TError,
  { appId: string; data: VendingSetupRequest },
  TContext
> => {
  const mutationOptions =
    getPostAppVendingSetupVendingappAppIdSetupPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Construct a transaction for the given application with the proposed payment.
If the proposed payment is unacceptable then an error will be returned.
If the user is not logged in, then an error will be returned.

Otherwise a transaction will be created and the information about it will be
returned in the output of the call.
 * @summary Post App Vending Status
 */
export type postAppVendingStatusVendingappAppIdPostResponse200 = {
  data: VendingOutput
  status: 200
}

export type postAppVendingStatusVendingappAppIdPostResponse401 = {
  data: null
  status: 401
}

export type postAppVendingStatusVendingappAppIdPostResponse403 = {
  data: null
  status: 403
}

export type postAppVendingStatusVendingappAppIdPostResponse404 = {
  data: null
  status: 404
}

export type postAppVendingStatusVendingappAppIdPostResponse422 = {
  data: null
  status: 422
}

export type postAppVendingStatusVendingappAppIdPostResponse500 = {
  data: null
  status: 500
}

export type postAppVendingStatusVendingappAppIdPostResponseComposite =
  | postAppVendingStatusVendingappAppIdPostResponse200
  | postAppVendingStatusVendingappAppIdPostResponse401
  | postAppVendingStatusVendingappAppIdPostResponse403
  | postAppVendingStatusVendingappAppIdPostResponse404
  | postAppVendingStatusVendingappAppIdPostResponse422
  | postAppVendingStatusVendingappAppIdPostResponse500

export type postAppVendingStatusVendingappAppIdPostResponse =
  postAppVendingStatusVendingappAppIdPostResponseComposite & {
    headers: Headers
  }

export const getPostAppVendingStatusVendingappAppIdPostUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}`
}

export const postAppVendingStatusVendingappAppIdPost = async (
  appId: string,
  proposedPayment: ProposedPayment,
  options?: RequestInit,
): Promise<postAppVendingStatusVendingappAppIdPostResponse> => {
  const res = await fetch(
    getPostAppVendingStatusVendingappAppIdPostUrl(appId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(proposedPayment),
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postAppVendingStatusVendingappAppIdPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postAppVendingStatusVendingappAppIdPostResponse
}

export const getPostAppVendingStatusVendingappAppIdPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
    TError,
    { appId: string; data: ProposedPayment },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
  TError,
  { appId: string; data: ProposedPayment },
  TContext
> => {
  const mutationKey = ["postAppVendingStatusVendingappAppIdPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
    { appId: string; data: ProposedPayment }
  > = (props) => {
    const { appId, data } = props ?? {}

    return postAppVendingStatusVendingappAppIdPost(appId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PostAppVendingStatusVendingappAppIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>
>
export type PostAppVendingStatusVendingappAppIdPostMutationBody =
  ProposedPayment
export type PostAppVendingStatusVendingappAppIdPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Post App Vending Status
 */
export const usePostAppVendingStatusVendingappAppIdPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
      TError,
      { appId: string; data: ProposedPayment },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
  TError,
  { appId: string; data: ProposedPayment },
  TContext
> => {
  const mutationOptions =
    getPostAppVendingStatusVendingappAppIdPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Retrieve the redeemable tokens for the given application.

The caller must have control of the app at some level

For now, there is no pagination or filtering, all tokens will be returned
 * @summary Get Redeemable Tokens
 */
export type getRedeemableTokensVendingappAppIdTokensGetResponse200 = {
  data: TokenList
  status: 200
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse401 = {
  data: null
  status: 401
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse403 = {
  data: null
  status: 403
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse404 = {
  data: null
  status: 404
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse422 = {
  data: null
  status: 422
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse500 = {
  data: null
  status: 500
}

export type getRedeemableTokensVendingappAppIdTokensGetResponseComposite =
  | getRedeemableTokensVendingappAppIdTokensGetResponse200
  | getRedeemableTokensVendingappAppIdTokensGetResponse401
  | getRedeemableTokensVendingappAppIdTokensGetResponse403
  | getRedeemableTokensVendingappAppIdTokensGetResponse404
  | getRedeemableTokensVendingappAppIdTokensGetResponse422
  | getRedeemableTokensVendingappAppIdTokensGetResponse500

export type getRedeemableTokensVendingappAppIdTokensGetResponse =
  getRedeemableTokensVendingappAppIdTokensGetResponseComposite & {
    headers: Headers
  }

export const getGetRedeemableTokensVendingappAppIdTokensGetUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/tokens`
}

export const getRedeemableTokensVendingappAppIdTokensGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getRedeemableTokensVendingappAppIdTokensGetResponse> => {
  const res = await fetch(
    getGetRedeemableTokensVendingappAppIdTokensGetUrl(appId),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getRedeemableTokensVendingappAppIdTokensGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getRedeemableTokensVendingappAppIdTokensGetResponse
}

export const getGetRedeemableTokensVendingappAppIdTokensGetQueryKey = (
  appId?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/tokens`,
  ] as const
}

export const getGetRedeemableTokensVendingappAppIdTokensGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRedeemableTokensVendingappAppIdTokensGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>
  > = ({ signal }) =>
    getRedeemableTokensVendingappAppIdTokensGet(appId, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRedeemableTokensVendingappAppIdTokensGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>
  >
export type GetRedeemableTokensVendingappAppIdTokensGetQueryError =
  | null
  | null
  | null
  | null
  | null

export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = null | null | null | null | null,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Redeemable Tokens
 */

export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = null | null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRedeemableTokensVendingappAppIdTokensGetQueryOptions(appId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create some tokens for the given appid.

The calling user must own the vending config for this application
 * @summary Create Tokens
 */
export type createTokensVendingappAppIdTokensPostResponse200 = {
  data: TokenModel[]
  status: 200
}

export type createTokensVendingappAppIdTokensPostResponse401 = {
  data: null
  status: 401
}

export type createTokensVendingappAppIdTokensPostResponse403 = {
  data: null
  status: 403
}

export type createTokensVendingappAppIdTokensPostResponse404 = {
  data: null
  status: 404
}

export type createTokensVendingappAppIdTokensPostResponse422 = {
  data: null
  status: 422
}

export type createTokensVendingappAppIdTokensPostResponse500 = {
  data: null
  status: 500
}

export type createTokensVendingappAppIdTokensPostResponseComposite =
  | createTokensVendingappAppIdTokensPostResponse200
  | createTokensVendingappAppIdTokensPostResponse401
  | createTokensVendingappAppIdTokensPostResponse403
  | createTokensVendingappAppIdTokensPostResponse404
  | createTokensVendingappAppIdTokensPostResponse422
  | createTokensVendingappAppIdTokensPostResponse500

export type createTokensVendingappAppIdTokensPostResponse =
  createTokensVendingappAppIdTokensPostResponseComposite & {
    headers: Headers
  }

export const getCreateTokensVendingappAppIdTokensPostUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/tokens`
}

export const createTokensVendingappAppIdTokensPost = async (
  appId: string,
  createTokensVendingappAppIdTokensPostBody: string[],
  options?: RequestInit,
): Promise<createTokensVendingappAppIdTokensPostResponse> => {
  const res = await fetch(getCreateTokensVendingappAppIdTokensPostUrl(appId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createTokensVendingappAppIdTokensPostBody),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createTokensVendingappAppIdTokensPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createTokensVendingappAppIdTokensPostResponse
}

export const getCreateTokensVendingappAppIdTokensPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["createTokensVendingappAppIdTokensPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
    { appId: string; data: string[] }
  > = (props) => {
    const { appId, data } = props ?? {}

    return createTokensVendingappAppIdTokensPost(appId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTokensVendingappAppIdTokensPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>
>
export type CreateTokensVendingappAppIdTokensPostMutationBody = string[]
export type CreateTokensVendingappAppIdTokensPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Create Tokens
 */
export const useCreateTokensVendingappAppIdTokensPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
      TError,
      { appId: string; data: string[] },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationOptions =
    getCreateTokensVendingappAppIdTokensPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Cancel a set of tokens
 * @summary Cancel Tokens
 */
export type cancelTokensVendingappAppIdTokensCancelPostResponse200 = {
  data: TokenCancellation[]
  status: 200
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse401 = {
  data: null
  status: 401
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse403 = {
  data: null
  status: 403
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse404 = {
  data: null
  status: 404
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse422 = {
  data: null
  status: 422
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse500 = {
  data: null
  status: 500
}

export type cancelTokensVendingappAppIdTokensCancelPostResponseComposite =
  | cancelTokensVendingappAppIdTokensCancelPostResponse200
  | cancelTokensVendingappAppIdTokensCancelPostResponse401
  | cancelTokensVendingappAppIdTokensCancelPostResponse403
  | cancelTokensVendingappAppIdTokensCancelPostResponse404
  | cancelTokensVendingappAppIdTokensCancelPostResponse422
  | cancelTokensVendingappAppIdTokensCancelPostResponse500

export type cancelTokensVendingappAppIdTokensCancelPostResponse =
  cancelTokensVendingappAppIdTokensCancelPostResponseComposite & {
    headers: Headers
  }

export const getCancelTokensVendingappAppIdTokensCancelPostUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/tokens/cancel`
}

export const cancelTokensVendingappAppIdTokensCancelPost = async (
  appId: string,
  cancelTokensVendingappAppIdTokensCancelPostBody: string[],
  options?: RequestInit,
): Promise<cancelTokensVendingappAppIdTokensCancelPostResponse> => {
  const res = await fetch(
    getCancelTokensVendingappAppIdTokensCancelPostUrl(appId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(cancelTokensVendingappAppIdTokensCancelPostBody),
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: cancelTokensVendingappAppIdTokensCancelPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as cancelTokensVendingappAppIdTokensCancelPostResponse
}

export const getCancelTokensVendingappAppIdTokensCancelPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["cancelTokensVendingappAppIdTokensCancelPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
    { appId: string; data: string[] }
  > = (props) => {
    const { appId, data } = props ?? {}

    return cancelTokensVendingappAppIdTokensCancelPost(
      appId,
      data,
      fetchOptions,
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type CancelTokensVendingappAppIdTokensCancelPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>
  >
export type CancelTokensVendingappAppIdTokensCancelPostMutationBody = string[]
export type CancelTokensVendingappAppIdTokensCancelPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Cancel Tokens
 */
export const useCancelTokensVendingappAppIdTokensCancelPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
      TError,
      { appId: string; data: string[] },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationOptions =
    getCancelTokensVendingappAppIdTokensCancelPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * This redeems the given token for the logged in user.

If the logged in user already owns the app then the token will not be redeemed
 * @summary Redeem Token
 */
export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse200 = {
  data: RedemptionResult
  status: 200
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse401 = {
  data: null
  status: 401
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse403 = {
  data: null
  status: 403
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse404 = {
  data: null
  status: 404
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse422 = {
  data: null
  status: 422
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse500 = {
  data: null
  status: 500
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponseComposite =
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse200
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse401
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse403
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse404
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse422
  | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse500

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse =
  redeemTokenVendingappAppIdTokensRedeemTokenPostResponseComposite & {
    headers: Headers
  }

export const getRedeemTokenVendingappAppIdTokensRedeemTokenPostUrl = (
  appId: string,
  token: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/tokens/redeem/${token}`
}

export const redeemTokenVendingappAppIdTokensRedeemTokenPost = async (
  appId: string,
  token: string,
  options?: RequestInit,
): Promise<redeemTokenVendingappAppIdTokensRedeemTokenPostResponse> => {
  const res = await fetch(
    getRedeemTokenVendingappAppIdTokensRedeemTokenPostUrl(appId, token),
    {
      ...options,
      method: "POST",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: redeemTokenVendingappAppIdTokensRedeemTokenPostResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as redeemTokenVendingappAppIdTokensRedeemTokenPostResponse
}

export const getRedeemTokenVendingappAppIdTokensRedeemTokenPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
      >,
      TError,
      { appId: string; token: string },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>>,
    TError,
    { appId: string; token: string },
    TContext
  > => {
    const mutationKey = ["redeemTokenVendingappAppIdTokensRedeemTokenPost"]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
      >,
      { appId: string; token: string }
    > = (props) => {
      const { appId, token } = props ?? {}

      return redeemTokenVendingappAppIdTokensRedeemTokenPost(
        appId,
        token,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type RedeemTokenVendingappAppIdTokensRedeemTokenPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>>
  >

export type RedeemTokenVendingappAppIdTokensRedeemTokenPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Redeem Token
 */
export const useRedeemTokenVendingappAppIdTokensRedeemTokenPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
      >,
      TError,
      { appId: string; token: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>>,
  TError,
  { appId: string; token: string },
  TContext
> => {
  const mutationOptions =
    getRedeemTokenVendingappAppIdTokensRedeemTokenPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * This determines the vending info for the app and returns it
 * @summary App Info
 */
export type appInfoVendingappAppIdInfoGetResponse200 = {
  data: VendingApplicationInformation
  status: 200
}

export type appInfoVendingappAppIdInfoGetResponse401 = {
  data: null
  status: 401
}

export type appInfoVendingappAppIdInfoGetResponse404 = {
  data: null
  status: 404
}

export type appInfoVendingappAppIdInfoGetResponse422 = {
  data: null
  status: 422
}

export type appInfoVendingappAppIdInfoGetResponse500 = {
  data: null
  status: 500
}

export type appInfoVendingappAppIdInfoGetResponseComposite =
  | appInfoVendingappAppIdInfoGetResponse200
  | appInfoVendingappAppIdInfoGetResponse401
  | appInfoVendingappAppIdInfoGetResponse404
  | appInfoVendingappAppIdInfoGetResponse422
  | appInfoVendingappAppIdInfoGetResponse500

export type appInfoVendingappAppIdInfoGetResponse =
  appInfoVendingappAppIdInfoGetResponseComposite & {
    headers: Headers
  }

export const getAppInfoVendingappAppIdInfoGetUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/info`
}

export const appInfoVendingappAppIdInfoGet = async (
  appId: string,
  options?: RequestInit,
): Promise<appInfoVendingappAppIdInfoGetResponse> => {
  const res = await fetch(getAppInfoVendingappAppIdInfoGetUrl(appId), {
    ...options,
    method: "GET",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: appInfoVendingappAppIdInfoGetResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as appInfoVendingappAppIdInfoGetResponse
}

export const getAppInfoVendingappAppIdInfoGetQueryKey = (appId?: string) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/vendingapp/${appId}/info`,
  ] as const
}

export const getAppInfoVendingappAppIdInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAppInfoVendingappAppIdInfoGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
  > = ({ signal }) =>
    appInfoVendingappAppIdInfoGet(appId, { signal, ...fetchOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppInfoVendingappAppIdInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
>
export type AppInfoVendingappAppIdInfoGetQueryError = null | null | null | null

export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = null | null | null | null,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
          TError,
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
          TError,
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary App Info
 */

export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = null | null | null | null,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAppInfoVendingappAppIdInfoGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
