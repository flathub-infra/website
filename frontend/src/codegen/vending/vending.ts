/**
 * Generated by orval üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"
import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"
import type {
  HTTPValidationError,
  ProposedPayment,
  RedemptionResult,
  TokenCancellation,
  TokenList,
  TokenModel,
  VendingApplicationInformation,
  VendingConfig,
  VendingOnboardingRequest,
  VendingOutput,
  VendingRedirect,
  VendingSetup,
  VendingSetupRequest,
  VendingStatus,
} from ".././model"

/**
 * Retrieve the vending status of the logged in user.

This will return `201` if the logged in user has never begun the onboarding
flow to be a vendor on Flathub.
 * @summary Status
 */
export const statusVendingStatusGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingStatus>> => {
  return axios.get(`/vending/status`, options)
}

export const getStatusVendingStatusGetQueryKey = () => {
  return [`/vending/status`] as const
}

export const getStatusVendingStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStatusVendingStatusGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statusVendingStatusGet>>
  > = ({ signal }) => statusVendingStatusGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statusVendingStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatusVendingStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof statusVendingStatusGet>>
>
export type StatusVendingStatusGetQueryError = AxiosError<unknown>

export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof statusVendingStatusGet>>,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Status
 */

export function useStatusVendingStatusGet<
  TData = Awaited<ReturnType<typeof statusVendingStatusGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statusVendingStatusGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getStatusVendingStatusGetQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Start or continue the onboarding process.
 * @summary Start Onboarding
 */
export const startOnboardingVendingStatusOnboardingPost = (
  vendingOnboardingRequest: VendingOnboardingRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingRedirect>> => {
  return axios.post(
    `/vending/status/onboarding`,
    vendingOnboardingRequest,
    options,
  )
}

export const getStartOnboardingVendingStatusOnboardingPostMutationOptions = <
  TData = Awaited<
    ReturnType<typeof startOnboardingVendingStatusOnboardingPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: VendingOnboardingRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationKey = ["startOnboardingVendingStatusOnboardingPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>,
    { data: VendingOnboardingRequest }
  > = (props) => {
    const { data } = props ?? {}

    return startOnboardingVendingStatusOnboardingPost(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: VendingOnboardingRequest },
    TContext
  >
}

export type StartOnboardingVendingStatusOnboardingPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof startOnboardingVendingStatusOnboardingPost>>
  >
export type StartOnboardingVendingStatusOnboardingPostMutationBody =
  VendingOnboardingRequest
export type StartOnboardingVendingStatusOnboardingPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Start Onboarding
 */
export const useStartOnboardingVendingStatusOnboardingPost = <
  TData = Awaited<
    ReturnType<typeof startOnboardingVendingStatusOnboardingPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: VendingOnboardingRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { data: VendingOnboardingRequest },
  TContext
> => {
  const mutationOptions =
    getStartOnboardingVendingStatusOnboardingPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Retrieve a link to the logged in user's Stripe express dashboard.

The user must be logged in and must have onboarded.
 * @summary Get Dashboard Link
 */
export const getDashboardLinkVendingStatusDashboardlinkGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingRedirect>> => {
  return axios.get(`/vending/status/dashboardlink`, options)
}

export const getGetDashboardLinkVendingStatusDashboardlinkGetQueryKey = () => {
  return [`/vending/status/dashboardlink`] as const
}

export const getGetDashboardLinkVendingStatusDashboardlinkGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetDashboardLinkVendingStatusDashboardlinkGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>
  > = ({ signal }) =>
    getDashboardLinkVendingStatusDashboardlinkGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardLinkVendingStatusDashboardlinkGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>
  >
export type GetDashboardLinkVendingStatusDashboardlinkGetQueryError =
  AxiosError<unknown>

export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<
          ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
        >,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Dashboard Link
 */

export function useGetDashboardLinkVendingStatusDashboardlinkGet<
  TData = Awaited<
    ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>
  >,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkVendingStatusDashboardlinkGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetDashboardLinkVendingStatusDashboardlinkGetQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve the configuration values needed to calculate application
vending splits client-side.

Configuration includes:
- Fee values
- Platform values
 * @summary Get Global Vending Config
 */
export const getGlobalVendingConfigVendingConfigGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingConfig>> => {
  return axios.get(`/vending/config`, options)
}

export const getGetGlobalVendingConfigVendingConfigGetQueryKey = () => {
  return [`/vending/config`] as const
}

export const getGetGlobalVendingConfigVendingConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetGlobalVendingConfigVendingConfigGetQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
  > = ({ signal }) =>
    getGlobalVendingConfigVendingConfigGet({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGlobalVendingConfigVendingConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>
>
export type GetGlobalVendingConfigVendingConfigGetQueryError =
  AxiosError<unknown>

export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
        TError,
        TData
      >,
      "initialData"
    >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Global Vending Config
 */

export function useGetGlobalVendingConfigVendingConfigGet<
  TData = Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getGlobalVendingConfigVendingConfigGet>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetGlobalVendingConfigVendingConfigGetQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve the vending status for a given application.
 * @summary Get App Vending Setup
 */
export const getAppVendingSetupVendingappAppIdSetupGet = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingSetup>> => {
  return axios.get(`/vendingapp/${appId}/setup`, options)
}

export const getGetAppVendingSetupVendingappAppIdSetupGetQueryKey = (
  appId: string,
) => {
  return [`/vendingapp/${appId}/setup`] as const
}

export const getGetAppVendingSetupVendingappAppIdSetupGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetAppVendingSetupVendingappAppIdSetupGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
  > = ({ signal }) =>
    getAppVendingSetupVendingappAppIdSetupGet(appId, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppVendingSetupVendingappAppIdSetupGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>
>
export type GetAppVendingSetupVendingappAppIdSetupGetQueryError =
  AxiosError<HTTPValidationError>

export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get App Vending Setup
 */

export function useGetAppVendingSetupVendingappAppIdSetupGet<
  TData = Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppVendingSetupVendingappAppIdSetupGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAppVendingSetupVendingappAppIdSetupGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create/update the vending status for a given application.  Returns an error
if the appid is not known, or if it's already set up for vending with a
user other than the one calling this API.

If you do not have the right to set the vending status for this application
then you will also be refused.

In addition, if any of the currency or amount values constraints are violated
then you will get an error
 * @summary Post App Vending Setup
 */
export const postAppVendingSetupVendingappAppIdSetupPost = (
  appId: string,
  vendingSetupRequest: VendingSetupRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingSetup>> => {
  return axios.post(`/vendingapp/${appId}/setup`, vendingSetupRequest, options)
}

export const getPostAppVendingSetupVendingappAppIdSetupPostMutationOptions = <
  TData = Awaited<
    ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: VendingSetupRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationKey = ["postAppVendingSetupVendingappAppIdSetupPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>,
    { appId: string; data: VendingSetupRequest }
  > = (props) => {
    const { appId, data } = props ?? {}

    return postAppVendingSetupVendingappAppIdSetupPost(
      appId,
      data,
      axiosOptions,
    )
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { appId: string; data: VendingSetupRequest },
    TContext
  >
}

export type PostAppVendingSetupVendingappAppIdSetupPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>>
  >
export type PostAppVendingSetupVendingappAppIdSetupPostMutationBody =
  VendingSetupRequest
export type PostAppVendingSetupVendingappAppIdSetupPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Post App Vending Setup
 */
export const usePostAppVendingSetupVendingappAppIdSetupPost = <
  TData = Awaited<
    ReturnType<typeof postAppVendingSetupVendingappAppIdSetupPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: VendingSetupRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { appId: string; data: VendingSetupRequest },
  TContext
> => {
  const mutationOptions =
    getPostAppVendingSetupVendingappAppIdSetupPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Construct a transaction for the given application with the proposed payment.
If the proposed payment is unacceptable then an error will be returned.
If the user is not logged in, then an error will be returned.

Otherwise a transaction will be created and the information about it will be
returned in the output of the call.
 * @summary Post App Vending Status
 */
export const postAppVendingStatusVendingappAppIdPost = (
  appId: string,
  proposedPayment: ProposedPayment,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingOutput>> => {
  return axios.post(`/vendingapp/${appId}`, proposedPayment, options)
}

export const getPostAppVendingStatusVendingappAppIdPostMutationOptions = <
  TData = Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: ProposedPayment },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationKey = ["postAppVendingStatusVendingappAppIdPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
    { appId: string; data: ProposedPayment }
  > = (props) => {
    const { appId, data } = props ?? {}

    return postAppVendingStatusVendingappAppIdPost(appId, data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { appId: string; data: ProposedPayment },
    TContext
  >
}

export type PostAppVendingStatusVendingappAppIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>
>
export type PostAppVendingStatusVendingappAppIdPostMutationBody =
  ProposedPayment
export type PostAppVendingStatusVendingappAppIdPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Post App Vending Status
 */
export const usePostAppVendingStatusVendingappAppIdPost = <
  TData = Awaited<ReturnType<typeof postAppVendingStatusVendingappAppIdPost>>,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: ProposedPayment },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { appId: string; data: ProposedPayment },
  TContext
> => {
  const mutationOptions =
    getPostAppVendingStatusVendingappAppIdPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Retrieve the redeemable tokens for the given application.

The caller must have control of the app at some level

For now, there is no pagination or filtering, all tokens will be returned
 * @summary Get Redeemable Tokens
 */
export const getRedeemableTokensVendingappAppIdTokensGet = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenList>> => {
  return axios.get(`/vendingapp/${appId}/tokens`, options)
}

export const getGetRedeemableTokensVendingappAppIdTokensGetQueryKey = (
  appId: string,
) => {
  return [`/vendingapp/${appId}/tokens`] as const
}

export const getGetRedeemableTokensVendingappAppIdTokensGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetRedeemableTokensVendingappAppIdTokensGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>
  > = ({ signal }) =>
    getRedeemableTokensVendingappAppIdTokensGet(appId, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRedeemableTokensVendingappAppIdTokensGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>
  >
export type GetRedeemableTokensVendingappAppIdTokensGetQueryError =
  AxiosError<HTTPValidationError>

export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
          >,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Redeemable Tokens
 */

export function useGetRedeemableTokensVendingappAppIdTokensGet<
  TData = Awaited<
    ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>
  >,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRedeemableTokensVendingappAppIdTokensGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetRedeemableTokensVendingappAppIdTokensGetQueryOptions(appId, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create some tokens for the given appid.

The calling user must own the vending config for this application
 * @summary Create Tokens
 */
export const createTokensVendingappAppIdTokensPost = (
  appId: string,
  createTokensVendingappAppIdTokensPostBody: string[],
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenModel[]>> => {
  return axios.post(
    `/vendingapp/${appId}/tokens`,
    createTokensVendingappAppIdTokensPostBody,
    options,
  )
}

export const getCreateTokensVendingappAppIdTokensPostMutationOptions = <
  TData = Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationKey = ["createTokensVendingappAppIdTokensPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
    { appId: string; data: string[] }
  > = (props) => {
    const { appId, data } = props ?? {}

    return createTokensVendingappAppIdTokensPost(appId, data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
}

export type CreateTokensVendingappAppIdTokensPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>
>
export type CreateTokensVendingappAppIdTokensPostMutationBody = string[]
export type CreateTokensVendingappAppIdTokensPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Create Tokens
 */
export const useCreateTokensVendingappAppIdTokensPost = <
  TData = Awaited<ReturnType<typeof createTokensVendingappAppIdTokensPost>>,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationOptions =
    getCreateTokensVendingappAppIdTokensPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Cancel a set of tokens
 * @summary Cancel Tokens
 */
export const cancelTokensVendingappAppIdTokensCancelPost = (
  appId: string,
  cancelTokensVendingappAppIdTokensCancelPostBody: string[],
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenCancellation[]>> => {
  return axios.post(
    `/vendingapp/${appId}/tokens/cancel`,
    cancelTokensVendingappAppIdTokensCancelPostBody,
    options,
  )
}

export const getCancelTokensVendingappAppIdTokensCancelPostMutationOptions = <
  TData = Awaited<
    ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const mutationKey = ["cancelTokensVendingappAppIdTokensCancelPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>,
    { appId: string; data: string[] }
  > = (props) => {
    const { appId, data } = props ?? {}

    return cancelTokensVendingappAppIdTokensCancelPost(
      appId,
      data,
      axiosOptions,
    )
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
}

export type CancelTokensVendingappAppIdTokensCancelPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>>
  >
export type CancelTokensVendingappAppIdTokensCancelPostMutationBody = string[]
export type CancelTokensVendingappAppIdTokensCancelPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Cancel Tokens
 */
export const useCancelTokensVendingappAppIdTokensCancelPost = <
  TData = Awaited<
    ReturnType<typeof cancelTokensVendingappAppIdTokensCancelPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; data: string[] },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { appId: string; data: string[] },
  TContext
> => {
  const mutationOptions =
    getCancelTokensVendingappAppIdTokensCancelPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * This redeems the given token for the logged in user.

If the logged in user already owns the app then the token will not be redeemed
 * @summary Redeem Token
 */
export const redeemTokenVendingappAppIdTokensRedeemTokenPost = (
  appId: string,
  token: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RedemptionResult>> => {
  return axios.post(
    `/vendingapp/${appId}/tokens/redeem/${token}`,
    undefined,
    options,
  )
}

export const getRedeemTokenVendingappAppIdTokensRedeemTokenPostMutationOptions =
  <
    TData = Awaited<
      ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
    >,
    TError = AxiosError<HTTPValidationError>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      TData,
      TError,
      { appId: string; token: string },
      TContext
    >
    axios?: AxiosRequestConfig
  }) => {
    const mutationKey = ["redeemTokenVendingappAppIdTokensRedeemTokenPost"]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
      >,
      { appId: string; token: string }
    > = (props) => {
      const { appId, token } = props ?? {}

      return redeemTokenVendingappAppIdTokensRedeemTokenPost(
        appId,
        token,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions } as UseMutationOptions<
      TData,
      TError,
      { appId: string; token: string },
      TContext
    >
  }

export type RedeemTokenVendingappAppIdTokensRedeemTokenPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>>
  >

export type RedeemTokenVendingappAppIdTokensRedeemTokenPostMutationError =
  AxiosError<HTTPValidationError>

/**
 * @summary Redeem Token
 */
export const useRedeemTokenVendingappAppIdTokensRedeemTokenPost = <
  TData = Awaited<
    ReturnType<typeof redeemTokenVendingappAppIdTokensRedeemTokenPost>
  >,
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { appId: string; token: string },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  TData,
  TError,
  { appId: string; token: string },
  TContext
> => {
  const mutationOptions =
    getRedeemTokenVendingappAppIdTokensRedeemTokenPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * This determines the vending info for the app and returns it
 * @summary App Info
 */
export const appInfoVendingappAppIdInfoGet = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VendingApplicationInformation>> => {
  return axios.get(`/vendingapp/${appId}/info`, options)
}

export const getAppInfoVendingappAppIdInfoGetQueryKey = (appId: string) => {
  return [`/vendingapp/${appId}/info`] as const
}

export const getAppInfoVendingappAppIdInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAppInfoVendingappAppIdInfoGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
  > = ({ signal }) =>
    appInfoVendingappAppIdInfoGet(appId, { signal, ...axiosOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppInfoVendingappAppIdInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>
>
export type AppInfoVendingappAppIdInfoGetQueryError =
  AxiosError<HTTPValidationError>

export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
          TError,
          TData
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary App Info
 */

export function useAppInfoVendingappAppIdInfoGet<
  TData = Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appInfoVendingappAppIdInfoGet>>,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAppInfoVendingappAppIdInfoGetQueryOptions(
    appId,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
