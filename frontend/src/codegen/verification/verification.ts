/**
 * Generated by orval 🍺
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import type {
  ArchiveRequest,
  AvailableMethods,
  ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,
  GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  HTTPValidationError,
  LinkResponse,
  SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,
  VerificationStatus,
  VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200,
  VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,
  WebsiteVerificationResult,
  WebsiteVerificationToken,
} from ".././model"

/**
 * Gets the verification status of the given app.
 * @summary Get Verification Status
 */
export type getVerificationStatusVerificationAppIdStatusGetResponse200 = {
  data: VerificationStatus
  status: 200
}

export type getVerificationStatusVerificationAppIdStatusGetResponse404 = {
  data: null
  status: 404
}

export type getVerificationStatusVerificationAppIdStatusGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getVerificationStatusVerificationAppIdStatusGetResponseComposite =
  | getVerificationStatusVerificationAppIdStatusGetResponse200
  | getVerificationStatusVerificationAppIdStatusGetResponse404
  | getVerificationStatusVerificationAppIdStatusGetResponse422

export type getVerificationStatusVerificationAppIdStatusGetResponse =
  getVerificationStatusVerificationAppIdStatusGetResponseComposite & {
    headers: Headers
  }

export const getGetVerificationStatusVerificationAppIdStatusGetUrl = (
  appId: string,
) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/status`
}

export const getVerificationStatusVerificationAppIdStatusGet = async (
  appId: string,
  options?: RequestInit,
): Promise<getVerificationStatusVerificationAppIdStatusGetResponse> => {
  const res = await fetch(
    getGetVerificationStatusVerificationAppIdStatusGetUrl(appId),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getVerificationStatusVerificationAppIdStatusGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getVerificationStatusVerificationAppIdStatusGetResponse
}

export const getGetVerificationStatusVerificationAppIdStatusGetQueryKey = (
  appId?: string,
) => {
  return [
    `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/status`,
  ] as const
}

export const getGetVerificationStatusVerificationAppIdStatusGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = null | HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerificationStatusVerificationAppIdStatusGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>
  > = ({ signal }) =>
    getVerificationStatusVerificationAppIdStatusGet(appId, {
      signal,
      ...fetchOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVerificationStatusVerificationAppIdStatusGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>
  >
export type GetVerificationStatusVerificationAppIdStatusGetQueryError =
  null | HTTPValidationError

export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = null | HTTPValidationError,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = null | HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = null | HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Verification Status
 */

export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = null | HTTPValidationError,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetVerificationStatusVerificationAppIdStatusGetQueryOptions(
      appId,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Gets the ways an app may be verified.
 * @summary Get Available Methods
 */
export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse200 =
  {
    data: AvailableMethods
    status: 200
  }

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse401 =
  {
    data: null
    status: 401
  }

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse404 =
  {
    data: null
    status: 404
  }

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse422 =
  {
    data: HTTPValidationError
    status: 422
  }

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse500 =
  {
    data: null
    status: 500
  }

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseComposite =

    | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse200
    | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse401
    | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse404
    | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse422
    | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse500

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse =
  getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseComposite & {
    headers: Headers
  }

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetUrl = (
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/available-methods?${stringifiedParams}`
    : `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/available-methods`
}

export const getAvailableMethodsVerificationAppIdAvailableMethodsGet = async (
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: RequestInit,
): Promise<getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse> => {
  const res = await fetch(
    getGetAvailableMethodsVerificationAppIdAvailableMethodsGetUrl(
      appId,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  )

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse["data"] =
    body ? JSON.parse(body) : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse
}

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryKey =
  (
    appId?: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  ) => {
    return [
      `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/available-methods`,
      ...(params ? [params] : []),
    ] as const
  }

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
    >,
    TError = null | null | HTTPValidationError | null,
  >(
    appId: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          TData
        >
      >
      fetch?: RequestInit
    },
  ) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryKey(
        appId,
        params,
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
        >
      >
    > = ({ signal }) =>
      getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId, params, {
        signal,
        ...fetchOptions,
      })

    return {
      queryKey,
      queryFn,
      enabled: !!appId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
    >
  >
export type GetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryError =
  null | null | HTTPValidationError | null

export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = null | null | HTTPValidationError | null,
>(
  appId: string,
  params:
    | undefined
    | GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = null | null | HTTPValidationError | null,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = null | null | HTTPValidationError | null,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Available Methods
 */

export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = null | null | HTTPValidationError | null,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryOptions(
      appId,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * If the current account is eligible to verify the given account via SSO, and the app is not already verified by
someone else, marks the app as verified.
 * @summary Verify By Login Provider
 */
export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse200 =
  {
    data: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200
    status: 200
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse401 =
  {
    data: null
    status: 401
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse403 =
  {
    data: null
    status: 403
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse404 =
  {
    data: null
    status: 404
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse422 =
  {
    data: null
    status: 422
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse500 =
  {
    data: null
    status: 500
  }

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseComposite =

    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse200
    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse401
    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse403
    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse404
    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse422
    | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse500

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse =
  verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseComposite & {
    headers: Headers
  }

export const getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostUrl =
  (
    appId: string,
    params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,
  ) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(key, value === null ? "null" : value.toString())
      }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
      ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/verify-by-login-provider?${stringifiedParams}`
      : `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/verify-by-login-provider`
  }

export const verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost =
  async (
    appId: string,
    params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,
    options?: RequestInit,
  ): Promise<verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse> => {
    const res = await fetch(
      getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostUrl(
        appId,
        params,
      ),
      {
        ...options,
        method: "POST",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse
  }

export const getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
        >
      >,
      TError,
      {
        appId: string
        params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
      },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >,
    TError,
    {
      appId: string
      params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost",
    ]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
        >
      >,
      {
        appId: string
        params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
        appId,
        params,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >
  >

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationError =
  null | null | null | null | null

/**
 * @summary Verify By Login Provider
 */
export const useVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost =
  <TError = null | null | null | null | null, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
          >
        >,
        TError,
        {
          appId: string
          params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
        },
        TContext
      >
      fetch?: RequestInit
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >,
    TError,
    {
      appId: string
      params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * Returns the URL to request access to the organization so we can verify the user's membership.
 * @summary Request Organization Access Github
 */
export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse200 =
  {
    data: LinkResponse
    status: 200
  }

export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse500 =
  {
    data: null
    status: 500
  }

export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseComposite =

    | requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse200
    | requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse500

export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse =
  requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseComposite & {
    headers: Headers
  }

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetUrl =
  () => {
    return `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/request-organization-access/github`
  }

export const requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet =
  async (
    options?: RequestInit,
  ): Promise<requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse> => {
    const res = await fetch(
      getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetUrl(),
      {
        ...options,
        method: "GET",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse
  }

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryKey =
  () => {
    return [
      `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/request-organization-access/github`,
    ] as const
  }

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
      >
    >,
    TError = null,
  >(options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  }) => {
    const { query: queryOptions, fetch: fetchOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryKey()

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
        >
      >
    > = ({ signal }) =>
      requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
        { signal, ...fetchOptions },
      )

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type RequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
      >
    >
  >
export type RequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryError =
  null

export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >
        >,
        "initialData"
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Request Organization Access Github
 */

export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryOptions(
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a token for the user to verify the app via website.
 * @summary Setup Website Verification
 */
export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse200 =
  {
    data: WebsiteVerificationToken
    status: 200
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse401 =
  {
    data: null
    status: 401
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse403 =
  {
    data: null
    status: 403
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse404 =
  {
    data: null
    status: 404
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse422 =
  {
    data: null
    status: 422
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse500 =
  {
    data: null
    status: 500
  }

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseComposite =

    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse200
    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse401
    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse403
    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse404
    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse422
    | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse500

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse =
  setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseComposite & {
    headers: Headers
  }

export const getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostUrl =
  (
    appId: string,
    params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,
  ) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(key, value === null ? "null" : value.toString())
      }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
      ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/setup-website-verification?${stringifiedParams}`
      : `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/setup-website-verification`
  }

export const setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost =
  async (
    appId: string,
    params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,
    options?: RequestInit,
  ): Promise<setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse> => {
    const res = await fetch(
      getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostUrl(
        appId,
        params,
      ),
      {
        ...options,
        method: "POST",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse
  }

export const getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
        >
      >,
      TError,
      {
        appId: string
        params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
      },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost",
    ]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
        >
      >,
      {
        appId: string
        params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
        appId,
        params,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >
  >

export type SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationError =
  null | null | null | null | null

/**
 * @summary Setup Website Verification
 */
export const useSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost =
  <TError = null | null | null | null | null, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
          >
        >,
        TError,
        {
          appId: string
          params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
        },
        TContext
      >
      fetch?: RequestInit
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * Checks website verification, and if it succeeds, marks the app as verified for the current account.
 * @summary Confirm Website Verification
 */
export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse200 =
  {
    data: WebsiteVerificationResult
    status: 200
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse401 =
  {
    data: null
    status: 401
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse403 =
  {
    data: null
    status: 403
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse404 =
  {
    data: null
    status: 404
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse422 =
  {
    data: null
    status: 422
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse500 =
  {
    data: null
    status: 500
  }

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseComposite =

    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse200
    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse401
    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse403
    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse404
    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse422
    | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse500

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse =
  confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseComposite & {
    headers: Headers
  }

export const getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostUrl =
  (
    appId: string,
    params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,
  ) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(key, value === null ? "null" : value.toString())
      }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
      ? `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/confirm-website-verification?${stringifiedParams}`
      : `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/confirm-website-verification`
  }

export const confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost =
  async (
    appId: string,
    params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,
    options?: RequestInit,
  ): Promise<confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse> => {
    const res = await fetch(
      getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostUrl(
        appId,
        params,
      ),
      {
        ...options,
        method: "POST",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse
  }

export const getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
        >
      >,
      TError,
      {
        appId: string
        params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
      },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost",
    ]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
        >
      >,
      {
        appId: string
        params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
        appId,
        params,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >
  >

export type ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationError =
  null | null | null | null | null

/**
 * @summary Confirm Website Verification
 */
export const useConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost =
  <TError = null | null | null | null | null, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
          >
        >,
        TError,
        {
          appId: string
          params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
        },
        TContext
      >
      fetch?: RequestInit
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * If the current account has verified the given app, mark it as no longer verified.
 * @summary Unverify
 */
export type unverifyVerificationAppIdUnverifyPostResponse204 = {
  data: null
  status: 204
}

export type unverifyVerificationAppIdUnverifyPostResponse401 = {
  data: null
  status: 401
}

export type unverifyVerificationAppIdUnverifyPostResponse403 = {
  data: null
  status: 403
}

export type unverifyVerificationAppIdUnverifyPostResponse404 = {
  data: null
  status: 404
}

export type unverifyVerificationAppIdUnverifyPostResponse422 = {
  data: null
  status: 422
}

export type unverifyVerificationAppIdUnverifyPostResponse500 = {
  data: null
  status: 500
}

export type unverifyVerificationAppIdUnverifyPostResponseComposite =
  | unverifyVerificationAppIdUnverifyPostResponse204
  | unverifyVerificationAppIdUnverifyPostResponse401
  | unverifyVerificationAppIdUnverifyPostResponse403
  | unverifyVerificationAppIdUnverifyPostResponse404
  | unverifyVerificationAppIdUnverifyPostResponse422
  | unverifyVerificationAppIdUnverifyPostResponse500

export type unverifyVerificationAppIdUnverifyPostResponse =
  unverifyVerificationAppIdUnverifyPostResponseComposite & {
    headers: Headers
  }

export const getUnverifyVerificationAppIdUnverifyPostUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/unverify`
}

export const unverifyVerificationAppIdUnverifyPost = async (
  appId: string,
  options?: RequestInit,
): Promise<unverifyVerificationAppIdUnverifyPostResponse> => {
  const res = await fetch(getUnverifyVerificationAppIdUnverifyPostUrl(appId), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: unverifyVerificationAppIdUnverifyPostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as unverifyVerificationAppIdUnverifyPostResponse
}

export const getUnverifyVerificationAppIdUnverifyPostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
    TError,
    { appId: string },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationKey = ["unverifyVerificationAppIdUnverifyPost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
    { appId: string }
  > = (props) => {
    const { appId } = props ?? {}

    return unverifyVerificationAppIdUnverifyPost(appId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UnverifyVerificationAppIdUnverifyPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>
>

export type UnverifyVerificationAppIdUnverifyPostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Unverify
 */
export const useUnverifyVerificationAppIdUnverifyPost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
      TError,
      { appId: string },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationOptions =
    getUnverifyVerificationAppIdUnverifyPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Switch To Direct Upload
 */
export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse204 =
  {
    data: null
    status: 204
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse401 =
  {
    data: null
    status: 401
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse403 =
  {
    data: null
    status: 403
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse404 =
  {
    data: null
    status: 404
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse422 =
  {
    data: null
    status: 422
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse500 =
  {
    data: null
    status: 500
  }

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseComposite =

    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse204
    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse401
    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse403
    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse404
    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse422
    | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse500

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse =
  switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseComposite & {
    headers: Headers
  }

export const getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostUrl =
  (appId: string) => {
    return `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/switch_to_direct_upload`
  }

export const switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost =
  async (
    appId: string,
    options?: RequestInit,
  ): Promise<switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse> => {
    const res = await fetch(
      getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostUrl(
        appId,
      ),
      {
        ...options,
        method: "POST",
      },
    )

    const body = [204, 205, 304].includes(res.status) ? null : await res.text()
    const data: switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse["data"] =
      body ? JSON.parse(body) : {}

    return {
      data,
      status: res.status,
      headers: res.headers,
    } as switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse
  }

export const getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationOptions =
  <TError = null | null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
        >
      >,
      TError,
      { appId: string },
      TContext
    >
    fetch?: RequestInit
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >,
    TError,
    { appId: string },
    TContext
  > => {
    const mutationKey = [
      "switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost",
    ]
    const { mutation: mutationOptions, fetch: fetchOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, fetch: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
        >
      >,
      { appId: string }
    > = (props) => {
      const { appId } = props ?? {}

      return switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
        appId,
        fetchOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >
  >

export type SwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationError =
  null | null | null | null | null

/**
 * @summary Switch To Direct Upload
 */
export const useSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPost =
  <TError = null | null | null | null | null, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
          >
        >,
        TError,
        { appId: string },
        TContext
      >
      fetch?: RequestInit
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >,
    TError,
    { appId: string },
    TContext
  > => {
    const mutationOptions =
      getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * @summary Archive
 */
export type archiveVerificationAppIdArchivePostResponse204 = {
  data: null
  status: 204
}

export type archiveVerificationAppIdArchivePostResponse401 = {
  data: null
  status: 401
}

export type archiveVerificationAppIdArchivePostResponse403 = {
  data: null
  status: 403
}

export type archiveVerificationAppIdArchivePostResponse404 = {
  data: null
  status: 404
}

export type archiveVerificationAppIdArchivePostResponse422 = {
  data: null
  status: 422
}

export type archiveVerificationAppIdArchivePostResponse500 = {
  data: null
  status: 500
}

export type archiveVerificationAppIdArchivePostResponseComposite =
  | archiveVerificationAppIdArchivePostResponse204
  | archiveVerificationAppIdArchivePostResponse401
  | archiveVerificationAppIdArchivePostResponse403
  | archiveVerificationAppIdArchivePostResponse404
  | archiveVerificationAppIdArchivePostResponse422
  | archiveVerificationAppIdArchivePostResponse500

export type archiveVerificationAppIdArchivePostResponse =
  archiveVerificationAppIdArchivePostResponseComposite & {
    headers: Headers
  }

export const getArchiveVerificationAppIdArchivePostUrl = (appId: string) => {
  return `${process.env.NEXT_PUBLIC_API_BASE_URI}/verification/${appId}/archive`
}

export const archiveVerificationAppIdArchivePost = async (
  appId: string,
  archiveRequest: ArchiveRequest,
  options?: RequestInit,
): Promise<archiveVerificationAppIdArchivePostResponse> => {
  const res = await fetch(getArchiveVerificationAppIdArchivePostUrl(appId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(archiveRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: archiveVerificationAppIdArchivePostResponse["data"] = body
    ? JSON.parse(body)
    : {}

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as archiveVerificationAppIdArchivePostResponse
}

export const getArchiveVerificationAppIdArchivePostMutationOptions = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
    TError,
    { appId: string; data: ArchiveRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
  TError,
  { appId: string; data: ArchiveRequest },
  TContext
> => {
  const mutationKey = ["archiveVerificationAppIdArchivePost"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
    { appId: string; data: ArchiveRequest }
  > = (props) => {
    const { appId, data } = props ?? {}

    return archiveVerificationAppIdArchivePost(appId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ArchiveVerificationAppIdArchivePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>
>
export type ArchiveVerificationAppIdArchivePostMutationBody = ArchiveRequest
export type ArchiveVerificationAppIdArchivePostMutationError =
  | null
  | null
  | null
  | null
  | null

/**
 * @summary Archive
 */
export const useArchiveVerificationAppIdArchivePost = <
  TError = null | null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
      TError,
      { appId: string; data: ArchiveRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
  TError,
  { appId: string; data: ArchiveRequest },
  TContext
> => {
  const mutationOptions =
    getArchiveVerificationAppIdArchivePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
