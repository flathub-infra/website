/**
 * Generated by orval üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"

import qs from "qs"

import type {
  ArchiveRequest,
  AvailableMethods,
  ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,
  GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  GetVerificationStatusVerificationAppIdStatusGet200,
  HTTPValidationError,
  LinkResponse,
  SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,
  VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200,
  VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,
  WebsiteVerificationResult,
  WebsiteVerificationToken,
} from ".././model"

/**
 * Gets the verification status of the given app.
 * @summary Get Verification Status
 */
export const getVerificationStatusVerificationAppIdStatusGet = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<GetVerificationStatusVerificationAppIdStatusGet200>
> => {
  return axios.get(`/verification/${appId}/status`, options)
}

export const getGetVerificationStatusVerificationAppIdStatusGetQueryKey = (
  appId?: string,
) => {
  return [`/verification/${appId}/status`] as const
}

export const getGetVerificationStatusVerificationAppIdStatusGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerificationStatusVerificationAppIdStatusGetQueryKey(appId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>
  > = ({ signal }) =>
    getVerificationStatusVerificationAppIdStatusGet(appId, {
      signal,
      ...axiosOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVerificationStatusVerificationAppIdStatusGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>>
  >
export type GetVerificationStatusVerificationAppIdStatusGetQueryError =
  AxiosError<void | HTTPValidationError>

export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  appId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Verification Status
 */

export function useGetVerificationStatusVerificationAppIdStatusGet<
  TData = Awaited<
    ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
  >,
  TError = AxiosError<void | HTTPValidationError>,
>(
  appId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getVerificationStatusVerificationAppIdStatusGet>
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetVerificationStatusVerificationAppIdStatusGetQueryOptions(
      appId,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Gets the ways an app may be verified.
 * @summary Get Available Methods
 */
export const getAvailableMethodsVerificationAppIdAvailableMethodsGet = (
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<AvailableMethods>> => {
  return axios.get(`/verification/${appId}/available-methods`, {
    ...options,
    params: { ...params, ...options?.params },
    paramsSerializer: (params) =>
      qs.stringify(params, { arrayFormat: "repeat" }),
  })
}

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryKey =
  (
    appId?: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  ) => {
    return [
      `/verification/${appId}/available-methods`,
      ...(params ? [params] : []),
    ] as const
  }

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
    >,
    TError = AxiosError<void | void | HTTPValidationError | void>,
  >(
    appId: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          TData
        >
      >
      axios?: AxiosRequestConfig
    },
  ) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryKey(
        appId,
        params,
      )

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
        >
      >
    > = ({ signal }) =>
      getAvailableMethodsVerificationAppIdAvailableMethodsGet(appId, params, {
        signal,
        ...axiosOptions,
      })

    return {
      queryKey,
      queryFn,
      enabled: !!appId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type GetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
    >
  >
export type GetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryError =
  AxiosError<void | void | HTTPValidationError | void>

export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = AxiosError<void | void | HTTPValidationError | void>,
>(
  appId: string,
  params:
    | undefined
    | GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = AxiosError<void | void | HTTPValidationError | void>,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = AxiosError<void | void | HTTPValidationError | void>,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get Available Methods
 */

export function useGetAvailableMethodsVerificationAppIdAvailableMethodsGet<
  TData = Awaited<
    ReturnType<typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet>
  >,
  TError = AxiosError<void | void | HTTPValidationError | void>,
>(
  appId: string,
  params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAvailableMethodsVerificationAppIdAvailableMethodsGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getGetAvailableMethodsVerificationAppIdAvailableMethodsGetQueryOptions(
      appId,
      params,
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * If the current account is eligible to verify the given account via SSO, and the app is not already verified by
someone else, marks the app as verified.
 * @summary Verify By Login Provider
 */
export const verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost = (
  appId: string,
  params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200>
> => {
  return axios.post(
    `/verification/${appId}/verify-by-login-provider`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
      paramsSerializer: (params) =>
        qs.stringify(params, { arrayFormat: "repeat" }),
    },
  )
}

export const getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationOptions =
  <
    TError = AxiosError<void | void | void | void | void>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
        >
      >,
      TError,
      {
        appId: string
        params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
      },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >,
    TError,
    {
      appId: string
      params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost",
    ]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
        >
      >,
      {
        appId: string
        params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost(
        appId,
        params,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >
  >

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationError =
  AxiosError<void | void | void | void | void>

/**
 * @summary Verify By Login Provider
 */
export const useVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost =
  <TError = AxiosError<void | void | void | void | void>, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
          >
        >,
        TError,
        {
          appId: string
          params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
        },
        TContext
      >
      axios?: AxiosRequestConfig
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost
      >
    >,
    TError,
    {
      appId: string
      params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * Returns the URL to request access to the organization so we can verify the user's membership.
 * @summary Request Organization Access Github
 */
export const requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet =
  (options?: AxiosRequestConfig): Promise<AxiosResponse<LinkResponse>> => {
    return axios.get(
      `/verification/request-organization-access/github`,
      options,
    )
  }

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryKey =
  () => {
    return [`/verification/request-organization-access/github`] as const
  }

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
      >
    >,
    TError = AxiosError<void>,
  >(options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  }) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
      queryOptions?.queryKey ??
      getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryKey()

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
        >
      >
    > = ({ signal }) =>
      requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet(
        { signal, ...axiosOptions },
      )

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
  }

export type RequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
      >
    >
  >
export type RequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryError =
  AxiosError<void>

export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
            >
          >
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Request Organization Access Github
 */

export function useRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet<
  TData = Awaited<
    ReturnType<
      typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
    >
  >,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet
          >
        >,
        TError,
        TData
      >
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions =
    getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetQueryOptions(
      options,
    )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a token for the user to verify the app via website.
 * @summary Setup Website Verification
 */
export const setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost =
  (
    appId: string,
    params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<WebsiteVerificationToken>> => {
    return axios.post(
      `/verification/${appId}/setup-website-verification`,
      undefined,
      {
        ...options,
        params: { ...params, ...options?.params },
        paramsSerializer: (params) =>
          qs.stringify(params, { arrayFormat: "repeat" }),
      },
    )
  }

export const getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationOptions =
  <
    TError = AxiosError<void | void | void | void | void>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
        >
      >,
      TError,
      {
        appId: string
        params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
      },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost",
    ]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
        >
      >,
      {
        appId: string
        params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost(
        appId,
        params,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >
  >

export type SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationError =
  AxiosError<void | void | void | void | void>

/**
 * @summary Setup Website Verification
 */
export const useSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost =
  <TError = AxiosError<void | void | void | void | void>, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
          >
        >,
        TError,
        {
          appId: string
          params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
        },
        TContext
      >
      axios?: AxiosRequestConfig
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * Checks website verification, and if it succeeds, marks the app as verified for the current account.
 * @summary Confirm Website Verification
 */
export const confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost =
  (
    appId: string,
    params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<WebsiteVerificationResult>> => {
    return axios.post(
      `/verification/${appId}/confirm-website-verification`,
      undefined,
      {
        ...options,
        params: { ...params, ...options?.params },
        paramsSerializer: (params) =>
          qs.stringify(params, { arrayFormat: "repeat" }),
      },
    )
  }

export const getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationOptions =
  <
    TError = AxiosError<void | void | void | void | void>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
        >
      >,
      TError,
      {
        appId: string
        params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
      },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationKey = [
      "confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost",
    ]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
        >
      >,
      {
        appId: string
        params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
      }
    > = (props) => {
      const { appId, params } = props ?? {}

      return confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost(
        appId,
        params,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >
  >

export type ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationError =
  AxiosError<void | void | void | void | void>

/**
 * @summary Confirm Website Verification
 */
export const useConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost =
  <TError = AxiosError<void | void | void | void | void>, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
          >
        >,
        TError,
        {
          appId: string
          params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
        },
        TContext
      >
      axios?: AxiosRequestConfig
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost
      >
    >,
    TError,
    {
      appId: string
      params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams
    },
    TContext
  > => {
    const mutationOptions =
      getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * If the current account has verified the given app, mark it as no longer verified.
 * @summary Unverify
 */
export const unverifyVerificationAppIdUnverifyPost = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`/verification/${appId}/unverify`, undefined, options)
}

export const getUnverifyVerificationAppIdUnverifyPostMutationOptions = <
  TError = AxiosError<void | void | void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
    TError,
    { appId: string },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationKey = ["unverifyVerificationAppIdUnverifyPost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
    { appId: string }
  > = (props) => {
    const { appId } = props ?? {}

    return unverifyVerificationAppIdUnverifyPost(appId, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UnverifyVerificationAppIdUnverifyPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>
>

export type UnverifyVerificationAppIdUnverifyPostMutationError = AxiosError<
  void | void | void | void | void
>

/**
 * @summary Unverify
 */
export const useUnverifyVerificationAppIdUnverifyPost = <
  TError = AxiosError<void | void | void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
      TError,
      { appId: string },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unverifyVerificationAppIdUnverifyPost>>,
  TError,
  { appId: string },
  TContext
> => {
  const mutationOptions =
    getUnverifyVerificationAppIdUnverifyPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Switch To Direct Upload
 */
export const switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost = (
  appId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(
    `/verification/${appId}/switch_to_direct_upload`,
    undefined,
    options,
  )
}

export const getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationOptions =
  <
    TError = AxiosError<void | void | void | void | void>,
    TContext = unknown,
  >(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
        >
      >,
      TError,
      { appId: string },
      TContext
    >
    axios?: AxiosRequestConfig
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >,
    TError,
    { appId: string },
    TContext
  > => {
    const mutationKey = [
      "switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost",
    ]
    const { mutation: mutationOptions, axios: axiosOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
        >
      >,
      { appId: string }
    > = (props) => {
      const { appId } = props ?? {}

      return switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost(
        appId,
        axiosOptions,
      )
    }

    return { mutationFn, ...mutationOptions }
  }

export type SwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >
  >

export type SwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationError =
  AxiosError<void | void | void | void | void>

/**
 * @summary Switch To Direct Upload
 */
export const useSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPost =
  <TError = AxiosError<void | void | void | void | void>, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
          >
        >,
        TError,
        { appId: string },
        TContext
      >
      axios?: AxiosRequestConfig
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost
      >
    >,
    TError,
    { appId: string },
    TContext
  > => {
    const mutationOptions =
      getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostMutationOptions(
        options,
      )

    return useMutation(mutationOptions, queryClient)
  }
/**
 * @summary Archive
 */
export const archiveVerificationAppIdArchivePost = (
  appId: string,
  archiveRequest: ArchiveRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`/verification/${appId}/archive`, archiveRequest, options)
}

export const getArchiveVerificationAppIdArchivePostMutationOptions = <
  TError = AxiosError<void | void | void | void | void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
    TError,
    { appId: string; data: ArchiveRequest },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
  TError,
  { appId: string; data: ArchiveRequest },
  TContext
> => {
  const mutationKey = ["archiveVerificationAppIdArchivePost"]
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
    { appId: string; data: ArchiveRequest }
  > = (props) => {
    const { appId, data } = props ?? {}

    return archiveVerificationAppIdArchivePost(appId, data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ArchiveVerificationAppIdArchivePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>
>
export type ArchiveVerificationAppIdArchivePostMutationBody = ArchiveRequest
export type ArchiveVerificationAppIdArchivePostMutationError = AxiosError<
  void | void | void | void | void
>

/**
 * @summary Archive
 */
export const useArchiveVerificationAppIdArchivePost = <
  TError = AxiosError<void | void | void | void | void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
      TError,
      { appId: string; data: ArchiveRequest },
      TContext
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveVerificationAppIdArchivePost>>,
  TError,
  { appId: string; data: ArchiveRequest },
  TContext
> => {
  const mutationOptions =
    getArchiveVerificationAppIdArchivePostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
